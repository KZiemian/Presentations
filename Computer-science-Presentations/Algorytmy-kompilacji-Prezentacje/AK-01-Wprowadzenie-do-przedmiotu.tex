% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located in directory
% "preambule"
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Algorytmy-kompilacji-Bibliography.bib}





% ------------------------------------------------------
% Packages, libraries and their settings
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
\usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation
\usepackage{./Local-packages/local-settings}

% Stylef for drawing diagrams
\usepackage{./Local-packages/PGF-TikZ-Diagram-styles}










% ------------------------------------------------------------------------------------------------------------------
\title{Algorytmy kompilacji}
\subtitle{Wprowadzenie do~przedmiotu}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% Number of chars: 62k+, 80k+, 41k+, 36k+, 40k+,
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################





% ######################################
\section{Informacje ogólne}
% ######################################





% ##################
\begin{frame}
  \frametitle{Informacje wstępne}


  Obawiam~się, że na tych konkretnych zajęciach będzie sporo przynudzania,
  ale nie widzę sposobu, by~tego uniknąć.

  Według mnie to zajęcia są dla studentów, nie studenci dla zajęć. Tak samo
  ja jestem tu dla Państwa, a~nie Państwo dla mnie. W~związku z~tym, ja
  będę Państwa rozliczał tylko i~wyłącznie z~umiejętności i~wiedzy,
  z~niczego innego. Wychodzę bowiem z~założenia, że~Państwo sami najlepiej
  wiedzą, czemu warto poświęcić swój czas. (Choć jak dobrze wiemy, często
  po jakimś czasie stwierdzamy, że~może trzeba było wybrać coś innego.)

  Na zajęciach nie tylko można, ale \alert{należy} zadawać pytania
  na dowolne związane z~zajęciami zagadnienia. W~szczególności
  \alert{należy} zadawać pytania, jeśli~się czegoś nie rozumie, lub coś
  jest niejasne. Kompilatory to zagadnienie na którym dobrze zna się jakiś
  0.1\% informatyków, \alert{nie} zakładamy, że~Państwo należą do tej
  wąskiej grupy.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Informacje wstępne}


  Proszę pamiętać, gdy chodzi o~tematy związane z~zajęciami
  \alert{nie} ma pytań zbyt elementarnych lub zbyt głupich. Są~tylko
  niezadowalające odpowiedzi.

  Na zajęciach nie tylko można, ale \alert{należy} zadawać pytania
  na dowolne związane z~zajęciami zagadnienia. Nie ma tu pytań zbyt
  elementarnych lub zbyt głupich, są~tylko niezadowalające odpowiedzi.

  Pytania typu „Jaki jest najfajniejszy boss w~grze \textit{Hollow
    Knight}?” musimy jednak zostawić na czas po zajęciach.

  Jeśli coś jest dla Państwa tak proste, że~mówienie o~tym to marnowanie
  Państwa czasu, proszę również o~tym powiedzieć. Przeskoczymy wtedy
  do~następnej części materiału.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Uwagi odnośnie treści zajęć}


  Współczesna informatyka jest dziedziną bardzo młodą. Ma sens datowanie
  jej powstania na rok 1945, gdy technologie komputerowe rozwinięte na
  potrzeby wojskowe w~czasie II~Wojny Światowej wchodzą do użytku
  powszechnego, choć z~przyczyn czysto technicznych (koszt, rozmiar,
  zużycie energii, etc.) dostępne są tylko bardzo wąskiej
  grupie ludzi. Dziedzina o~której jest ten przedmiot nie ma jeszcze
  100~lat. Nauka ma to do siebie, że~potrafi naprawdę długo~się rozwijać,
  potrzebując niekiedy dekad jeśli nie wieków, by dokonać realnego postępu.
  W~informatyce zaś cały czas odkrywamy nowe i~kluczowe dla tej dziedziny
  rzeczy.

  W~szczególności, żyjemy teraz w~epoce intensywnego rozwoju kompilatorów,
  która raczej~się nie skończy już jutro. W~skutek tego cała masa rzeczy~się
  ciągle zmienia i~to co wczoraj uchodziło za czystą fantazję, dziś jest
  rzeczywistością wdrażaną do produkcji przemysłowej (może trochę
  przesadzam, ale nie tak bardzo). Proszę mieć to na uwadze biorąc udział
  w~zajęciach i~ucząc~się do tego kursu.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Bardzo ważne}


  Ze względu na ramy czasowe tego kursu wiele rzeczy będę
  \alert{upraszczał} lub \alert{pomijał}. Proszę o~tym pamiętać podczas
  uczęszczania na zajęcia i~czytania materiałów z~nich.

  Jeśli jednak ktoś chce~się zagłębić w~nie bardziej, po zajęciach służę
  całą moją wiedzą.

  Z~mojego doświadczenia wynika, że~ustalanie jednego terminu na konsultacje
  to nie jest dobry pomysł. W~zasadzie nikt wtedy nie przychodzi, a~ja
  wyznaję zasadę, że~konsultacje są dla Państwa, nie dla mnie. Jeśli
  Państwo chcą bym ustalił konkretne terminy na konsultacje, to proszę jako
  grupa wybrać jeden taki i~poinformować mnie o~tym mailowo, pisząc na
  adres \email.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Bardzo ważne}


  W~przeciwnym razie, jeśli ktoś z~Państwa ma problem i~chce zasięgnąć
  mojej pomocy, proszę do mnie napisać, na wspomniany już adres \email,
  kiedy, gdzie i~w~jakiej formie chcą Państwo uczestniczyć w konsultacjach.

  Mogą one być zarówno w~świecie rzeczywistym (niekoniecznie w~budynku
  \textsc{WSZiBu}), online lub telefonicznie.

  Będę wdzięczny za napisanie w~mailu z~czym konkretnie mają Państwo
  problem, rozumiem jedna, że~często wskazanie czy nazwanie tego jest
  trudne. Sam przez to przechodziłem.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Materiały do nauki}


  Prezentacje te są dostępne w~formie plików \LaTeX a (kodu źródłowego)
  na serwisie GitHub. Każdy kto ma na komputerze program Git i~dostęp
  do internetu może jest zdobyć wpisując \\
  \texttt{\$ git clone https://github.com/KZiemian/Presentation} \\
  Znajdują~się one w~katalogu „Podstawy-informatyki-ETC-Prezentacje”.

  Będą też dostępne w~formie \textsc{pdf}ów na~Sake, wraz z~innymi
  materiałami do nauki.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zgłaszanie błędu i~uwag}


  W~razie znalezienia jakiegokolwiek błędu lub jakichkolwiek uwag
  merytorycznych do zajęć lub dostępnych materiałów proszę pisać pod adres
  \email. Chcemy by te zajęcia i~towarzyszące im materiały były możliwie
  proste, łatwe w~zrozumieniu i~pozbawione błędów. Proszę jednak uwierzyć,
  że~osiągnięcie tego jest naprawdę trudne.

\end{frame}
% ##################










% ######################################
\section{Dygresja o~diagramach występujących w~tych
  prezentacjach}
% ######################################



% ##################
\begin{frame}
  \frametitle{Konwencja}


  \begin{textblock}{2.8}(2,1.5)

    \begin{tikzpicture}

      \node[diagram block] at (0,0) {Coś robi};

    \end{tikzpicture}

  \end{textblock}



  \begin{textblock}{2.8}(8,1.5)

    \begin{tikzpicture}

      \node[diagram rectangle block] at (0,0) {Czymś jest};

    \end{tikzpicture}

  \end{textblock}


  \vspace{6em}





  Bloki diagramu które mają kształt prostokąta z~zaokrąglonymi rogami,
  zwykle~są koloru niebieskiego, oznaczają \textbf{aktorów}, czyli
  taki obiekt który wykonuje jakąś czynność na zadanych obiektach
  wejściowych, tworząc obiekty wyjściowe. Takim obiektem może być człowiek,
  komputer, program komputerowy, fragment programu komputerowego,~etc.

  Bloki diagramu które mają kształt prostokąta z~ostrymi rogami, zwykle~są
  koloru karmelowego (czy to jest kolor karmelowy?), przedstawiają
  \textbf{obiekty} które są pobierane na~wejście przez aktorów lub przez
  nich wytwarzane i~zwracane na wyjście. Jeśli aktorem jest kucharz to na
  wejście może pobierać jaka, mąkę, etc., a~na wyjściu zwracać naleśniki
  z~truskawkami.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przykładowy diagram}


  Konwencję tą ilustruje poniższy, zrobionym z~przymrużeniem oka, diagram.
  Przedstawia on proces tworzenia przez człowieka za pomocą klawiatury
  i~komputera programu w~języku programowania~C.





  \begin{figure}

    \label{fig:Creating-code-in-C}

    \begin{tikzpicture}

      \node[diagram block] (Man) at (0,0) {Człowiek};

      \node[diagram block] (Keyboard) at (3.8,0) {Klawiatura};

      \draw[thick diagram arrow] (Man) -- (Keyboard);



      \node[diagram block] (Computer) at (7.6,0) {Komputer};

      \draw[thick diagram arrow] (Keyboard) -- (Computer);



      \node[diagram rectangle block] (Source code) at (7.6,-2.5)
      {Kod źródłowy w~języku~C};

      \draw[thick diagram arrow] (Computer) -- (Source code);

    \end{tikzpicture}

    \caption{Diagram ilustrujący tworzenie kodu w~języku~C.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Inny diagram}


  Czy poniższy diagram jest lepszy czy gorszy od poprzedniego? Zależy
  od~tego jakie informacje ma dany diagram przekazywać. Proszę~się więc nie
  dziwić, jeśli na danym diagramie czegoś nie ma, a~nawet, że~nie ma czegoś
  co było na poprzedniej wersji diagramu. Zawsze trzeba dokonać selekcji co
  na diagramie zostanie umieszczone, a~co nie i~ten wybór często zależy
  od kontekstu.

  Jeśli uważają Państwo, że~na diagramie nie ma czegoś, co być powinno,
  albo coś innego jest nie w~porządku, \alert{proszę} mi zwrócić na to
  uwagę. Całkiem możliwe, że~popełniłem błąd rysując dany diagram.






  \begin{figure}

    \label{fig:Also-creating-code-in-C}

    \begin{tikzpicture}

      \node[diagram block] (Man) at (0,0) {Człowiek};

      \node[diagram rectangle block] (Source code) at (3.8,0)
      {Kod źródłowy w~języku~C};

      \draw[thick diagram arrow] (Man) -- (Source code);

    \end{tikzpicture}

    \caption{Inna wersja diagramu ilustrującego tworzenie kodu w~języku~C.}


  \end{figure}

\end{frame}
% ##################










% ######################################
\section{Spojrzenie na~przedmiot z~lotu ptaka}
% ######################################



% ##################
\begin{frame}
  \frametitle{Czy ten kurs jest praktyczny?}


  Jeśli kiedyś napisaliście Państwo i~uruchomili program w~języku C, C++,
  Fortran, Go, Java, Rust, etc., to na $99\%$ korzystali Państwo
  z~kompilatora. W~2024 cała infrastruktura informatyczna stoi
  na~kodzie napisany w~języku~C, który odpowiednie kompilatory przetworzyły
  w~programy komputerowe. W~tym sensie kurs ten jest superpraktyczny, bo
  ktoś te kompilatory musi pisać.

  Jeśli jednak nie mają Państwo zamiaru zajmować~się zawodowo pracą nad
  kompilatorami, jak przytłaczająca większość informatyków, to ten kurs nie
  będzie miał jakiejś szczególnie wielkiej wartości praktycznej dla Państw.
  Niemniej nawet w~takiej sytuacji mogą Państwo wynieść z~niego jakąś
  wiedzę i~umiejętności, które potencjalnie pozwoli wam później tworzyć
  bardziej wydajne programy. Jeśli mamy jakieś wyobrażenie na temat tego
  jak kompilator działa, to możemy mu ułatwić tworzenie wydajny programów.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}

  \pause


  Żeby komputer coś zrobił musimy więc mu przekazać polecenie w~języku,
  który rozumie. Dla mnie pierwotny językiem jest język polski, co zaś
  jest pierwotnym językiem komputera? Na potrzeby tego kursu przyjmiemy,
  że~pierwotnym językiem komputera jest \textbf{język asemblera}
  (ang. \textit{assembly language}).

  Tak jak niektórzy ludzie mają jako swój pierwotny język angielski,
  hiszpański, japoński, niemiecki, polski, etc., tak komputer również
  posługują~się różnymi rodzajami języka asembler, takimi jak \textsc{arm}
  czy x86/Intel. Można też wymienić dialekty asemblera \textsc{gas},
  \textsc{fasm}, \textsc{masm}, \textsc{nasm}, \textsc{yasm} (Kto wymyśla
  te nazwy?).

  Różnica między komputerem, a~człowiekiem jest taka, że~pojedynczy człowiek
  poza swoim pierwotnym językiem, może znać kilka innych (angielski,
  arabski, chiński, farsi, francuski, hiszpański, japoński, niemiecki,
  polski, etc.). Komputery zwykle rozumieją tak naprawdę tylko
  \alert{jeden jedyny} język: właściwy mu dialekt asemblera.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}


  To który dialekt asemblera rozumiem komputer jest ustalony przez firmę,
  która wyprodukowała jego procesor. Asembler jest bowiem zakodowany w~tym
  jak są „podpięte kable” w~danym procesorze.

  By lepiej zrozumieć dlaczego potrzebujemy kompilatorów, przedstawimy
  teraz jeden program, który wypisuje „Hello, World!” na ekranie, napisany
  w~dialektach asemblera \textsc{arm~32}, AArch64, \textsc{risc-v},
  \textsc{nasm} i~x86/Intel oraz językach C i~Python.

  Poza wersją programu w~języku asemblera x86/Intel, wszystkie te programy
  przetestowałem na~moim komputerze pod systemem GNU/Linux Ubuntu
  22.04~\textsc{lts}, więc jeśli są chętni, to możemy je~głębiej omówić
  po~zajęciach.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze ARM~32,
    \parencite{Low-Level-Learning-You-Can-Learn-ARM-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x4} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr r1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov r2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#65} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze AArch64,
    \parencite{Low-Level-Learning-You-Can-Learn-AArch64-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov x8, \#64} \\
  \hphantom{aaaaaaaa} \texttt{mov x0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr x1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov x2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#65} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze RISC-V
    \parencite{Anonymous-Hello-World-in-x86-Assembly-Language}}


  \texttt{.global \_start} \\
  \texttt{\_start:} \\
  \hphantom{aaaa} \texttt{addi a7, zero, 64} \\
  \hphantom{aaaa} \texttt{addi a0, zero, 1} \\
  \hphantom{aaaa} \texttt{la a1, helloworld} \\
  \hphantom{aaaa} \texttt{addi a2, zero, 14} \\
  \hphantom{aaaa} \texttt{ecall}
  \vspace{0.8em}

  \hphantom{aaaa} \texttt{a7, zero, 93} \\
  \hphantom{aaaa} \texttt{a0, zero, 13} \\
  \hphantom{aaaa} \texttt{ecall}
  \vspace{0.8em}

  \texttt{helloworld:} \\
  \hphantom{aaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze NASM
    \parencite{Toal-NASM-Tutorial-Ver-2024}}


  \hphantom{aaaaaaaaa} \texttt{global} \hphantom{aa} \texttt{\_start} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section} \hphantom{a} \texttt{.text} \\
  \texttt{\_start:} \hphantom{a} \texttt{mov} \hphantom{aaaaaa}
  \texttt{rax, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdi, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa}
  \texttt{rsi, message} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdx, 14} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rax, 60} \\
  \hphantom{aaaaaaaaa} \texttt{xor} \hphantom{aaaaaa} \texttt{rdi, rdi} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section .data} \\
  \vspace{0.8em}

  \texttt{message: db} \hphantom{aaaaa} \texttt{"Hello, World!", 10}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze x86/Intel
    \parencite{Anonymous-Hello-World-in-x86-Assembly-Language}}


  \texttt{org 0x100} \\
  \vspace{0.8em}

  \texttt{mov dx, msg} \\
  \texttt{mov ah, 9} \\
  \texttt{int 0x21} \\
  \vspace{0.8em}

  \texttt{mov ah, 0x4c} \\
  \texttt{int 0x21} \\
  \vspace{0.8em}

  \texttt{msg db 'Hello, World!', 0x0d, 0x0a, '\$'}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~C}


  \texttt{\#include <stdio.h>} \\
  \vspace{0.8em}
  \texttt{int main() \{ } \\
  \hphantom{aaaa} \texttt{printf("Hello, World!\textbackslash n");} \\
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \hphantom{aaaa} \texttt{return 0;} \\
  \texttt{ \} }

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~Python}


  \texttt{print("Hello, World!")}

\end{frame}
% ##################




% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}


  Na pierwszy rzut oka powinno być jasne, że~C jest prostszy od~asemblera,
  a~Python prostszy od~C. Dlaczego tak jest, to niestety temat na inny
  przedmiot, acz o~kilka elementów tego zagadnienia uda nam~się zahaczyć.

  Większość ludzi zrobi wszystko, by tylko uniknąć pracy w~asemblerze.
  Mam nadzieję, że~nie muszę tłumaczyć dlaczego.  A~nawet jeśli
  znajdzie~się człowieka, który lubi w~nim pisać, to unika~się jak tylko
  można tego, by kod napisany przez niego w~asemblerze wszedł w~skład
  danego programu.

  Jest tak dlatego, że~nawet najlepsi programiści zbyt łatwo mylą~się
  pisząc w~asemblerze, a~pomyłki na jego poziomie są szczególnie
  niebezpieczne. Jeśli są zainteresowani, to możemy omówić ten temat
  szerzej, ale tylko po zajęciach. Wykracza on bowiem mocno poza zakres tego
  przedmiotu.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}


  Co więc robimy by uniknąć pisania kodu w~języku asemblera? Tworzymy
  język programowania taki jak~C czy Python, który jest dla nas prostszy
  w~użyciu, niż dany dialekt asemblera i~piszemy program w~nim. Proszę
  zwrócić uwagę, że~słowo „prostszy” wcale nie oznacza \alert{„prosty”}!

  Dobrze, ale komputer dalej rozumie tylko język asembler, a~nie~C czy
  Pytona, co więc musimy zrobić, by uruchomić programy napisany w~jednym
  z~tych języków? Potrzebny jest nam program komputerowy zwany
  \textbf{translatorem}, który \alert{przetłumaczy} kod napisany,
  przykładowo z~języka~C na język asemblera.





  \begin{figure}

    \label{fig:Translator-01}

    \begin{tikzpicture}% [node distance=0.8]

      \node[diagram rectangle block] (Source code in C) at (0,0)
      {Kod programu (język C)};

      \node[diagram block,right=of Source code in C] (Translator)
      {Translator};

      \draw[thick diagram arrow] (Source code in C) -- (Translator);



      \node[diagram rectangle block,right=of Translator] (Code in assembly)
      {Kod programu (język asemblera)};

      \draw[thick diagram arrow] (Translator) -- (Code in assembly);

    \end{tikzpicture}

    \caption{Ilustracja działania translatora.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka uwag uzupełniających}


  \alert{Dygresja.} Czy ktoś z~Państwa korzystał z~emulatora do gier?
  Choćby po to by uruchomić grę \textit{Pokemon Yellow/Red/Blue}
  przeznaczoną na GameBoya na swoim PCecie? (To nie jedyny emulator do gier
  z~którego korzystałem.) Na tej samej zasadzie działają emulatory
  asemblerów, pozwalające uruchomić asemblera x86 na procesorze
  zbudowanym w~architekturze \textsc{arm}.

\end{frame}
% ##################





% ##################
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% ##################




















% ######################################
\section{Praktyczny problem}
% ######################################



% ##################
\begin{frame}
  \frametitle{Kilka słów przypomnienia}


  Jak mówiliśmy wcześniej, na potrzeby tego kursu będziemy przyjmować,
  że~naturalnym językiem komputera jest język asembler i~nie będziemy
  wnikać głębiej w~to co~się tam dzieje. Jeśli jednak ktoś chce wniknąć
  głębiej w~to zagadnienie, to po zajęciach służę całą moją wiedzą w~tym
  temacie.

  \alert{Uwaga terminologiczna.} W~języku angielskim rozróżnia~się
  \textbf{język asemblera} (ang. \textit{assembly langauge})
  i~\textbf{program asembler} (ang. \textit{assembler}), który operuje
  na~programie napisany w~języku danego asemblera. W~języku polskim
  „asembler” oznacza często język asembler, co może powodować pewne
  nieporozumienia.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Typowy sposób wykonywania programu}


  Aby opisać jak z~grubsza wygląda wykonanie dowolnego programu na
  komputerze muszę wprowadzić pewną dozę uproszczeń. Po~pierwsze
  przyjmijmy, że~gra \textit{Hollow Knight} (nie gorszy przykład programu,
  niż dowolny inny), zawiera~się w~jednym pliku napisany w~języku asembler.
  Proces uruchamiania tej gry pokazuje poniższy diagram.





  \begin{figure}

    \label{fig:Running-Hollow-Knight-bad}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Hollow Knight) at (0,0)
      {\textit{Hollow Knight} (język asemblera)};

      \node[diagram block,right=of Hollow Knight] (Computer) {Komputer};

      \draw[thick diagram arrow] (Hollow Knight) -- (Computer);



      \node[diagram block,right=of Computer] (Playable computer)
      {Komputer z~włączoną grą \textit{HK}};

      \draw[thick diagram arrow] (Computer) -- (Playable computer);

    \end{tikzpicture}

    \caption{Typowy sposób uruchamiania programu na~komputerze.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pisanie gier w~języku asembler?}


  Jak już wspomnieliśmy, pisanie czegokolwiek, w~tym gier wideo, w~języku
  asemblera to zwykle nie jest dobry pomysł. Znanym przykładem tego, że~jest
  to możliwe, jest gra \textit{RollerCoaster Tycoon} z~1999 roku, którą
  napisał \alert{w~pojedynkę} Chris Sawyer.





  \begin{figure}

    \label{fig:Feel-even-worse}

    \centering


    \includegraphics[scale=0.275]
    {./Presentations-pictures/Feel-even-worse.jpg}

  \end{figure}

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{?????}


  Dzisiaj gry często tworzy~się środowiskach takich jak
  \colorhref{https://www.unrealengine.com/en-US}{Unreal Engine},
  \colorhref{https://unity.com/}{Unity} czy
  \colorhref{https://godotengine.org/}{Godot}, nie zaś pisze kod źródłowy
  od zera. Unreal Engine i~Godot są napisane w~większości w~języku C++,
  Unity w~języku C\#. W~tym momencie nie mam pewności, w~czym został
  napisany \textit{Hollow Knight}, ale mędrcy internetu twierdzą,
  że~głównie w~języku C\#, bo został napisany w~Unity. Dlaczego jednak
  poniższy diagram jest błędny?





  \begin{figure}

    \label{fig:Running-Hollow-Knight-good}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Hollow Knight) at (0,0)
      {\textit{Hollow Knight} (język C\#)};

      \node[diagram block,right=of Hollow Knight] (Computer) {Komputer};

      \draw[thick diagram arrow] (Hollow Knight) -- (Computer);



      \node[diagram block,right=of Computer] (Playable computer)
      {Komputer z~włączoną grą \textit{HK}};

      \draw[thick diagram arrow] (Computer) -- (Playable computer);

    \end{tikzpicture}

    \caption{Błędny sposób uruchamiania gry \textit{Hollow Knight}}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{??? }


  Komputer jako taki nie rozumie języka~C\#, więc nie jest w~stanie
  uruchomić gry napisanej w~takim języku. Aby ją uruchomić, translator
  musi najpierw przetłumaczyć ją na język asemblera.





  \begin{figure}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Hollow Knight in C-sharp) at (0,0)
      {\textit{Hollow Knight} (język C\#)};

      \node[diagram block,right=of Hollow Knight in C-sharp] (Translator)
      {Translator};

      \draw[thick diagram arrow] (Hollow Knight in C-sharp) -- (Translator);



      \node[diagram rectangle block,right=of Translator]
      (Hollow Knight in assembly)
      {\textit{Hollow Knight} (język asemblera)};

      \draw[thick diagram arrow] (Translator) -- (Hollow Knight in assembly);



      \node[diagram block,below=of Hollow Knight in assembly] (Computer)
      {Komputer};

      \draw[thick diagram arrow] (Hollow Knight in assembly) -- (Computer);


      \node[diagram block,left=of Computer]
      (Computer running Hollow Knight)
      {Komputer z~włączoną grą \textit{HK}};

      \draw[thick diagram arrow]
      (Computer) -- (Computer running Hollow Knight);

    \end{tikzpicture}

    \caption{Poprawny sposób włączania gry \textit{Hollow Knight}.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czy to znaczy\ldots}


  Mogą~się Państwu nasunąć taka myśl.

  „Ja coś słyszałem, że~istnieje oprogramowanie o~otwarty kodzie, jak
  system operacyjny GNU/Linux i~o~zamkniętym kodzie, takie jak system
  Windows. Każdy może przeczytać kod źródłowy otwartego oprogramowania,
  ale tego o~zamkniętym kodzie tylko ci którzy pracują dla takich firm jak
  Microsoft. A~Pan tu twierdzi, że~program który dostaję na moim komputerze
  jest napisany w~języku assemblera, więc jeśli tylko otworzę ten program
  i~zrozumiem asemblera wewnątrz niego, to tak jakby miał on otwarty kod.
  Po co więc całe to rozróżnienie na kod otwarty i~zamknięty?”

  Wszystko to prawda. Haczyk tkwi w~stwierdzeniu \alert{„zrozumiem asemblera
    wewnątrz niego”}. Zrozumienie działania kodu źródłowego w~języku~C,
  czy~Python jest często nieznośnie trudne, a~język asembler czyni to
  zadanie jeszcze mniej przyjemnym.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Proszę~się nie poddawać}


  Proszę~się jednak nie poddawać i~pamiętać, że~„każdy program ma otwarty
  kod, jeśli potrafisz przeprowadzić jego inżynierię wsteczną” (org.
  „Everything is open source, if you can reverse engineering it.”,
  \parencite{Low-Level-Learning-Everything-is-open-source-if-ETC-Ver-2023})~;).

  \vspace{1.5em}





  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x4} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr r1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov r2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hspace{5em} \vdots

\end{frame}
% ##################





% ##################
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% ##################










% ######################################
\section{Translatory, kompilatory i~interpretery}
% ######################################



% ##################
\begin{frame}
  \frametitle{Translatory}


  W~tym momencie już mam nadzieję wszyscy rozumiemy, czemu potrzebujemy
  kompilatorów. Zanim jednak przejdziemy dalej, potrzebujemy, choć to może
  być dość nudne, wprowadzić trochę nowych pojęć i~doprecyzować odrobinę
  terminologię.

  \textbf{Translator} to dowolny obiekt który tłumaczy tekst z~języka~A,
  na odpowiedni tekst w~języku~B. Wedle tej definicji człowiek tłumaczący
  z~polskiego na angielski też jest translatorem. To nie jest bug tej
  definicji, to jest jej feature.

  Bardziej formalnie, język~A nazywamy \textbf{językiem źródłowym}
  (ang.~\textit{source language}), a~język~B \textbf{językiem wynikowym}
  (ang.~\textit{target language}).

  % W~kontekście języków programowania, słowo „tekst” będzie dla nas
  % równoważne słowu „program”, choć intuicyjnie przez „program” rozumiemy
  % obiekt, który można uruchomić w~komputerze. Wedle tej definicji niektórych
  % programów nie da się uruchomić, bez użycia na nich translatora, ale~to
  % nie powinno stwarzać prawdziwych problemów.





  \begin{figure}

    \label{fig:Translator-01}


    \begin{tikzpicture}

      \node[diagram rectangle block] (Text in language A) at (0,0)
      {Tekst w~języku~A};

      \node[diagram block,right=of Text in language A] (Translator)
      {Translator};

      \draw[thick diagram arrow] (Text in language A) -- (Translator);


      \node[diagram rectangle block,right=of Translator]
      (Text in language B)
      {Tekst w~języku~B};

      \draw[thick diagram arrow] (Translator) -- (Text in language B);

    \end{tikzpicture}

    \caption{Sposób działania translatora}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Translatory}


  % W~tym momencie już mam nadzieję wszyscy rozumiemy, czemu potrzebujemy
  % kompilatorów. Zanim jednak przejdziemy dalej, potrzebujemy, choć to może
  % być dość nudne, wprowadzić trochę nowych pojęć i~doprecyzować odrobinę
  % terminologię.

  % \textbf{Translator} to dowolny obiekt który tłumaczy tekst z~języka~A,
  % na odpowiedni tekst w~języku~B. Wedle tej definicji człowiek tłumaczący
  % z~polskiego na angielski też jest translatorem. To nie jest bug tej
  % definicji, to jest jej feature.

  W~kontekście języków programowania, słowo „tekst” będzie dla nas
  równoważne słowo „kod” i~„program”, choć intuicyjnie przez „program”
  rozumiemy obiekt, który można od razu uruchomić na~komputerze. Jednak nie
  możemy tak po prostu uruchomić programu (tekstu kodu źródłowego)
  napisanego w~języku~C, bo komputer rozumie tylko swój dialekt języka
  asembler. Musimy najpierw przetłumaczyć go odpowiednim translatorem na ów
  dialekt i~dopiero nowy program jesteśmy w~stanie uruchomić. Mam jednak
  nadzieję, że~ta kwestia nie będzie prowadzić do nieporozumień.

  Będziemy więc mówić o~„kodzie źródłowym” (ang. \textit{source code})
  i~„kodzie wynikowym” (ang. \textit{target code}).

  % \begin{figure}

  %   \label{fig:Translator-01}


  %   \begin{tikzpicture}

  %     \node[diagram rectangle block] (Text in language A) at (0,0)
  %     {Tekst w~języku~A};

  %     \node[diagram block,right=of Text in language A] (Translator)
  %     {Translator};

  %     \draw[thick diagram arrow] (Text in language A) -- (Translator);


  %     \node[diagram rectangle block,right=of Translator]
  %     (Text in language B)
  %     {Tekst w~języku~B};

  %     \draw[thick diagram arrow] (Translator) -- (Text in language B);

  %   \end{tikzpicture}

  %   \caption{Sposób działania translatora}


  % \end{figure}

  \begin{figure}

    \label{fig:Translator-02}


    \begin{tikzpicture}

      \node[diagram rectangle block] (Source code) at (0,0)
      {Kod źródłowy};

      \node[diagram block,right=of Source code] (Translator)
      {Translator};

      \draw[thick diagram arrow] (Source code) -- (Translator);



      \node[diagram rectangle block,right=of Translator]
      (Target code)
      {Kod wynikowy};

      \draw[thick diagram arrow] (Translator) -- (Target code);

    \end{tikzpicture}

    \caption{Sposób działania translatora}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Translatory}


  W~definicji translatora jest powiedziane, że~tłumaczy on tekst
  w~języku~A, na \alert{odpowiedni} tekst w~języku~B. Co jednak znaczy
  słowo „odpowiedni”? Odpowiedź na to pytanie jest zaskakująco trudna
  i~złożona, zarówno jeśli chodzi o~tłumaczenie z~języka angielskiego
  na~polski, czy~z~C na~dialekt asemblera i~dokładne wyjaśnienie wykracza
  poza zakres tego przedmiotu. Ogólnie rzecz biorąc korzystamy tu
  z~koncepcji czarnej skrzynki: programy są równoważne, jeśli przy tych
  samych danych wejściowych dają te same dane wyjściowe.%  Co jest w~środku
  % danego programu (czarnej skrzynki) nas nie obchodzi. Może tam być i~smok
  % wykonujący odpowiednia działania, byleby tylko rezultat był poprawny.



  \begin{figure}

    \label{fig:Translator-03}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Source code) at (0,0)
      {Kod źródłowy};

      \node[diagram block,fill=black,right=of Source code] (Translator)
      {Translator (czarna skrzynka)};

      \draw[thick diagram arrow] (Source code) -- (Translator);



      \node[diagram rectangle block,right=of Translator]
      (Target code)
      {Kod wynikowy};

      \draw[thick diagram arrow] (Translator) -- (Target code);

    \end{tikzpicture}

    \caption{Translator jako czarna skrzynka}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Translatory}


  % W~definicji translatora jest powiedziane, że~tłumaczy on tekst
  % w~języku~A, na \alert{odpowiedni} tekst w~języku~B. Co jednak znaczy
  % słowo „odpowiedni”? Odpowiedź na to pytanie jest zaskakująco trudna
  % i~złożona, zarówno jeśli chodzi o~tłumaczenie z~języka angielskiego
  % na~polski, czy~z~C na~dialekt asemblera i~dokładne wyjaśnienie wykracza
  % poza zakres tego przedmiotu. Ogólnie rzecz biorąc korzystamy tu
  % z~koncepcji czarnej skrzynki: programy są równoważne, jeśli przy tych
  % samych danych wejściowych dają te same dane wyjściowe.
  Co jest w~środku danego programu (czarnej skrzynki) nas nie obchodzi.
  Może tam być i~smok wykonujący odpowiednia działania, byleby tylko
  na zadane dane wejściowa, dawał poprawną odpowiedź na wyjściu.

  Od translatora będziemy więc żądać, by~przetwarzał kod źródłowy
  na równoważny mu kod wynikowy.





  \begin{figure}

    \label{fig:Translator-04}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Source code) at (0,0)
      {Kod źródłowy};

      \node[diagram block,fill=black,right=of Source code] (Translator)
      {Translator (czarna skrzynka)};

      \draw[thick diagram arrow] (Source code) -- (Translator);



      \node[diagram rectangle block,right=of Translator]
      (Target code)
      {Kod wynikowy};

      \draw[thick diagram arrow] (Translator) -- (Target code);

    \end{tikzpicture}

    \caption{Translator jako czarna skrzynka}


  \end{figure}

\end{frame}
% ##################




% ##################
\begin{frame}
  \frametitle{Rodzaje translatorów}


  Wyróżniamy dwa główne typy translatorów, \textbf{kompilatory}
  i~\textbf{interpretery}. Dawno temu można było dość łatwo podzielić
  języki programowania na języki kompilowane, czyli takie których translator
  jest kompilatorem i~języki interpretowane, zdefiniowane tak samo.
  Typowymi językami kompilowanymi były C i~C++, a~typowym językiem
  interpretowany Python.

  Jednak najmniej $2010$ roku sprawa ta nie jest taka prosta, ale ten
  podział jest wciąż bardzo użyteczny, gdy chcemy zrozumieć podstawy. Do
  tego jak dzisiaj to wygląda, może wrócimy w~dalszej części zajęć.

  \textbf{Kompilator} to translator, który analizuje program w~języku
  źródłowym i~tworzy obiekt zawierający program w~języku wynikowym.
  Kompilator \alert{tylko} przekłada kod z~jednego języka na drugi
  i~zapisuje wynik w~odpowiednim pliku, ale \alert{nie} uruchamia
  otrzymanego programu. Używając prostego przykładu, kompilator
  przetłumaczy „Eat the soup.” na „Zjedz zupę.”, ale nie powie nikomu,
  że~ma zjeść zupę.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kompilator}


  Dla ustalenia uwagi, przyjmijmy, że~językiem źródłowym jest~C
  (Czy Państwo dobrze znają ten język?), a~językiem docelowym dialekt
  asemblera.

  W~przypadku języków kompilowanych mamy więc rozdział na \textbf{fazę
    kompilacji} (fazę translacji) i~\textbf{fazę wykonania programu}.
  W~fazie kompilacji niezrozumiały dla komputera program w~języku~C,
  jest tłumaczony na zrozumiały dla niego program w~dialekcie asemblera
  („Eat soup.” $\mapsto$ „Zjedz zupę.”). W~fazie wykonania program jest
  uruchamiany i~komputer realizuje zawarte w~nim polecenia (ktoś dostaje
  informację „Zjedz zupę.” i~zaczyna ją jeść).





  \begin{figure}

    \label{fig:Translator-04}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Source program) at (0,0)
      {Program źródłowy (język~C)};

      \node[diagram block,right=of Source program] (Compiler)
      {Kompilator};

      \draw[thick diagram arrow] (Source program) -- (Compiler);



      \node[diagram rectangle block,right=of Compiler]
      (Target program)
      {Program wynikowy (dia. asemblera)};

      \draw[thick diagram arrow] (Translator) -- (Target program);

    \end{tikzpicture}

    \caption{Translator jako czarna skrzynka}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Faza kompilacji i~faza wykonania}


  \begin{figure}

    \begin{tikzpicture}[node distance=0.5]

      \node[diagram rectangle block] (Source code) at (0,0) {Kod źródłowy};

      \node[diagram block,below=of Source code] (Compiler) {Kompilator};

      \draw[thick diagram arrow] (Source code) -- (Compiler);



      \node[diagram rectangle block,below=of Compiler] (Target program)
      {Program wynikowy};

      \draw[thick diagram arrow] (Compiler) -- (Target program);



      \node[below=0.1em of Target program] {a) Faza kompilacji};






      \begin{scope}[xshift=5cm]


        \node[diagram rectangle block] (Input) at (0,0) {Wejście};

        \node[diagram block,below=of Input] (Running target program)
        {Uruchomiony program wynikowy};

        \draw[thick diagram arrow] (Input) -- (Running target program);



        \node[diagram rectangle block,below=of Running target program]
        (Results) {Wyniki działania programu};

        \draw[thick diagram arrow] (Running target program) --
        (Results);



        \node[below=0.1em of Results] {b) Faza wykonania};

      \end{scope}

    \end{tikzpicture}

    \caption{Ilustracja podziału na fazę kompilacji i~wykonania programu}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak to wygląda w~praktyce?}


  Załóżmy, że~pracuję na komputerze z~systemem operacyjny GNU/Linux i~mam
  kod źródłowy w~języku~C o~nazwie \texttt{helloWorld.c}. Polecenie \\
  \texttt{\$ gcc --std=c99 -pedantic helloWorld.c -o outProg} \\
  wykonuje fazę kompilacji kodu źródłowego \texttt{helloWorld.c}
  dając w~rezultacie program wynikowy \texttt{outProg}.

  Faza wykonania polega na wywołaniu polecenia \\
  \texttt{\$ ./outProg} \\
  w~wyniku którego na ekranie zobaczymy napis \texttt{Hello, World!}.

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Interpreter}


  \textbf{Interpreter} to translator, który tłumaczy polecenia zawarte
  w~kodzie źródłowym na operacje kodu wynikowego i~natychmiast je wykonuje.
  Interpreter \alert{nie} tworzy obiektu zawierającego program wynikowy.
  Wszystkie rezultaty jego działania idą bezpośrednio na procesor i~tam
  znikają (zostają nadpisane przez nadchodzące dane).

  Używając poprzedniego przykładu, gdy interpreter dostaje string „Eat
  soup.”, natychmiast mówi komuś „Zjedz zupę.” i~ta osoba zaczyna jeść.





  \begin{figure}

    \begin{tikzpicture}

      \node[diagram rectangle block] (Source code) at (0,0) {Kod źródłowy};

      \node[diagram block,right=of Source code] (Interpreter)
      {Interpreter};

      \draw[thick diagram arrow] (Source code) -- (Interpreter);



      \node[diagram rectangle block,above=1.5em of Interpreter] (Input)
      {Wejście};

      \draw[thick diagram arrow] (Input) -- (Interpreter);



      \node[diagram rectangle block,right=of Interpreter] (Results)
      {Wynik działania programu};

      \draw[thick diagram arrow] (Interpreter) -- (Results);

    \end{tikzpicture}

    \caption{Ilustracja działania interpretera}


  \end{figure}

\end{frame}
% ##################





% % ##################
% \begin{frame}
%   \frametitle{}




% \end{frame}
% % ##################





% ##################
\begin{frame}
  \frametitle{?????}


  Dwa najważniejsze dzisiaj zbiory instrukcji architektury to
  \alert{\textsc{cisc}} i~\alert{\textsc{risc}}.

  Akronim \textsc{cisc} pochodzi od angielskiego \textit{Complex
    Instruction Set Computing}, czyli „obliczenia za pomocą zbioru
  złożonych instrukcji”. Architektura ta charakteryzuje~się dużą ilością
  instrukcji wykonujących złożone (stąd nazwa) operacje, które wykonanie
  może zajmować wiele cykli procesora.

  Natomiast nazwa \textsc{risc} jest od \textit{Reduced Instruction Set
    Computing}, czyli „obliczenia za pomocą zbioru zredukowanych
  instrukcji”. W~architekturze tej dominują małe instrukcje, które są
  wykonywane w~jednym lub kilku cyklach procesora. Nazwa wzięła~się
  stąd, że~instrukcje w~niej stosowane, miały~się być zredukowaną wersją
  instrukcji architektury \textsc{cisc}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{????}


  W~praktyce trudno wskazać procesor który byłby czystą realizacją
  \textsc{cisc} albo \textsc{risc}. Jednak w~dobrym przybliżeniu procesor
  x86/Intel to \textsc{cisc}, zaś \textsc{arm} to \textsc{risc}. Od~2021
  roku dużo szumu jest wokół architektury \textsc{risc-v}, ale to temat na
  inne zajęcia.

\end{frame}
% ##################











% ##################
\begin{frame}
  \frametitle{Krótka i~niezbyt poprawna historia problemu}


  Na~przestrzeni tysięcy lat ludzie tworzyli urządzenia, które dziś
  rozpoznajemy jako prekursorów współczesnych komputerów, wypada wymienić
  kilku z~nich, którzy działali przed rokiem 1900-nym.

  \textbf{2003 r.} Chris Lattner i~Vikram Adve tworzą system \textsc{llvm}.
  Możemy przyjąć, że~w~tym momencie zaczyna~się okres rozwoju technik
  kompilacji w~którym jesteśmy dziś (2024 rok).

\end{frame}
% ##################



























% % ######################################
% \section{????}
% % ######################################
























% ######################################
\section{Informacje dodatkowe}
% ######################################









% ##################
\begin{frame}
  \frametitle{?????}




\end{frame}
% ##################











% % ##################
% \begin{frame}
%   \frametitle{Rendering without perspective}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Rendering with perspective}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Basic concepts of computer graphics}






% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Data structures}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{From vertices to fragments}



% \end{frame}
% % ##################











% % ##################
% \begin{frame}
%   \frametitle{Vertex attributes}




% \end{frame}
% % ##################






% % ##################
% \begin{frame}
%   \frametitle{Basic concepts of computer graphics}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Primitives in the OpenGL library}



% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Primitives in the OpenGL library}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Primitives in the OpenGL library}



% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Primitives in the OpenGL library}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Primitives in the OpenGL library (deprecated since ver.~3.1)}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Texturing and blending}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Texturing and blending}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Communication between CPU and GPU}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Data stored in the video memory}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Data stored in the video memory}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Graphics pipeline (rendering pipeline)}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Basic concepts of computer graphics}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Basic concepts of computer graphics}





% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Basic concepts of computer graphics}





% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Vertex transformations (OpenGL nomenclature)}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}[label=Przestrzen-uklad-wspolrzednych-1]
%   \frametitle{Spaces --~coordinate systems}





% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Spaces --~coordinate systems}





% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Rasterization and fragment operations}





% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{}




% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Fragment operations}






% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Basic concepts of computer graphics}





% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{Links}


%   [1] \colorhref{www.blender.org}{www.blender.org}

% \end{frame}
% % ##################










% % ######################################
% \appendix
% % ######################################





% % ##################
% \GeometryThreeDTwoSpecialEndingSlidesEN{Questions? Thank you for your attention.}
% % ##################



% % % ##################
% % \jagiellonianendslide{Dziękuję za~uwagę.}
% % % ##################





% ######################################
% \section{Dodatkowe informacje}
% ######################################



% ##################
\begin{frame}
  \frametitle{Historia języków asemblera}


  W~$1978$ roku firma Intel (od ang.~\textit{INTegrated ELectronic})
  wypuszcza procesor $8086$, który rozpoczyna rodzinę procesorów
  $\text{x}86$. Nazwa „$\text{x}86$” wywodzie~się od tego, że~liczby
  będące nazwami procesorów miały~się kończyć na „$86$”, więc symbol
  „$\text{x}$” oznacza pozostałą część tej liczby. W~następny latach
  pojawiły~się procesory $80186$, $80286$ i~$80386$. Z~powodu praw
  autorskich i~spraw pokrewnych, procesor który powinien~się nazywać
  $80586$ został przemianowany na Pentium. I~tak dalej. Język asembler
  stworzony dla tych procesorów nosi nazwę \alert{x86}, używa~się również
  bardziej precyzyjnego określenia \alert{x86/Intel}.

  Jeśli~się Państwo zastanawiają „Skąd oni biorą te nazwy dla procesorów?”,
  to powiem, że~też chciałbym wiedzieć.

  W~$2003$ roku firma \textsc{amd} (od ang.~\textit{Advanced Micro Devices})
  wypuszcza 64-bitowy procesor Athlon~64 z~językiem asemblera o~nazwie
  \textsc{amd}64, wzorowanym na języku x86/Intel.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{???}


  Zbiorczą nazwą stosowną dla 64-bitowych asemblerów \textsc{amd} i~Intela
  jest \alert{x86-64} lub \alert{x64}. Niektórzy używają również nazwy
  \alert{\textsc{amd}64}.

  W~1983 roku firma Acorn Computers Ltd. zaczyna pracę nad procesorem który
  zostanie nazwany \alert{\textsc{arm}} (od ang.~\textit{Acorn \textsc{risc}
    Machine}). Jednym z~wyników tego projektu jest opracowanie zbioru
  instrukcji architektury \textsc{risc} (ang.~\textit{Reduced Instruction
    Set Computing}). Pierwszym wyprodukowanym przed nich procesorem jest
  32-bitowy \textsc{arm1}. Dla tych procesorów utworzono język asembler
  \alert{\textsc{arm}}.

  W~1990 roku z~Acorn Computers Ltd. wydzieliła~się firma znana dziś jako
  Arm~Holdings~pcl.

\end{frame}
% ##################





% ##################
% \begin{frame}
%   \frametitle{Coordinate systems in computer graphics}



% \end{frame}
% ##################





% ##################
% \begin{frame}
%   \frametitle{Coordinate systems in computer graphics}



% \end{frame}
% ##################



% % ######################################
% \SectionSlideWithPicture{Terminological notes}
% % ######################################



% ##################
% \begin{frame}[label=]
%   \frametitle{}




% \end{frame}
% ##################





% ##################
% \begin{frame}[label=]
%   \frametitle{}




% \end{frame}
% ##################





% ##################
% \begin{frame}[label=Uwagi-pojecie-przestrzeni-Przestrzen-afiniczna-i-wektorowa-3]
%   \frametitle{The concept of space. Space and coordinate system}



% \end{frame}
% ##################








% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ####################################################################

% End of the document
\end{document}
