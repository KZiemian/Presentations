% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located in directory
% "preambule"
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Algorytmy-kompilacji-Bibliography.bib}





% ------------------------------------------------------
% Packages, libraries and their settings
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
\usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation
\usepackage{./Local-packages/local-settings}

% Patching problems with Jagiellonian
\usepackage{./Local-packages/Jagiellonian-theme-colors}

\usepackage{./Local-packages/Some-patches-for-Jagiellonian}

% Stylef for drawing diagrams
\usepackage{./Local-packages/PGF-TikZ-Diagram-styles}










% ------------------------------------------------------------------------------------------------------------------
\title{Wybrane algorytmy kompilacji}
\subtitle{Wprowadzenie do~przedmiotu}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% Number of chars: 62k+, 80k+, 41k+, 36k+, 40k+, 56k+, 53k+,
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################





% ######################################
\section{Informacje ogólne}
% ######################################





% ##################
\begin{frame}
  \frametitle{Informacje wstępne}


  Obawiam~się, że na tych konkretnych zajęciach będzie sporo przynudzania,
  ale nie widzę sposobu, by~tego uniknąć.

  Według mnie to zajęcia są dla studentów, nie studenci dla zajęć. Tak samo
  ja jestem tu dla Państwa, a~nie Państwo dla mnie. W~związku z~tym, ja
  będę Państwa rozliczał tylko i~wyłącznie z~umiejętności i~wiedzy,
  z~niczego innego. Wychodzę bowiem z~założenia, że~Państwo sami najlepiej
  wiedzą, czemu warto poświęcić swój czas. (Choć jak dobrze wiemy, często
  po jakimś czasie stwierdzamy, że~może trzeba było wybrać coś innego.)

  Na zajęciach nie tylko można, ale \alert{należy} zadawać pytania
  na dowolne związane z~zajęciami zagadnienia. W~szczególności
  \alert{należy} zadawać pytania, jeśli~się czegoś nie rozumie, lub coś
  jest niejasne. Kompilatory to zagadnienie na którym dobrze zna się jakiś
  0.1\% informatyków, \alert{nie} zakładamy, że~Państwo należą do tej
  wąskiej grupy. Co do mnie, sami Państwo to ocenią.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Informacje wstępne}


  Pytania typu „Jaki jest najfajniejszy boss w~grze \textit{Hollow
    Knight}?” musimy jednak zostawić na czas po zajęciach.

  Jeśli coś jest dla Państwa tak proste, że~mówienie o~tym to marnowanie
  Państwa czasu, proszę również o~tym powiedzieć. Przeskoczymy wtedy
  do~następnej części materiału.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Uwagi odnośnie treści zajęć}


  Współczesna informatyka jest dziedziną bardzo młodą. Ma sens datowanie
  jej powstania na rok 1945, gdy technologie komputerowe rozwinięte na
  potrzeby wojskowe w~czasie II~Wojny Światowej wchodzą do użytku
  powszechnego, choć z~przyczyn czysto technicznych (koszt, rozmiar,
  zużycie energii, etc.) dostępne są tylko bardzo wąskiej
  grupie ludzi. Nauka ma to do siebie, że~jej dział potrafi naprawdę
  długo~się rozwijać, potrzebując niekiedy dekad jeśli nie wieków, by
  zbudować dla siebie solidne fundamenty. W~informatyce zaś cały czas
  odkrywamy nowe i~kluczowe dla niej rzeczy.

  W~szczególności, żyjemy teraz, rok $2024$, w~epoce intensywnego rozwoju
  kompilatorów, która raczej~się nie skończy~się jutro. W~skutek tego cała
  masa rzeczy~się ciągle zmienia i~to co wczoraj uchodziło za czystą
  fantazję, dziś jest rzeczywistością wdrażaną do produkcji przemysłowej
  (może trochę przesadzam, ale nie tak bardzo). Proszę mieć to na uwadze
  biorąc udział w~zajęciach i~ucząc~się do tego kursu.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Poziom zajęć i~konsultacje}


  Ze względu na ramy czasowe tego kursu wiele rzeczy będę
  \alert{upraszczał} lub \alert{pomijał}. Proszę o~tym cały czas pamiętać.
  To czy ten przedmiot będzie sam w~sobie \alert{prosty}, to tylko czas
  pokaże.

  Jeśli ktoś chce~się zagłębić bardziej w~omawianą tematykę, to po
  zajęciach służę całą moją osobą.

  Z~mojego doświadczenia wynika, że~ustalanie jednego terminu na konsultacje
  to nie jest dobry pomysł. W~zasadzie nikt wtedy nie przychodzi, a~ja
  wyznaję zasadę, że~konsultacje są dla Państwa, nie dla mnie. Jeśli
  Państwo chcą bym ustalił konkretne terminy na konsultacje, to proszę jako
  grupa wybrać jeden taki i~poinformować mnie o~tym bezpośrednio, lub
  mailowo, pisząc na adres \email.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Konsultacje}


  Jeśli taki termin nie zostanie ustalony, to każdy z~Państwa kto ma
  problem i~chce zasięgnąć mojej pomocy, nie do mnie napiszę, na
  wspomniany już adres \email, kiedy, gdzie i~w~jakiej formie chcą Państwo
  uczestniczyć w konsultacjach. Mogą one być zarówno w~świecie rzeczywistym
  (niekoniecznie w~budynku \textsc{wsz}i\textsc{b}u), online lub
  telefonicznie. Jeśli wystarczy odpowiedź pisemna, to oczywiście
  też można i~należy o~nią prosić.

  Zawsze będę wdzięczny za napisanie w~mailu z~czym konkretnie mają Państwo
  problem, rozumiem jedna, że~często wskazanie czy nazwanie tego co sprawia
  trudności, jest samo w~sobie problemem. Sam przez to przechodziłem.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jeszcze o~zajęciach}


  Będę~się starał nagrywać na \textsc{ms}~Teamsach każde naszych spotkań.
  Proszę mnie męczyć, żeby to robił, bo jestem roztrzepany i~za którymś
  razem na pewno o~tym zapomnę.

  Proszę mi też zwracać uwagę, że~na ekranie czegoś nie widać,
  że~czcionka jest za mała, że~kolory kłują w~oczy, że~nagrany dźwięk
  jest niskiej jakości,~etc. Zajęcia są dla Państwa, nie dla mnie, a~moim
  obowiązkiem jest dostarczyć Państwu materiały do nauki o~najwyższej
  jakości jaka jest nam dostępna.

  Niestety, jakość dźwięku to coś na co mam mały wpływ. Mogę~się starać
  mówić możliwie blisko mikrofonu, ale to raczej nie pomoże wiele.
  Poza tym, na~pewno nie wyjdzie mi to dobrze, bo jestem roztrzepany.
  Swoje uwagi w~tej sprawie proszę kierować do ludzi odpowiedzialnych
  za~sprawy studenckie na \textsc{wsz}i\textsc{b}ie.

\end{frame}
% ##################










% ######################################
\section{O~uzyskaniu zaliczenia}
% ######################################



% ##################
\begin{frame}
  \frametitle{Zaliczenie zaoczne}


  Zaliczenie zaoczne można jak najbardziej uzyskać, przez oddanie
  odpowiedniego projektu lub ustną dyskusję ze mną na temat kompilatorów
  i~algorytmów kompilacji. Ta ostania musi~się odbyć na żywo, by uniknąć
  wątpliwości co do źródła wiedzy zdającego.

  Każdy kto chce uzyskać zaliczenie zaoczne, niech zgłosi~się do mnie po
  zajęciach lub napisze na maila \email.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Warunki zaliczenia}


  Na dzień dzisiejszy zaliczenie uzyskuje~się przez oddanie jednego zestawu
  zadań domowych i~napisanie jednego sprawdzianu na żywo.

  Sprawdzian będzie zawierał $20$ pytań testowych, jednokrotnego wyboru.
  Urządzimy go na pierwszym spotkaniu po świętach Bożego Narodzenia.

\end{frame}
% ##################









% ######################################
\section{Wymagania i~materiały do nauki}
% ######################################



% ##################
\begin{frame}
  \frametitle{Materiały do nauki}


  Prezentacje te są dostępne w~formie plików \LaTeX a (kodu źródłowego)
  na serwisie GitHub. Każdy kto ma na komputerze program Git i~dostęp
  do internetu może jest zdobyć wpisując \\
  \texttt{\$ git clone https://github.com/KZiemian/Presentation} \\
  Znajdują~się one w~katalogu: \\
  \texttt{Wybrane-algorytmy-kompilacji-ETC-Prezentacje}. \\
  Można je również oglądać, jak normalny człowiek, w~przeglądarce: \\
  \colorhref{https://github.com/KZiemian/Presentations}
  {https://github.com/KZiemian/Presentations}.

  Będą też dostępne w~formie \textsc{pdf}ów na~Sake, wraz z~innymi
  materiałami do nauki.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zgłaszanie błędu i~uwag}


  W~razie znalezienia jakiegokolwiek błędu lub jakichkolwiek uwag
  merytorycznych do zajęć lub towarzyszącym ich materiałów proszę pisać pod
  adres \email{ } lub zgłaszać je mi po zajęciach. Chcemy by te zajęcia
  i~towarzyszące im materiały były możliwie merytoryczne, proste, łatwe
  w~zrozumieniu i~pozbawione błędów. Proszę jednak uwierzyć, że~osiągnięcie
  tego jest naprawdę dużym wyzwaniem.

  W~szczególności uwagi odnośnie treści przedmiotu są mile widziane.
  Wciąż próbujemy znaleźć optymalną jego formę, co nie jest wcale sprawą
  prostą.

\end{frame}
% ##################










% ######################################
\section{Dygresja o~diagramach występujących w~tych
  prezentacjach}
% ######################################



% ##################
\begin{frame}
  \frametitle{Konwencja}


  \begin{textblock}{2.8}(2,1.5)

    \begin{tikzpicture}

      \node[diagram block] at (0,0) {Coś robi};

    \end{tikzpicture}

  \end{textblock}



  \begin{textblock}{2.8}(8,1.5)

    \begin{tikzpicture}

      \node[diagram rectangle block] at (0,0) {Czymś jest};

    \end{tikzpicture}

  \end{textblock}


  \vspace{6em}





  Bloki diagramu które mają kształt prostokąta z~zaokrąglonymi rogami,
  zwykle~są koloru niebieskiego, oznaczają \textbf{aktorów}, czyli
  taki obiekt który wykonuje jakąś czynność na obiektach wejściowych,
  tworząc obiekty wyjściowe. Takim obiektem może być kucharz, komputer,
  program komputerowy,~etc.

  Bloki diagramu które mają kształt prostokąta z~ostrymi rogami, zwykle~są
  koloru karmelowego (czy to jest kolor karmelowy?), przedstawiają
  \textbf{obiekty} które są pobierane na~wejście przez aktorów lub przez
  nich wytwarzane i~zwracane na wyjście. Jeśli aktorem jest kucharz to na
  wejście może pobierać jajka, mąkę, etc., a~na wyjściu zwracać naleśniki
  z~truskawkami.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przykładowy diagram}


  Konwencję tą ilustruje poniższy, zrobionym z~przymrużeniem oka, diagram.
  Przedstawia on proces tworzenia przez człowieka za pomocą klawiatury
  i~komputera programu w~języku programowania~C.






  \begin{textblock}{10.5}(1.4,3.5)

    \begin{figure}

      \label{fig:Creating-code-in-C}


      \begin{tikzpicture}

        % \path (0,0) -- (0,0);



        \node[diagram block] (Man) at (0,0) {Człowiek};

        \node[diagram block] (Keyboard) at (3.8,0) {Klawiatura};

        \draw[thick diagram arrow] (Man) -- (Keyboard);



        \node[diagram block] (Computer) at (7.6,0) {Komputer};

        \draw[thick diagram arrow] (Keyboard) -- (Computer);



        \node[diagram rectangle block] (Source code) at (7.6,-2.5)
        {Kod źródłowy w~języku~C};

        \draw[thick diagram arrow] (Computer) -- (Source code);

      \end{tikzpicture}

      \caption{Diagram ilustrujący tworzenie kodu w~języku~C.}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Inny diagram}


  Czy poniższy diagram jest lepszy czy gorszy od poprzedniego? Zależy
  od~tego jakie informacje ma dany diagram przekazywać. Proszę~się więc nie
  dziwić, jeśli na danym diagramie czegoś nie ma, a~nawet, że~nie ma czegoś
  co było na poprzedniej wersji diagramu. Zawsze trzeba dokonać selekcji
  tego co na diagramie zostanie umieszczone, a~co nie i~ten wybór często
  zależy od kontekstu.

  Jeśli uważają Państwo, że~na diagramie nie ma czegoś, co być powinno,
  albo coś innego jest nie w~porządku, \alert{proszę} mi zwrócić na to
  uwagę. Całkiem możliwe, że~popełniłem błąd rysując ten konkretny diagram.





  \begin{textblock}{10.9}(1.4,6.1)

    \begin{figure}

      \label{fig:Also-creating-code-in-C}


      \begin{tikzpicture}

        \node[diagram block] (Man) at (0,0) {Człowiek};

        \node[diagram rectangle block] (Source code) at (3.8,0)
        {Kod źródłowy w~języku~C};

        \draw[thick diagram arrow] (Man) -- (Source code);

      \end{tikzpicture}

      \caption{Inna wersja diagramu ilustrującego tworzenie kodu
        w~języku~C.}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################










% ######################################
\section{Spojrzenie na~przedmiot z~lotu ptaka}
% ######################################



% ##################
\begin{frame}
  \frametitle{Czy ten przedmiot jest praktyczny?}


  Jeśli kiedyś napisaliście Państwo i~uruchomili program w~języku C, C++,
  Fortran, Go, Java, Rust, etc., to na $99\%$ korzystali Państwo
  z~kompilatora danego języka. W~roku $2024$ cała infrastruktura
  informatyczna stoi na~kodzie napisany w~języku~C, który odpowiednie
  kompilatory przetworzyły w~programy komputerowe. W~tym sensie kurs ten
  jest superpraktyczny, bo ktoś te kompilatory musi pisać.

  Jeśli jednak nie mają Państwo zamiaru zajmować~się zawodowo pracą nad
  kompilatorami, jak przytłaczająca większość informatyków, to ten kurs nie
  będzie miał jakiejś szczególnie wielkiej wartości praktycznej dla Państw.
  Niemniej nawet w~takiej sytuacji mogą Państwo wynieść z~niego jakąś
  wiedzę i~umiejętności, które potencjalnie pozwoli wam później tworzyć
  bardziej wydajne programy. Jeśli mamy jakieś wyobrażenie na temat tego
  jak kompilator działa, to możemy mu ułatwić tworzenie dobrych programów.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}

  \pause


  Żeby komputer coś zrobił musimy więc mu przekazać polecenie w~języku,
  który rozumie. Dla mnie pierwotny językiem jest język polski, co zaś
  jest pierwotnym językiem komputera? Na potrzeby tego kursu przyjmiemy,
  że~pierwotnym językiem komputera jest \textbf{język asemblera}
  (ang. \textit{assembly language}).

  Tak jak niektórzy ludzie mają jako swój pierwotny język angielski,
  hiszpański, japoński, niemiecki, polski, etc., tak komputer również
  posługują~się różnymi rodzajami języka asembler, takimi jak \textsc{arm}
  czy x86. Można też wymienić dialekty asemblera \textsc{gas},
  \textsc{fasm}, \textsc{masm}, \textsc{nasm}, \textsc{yasm}. (Kto wymyśla
  te nazwy?)

  Różnica między komputerem, a~człowiekiem jest taka, że~pojedynczy człowiek
  poza swoim pierwotnym językiem, może znać kilka innych (angielski,
  arabski, chiński, farsi, francuski, hiszpański, japoński, niemiecki,
  polski, etc.). Komputery zwykle rozumieją tak naprawdę tylko
  \alert{jeden jedyny} język: właściwy mu dialekt asemblera.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}


  To który dialekt asemblera rozumiem komputer jest ustalony przez firmę,
  która wyprodukowała jego procesor. Asembler jest bowiem zakodowany w~tym
  jak są „podpięte kable” w~danym procesorze.

  By lepiej zrozumieć dlaczego potrzebujemy kompilatorów, przedstawimy
  teraz jeden program, który wypisuje „Hello, World!” na ekranie, napisany
  w~dialektach asemblera \textsc{arm~32}, AArch64, \textsc{risc-v},
  \textsc{nasm} i~x86 oraz językach C i~Python.

  Wszystkie te programy przetestowałem na~moim komputerze pod systemem
  GNU/Linux Ubuntu 22.04~\textsc{lts}, więc jeśli są chętni, to możemy
  je~bardziej szczegółowo omówić po~zajęciach.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze ARM~32
    \parencite{Low-Level-You-Can-Learn-ARM-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x4} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr r1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov r2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#65} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}

  \frametitle{„Hello, World!” w~asemblerze AArch64
    \parencite{Low-Level-You-Can-Learn-AArch64-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov x8, \#64} \\
  \hphantom{aaaaaaaa} \texttt{mov x0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr x1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov x2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#65} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze RISC-V
    \parencite{Low-Level-You-Can-Learn-RISC-V-ETC-Ver-2021}}


  \texttt{.global \_start} \\
  \texttt{\_start:} \\
  \hphantom{aaaa} \texttt{addi a7, zero, 64} \\
  \hphantom{aaaa} \texttt{addi a0, zero, 1} \\
  \hphantom{aaaa} \texttt{la a1, helloworld} \\
  \hphantom{aaaa} \texttt{addi a2, zero, 14} \\
  \hphantom{aaaa} \texttt{ecall}
  \vspace{0.8em}

  \hphantom{aaaa} \texttt{addi a7, zero, 93} \\
  \hphantom{aaaa} \texttt{addi a0, zero, 13} \\
  \hphantom{aaaa} \texttt{ecall}
  \vspace{0.8em}

  \texttt{helloworld:} \\
  \hphantom{aaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze NASM
    \parencite{Toal-NASM-Tutorial-Ver-2024}}


  \hphantom{aaaaaaaaa} \texttt{global} \hphantom{aa} \texttt{\_start} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section} \hphantom{a} \texttt{.text} \\
  \texttt{\_start:} \hphantom{a} \hspace{-0.14em}
  \texttt{mov} \hphantom{aaaaaa} \texttt{rax, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdi, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa}
  \texttt{rsi, message} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdx, 14} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rax, 60} \\
  \hphantom{aaaaaaaaa} \texttt{xor} \hphantom{aaaaaa} \texttt{rdi, rdi} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section .data} \\
  \vspace{0.8em}

  \texttt{message: db} \hphantom{aaaaa} \texttt{"Hello, World!", 10}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze x86
    \parencite{Low-Level-You-Can-Learn-Assembly-in-10-Minutes-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.intel\_syntax} \\
  \texttt{.section .text}

  \texttt{\_start:} \\
  \hphantom{aaaa} \texttt{mov \%eax, 4} \\
  \hphantom{aaaa} \texttt{mov \%ebx, 1} \\
  \hphantom{aaaa} \texttt{mov \%ecx, [message]} \\
  \hphantom{aaaa} \texttt{mov \%edx, 14} \\
  \hphantom{aaaa} \texttt{int 0x80} \\
  \hphantom{aaaa} \texttt{mov \%eax, 1} \\
  \hphantom{aaaa} \texttt{mov \%ebc, 65} \\
  \hphantom{aaaa} \texttt{int 0x80} \\
  \texttt{.section .dat} \\
  \texttt{message:} \\
  \hphantom{aaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~C}


  \texttt{\#include <stdio.h>} \\
  \vspace{0.8em}
  \texttt{int main() \{ } \\
  \hphantom{aaaa} \texttt{printf("Hello, World!\textbackslash n");} \\
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \hphantom{aaaa} \texttt{return 0;} \\
  \texttt{ \} }

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~Python}


  \texttt{print("Hello, World!")}

\end{frame}
% ##################




% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}


  Na pierwszy rzut oka powinno być jasne, że~C jest prostszy od~asemblera,
  a~Python prostszy od~C. Dlaczego tak jest, to niestety temat na inny
  przedmiot, acz o~kilku czynnikach wspomnimy w~dalszym ciągu zajęć.

  Większość ludzi zrobi wszystko, by tylko uniknąć pracy w~asemblerze.
  Mam nadzieję, że~nie muszę tłumaczyć dlaczego.  A~nawet jeśli
  znajdzie~się człowieka, który lubi w~nim pisać, to unika~się jak tylko
  można tego, by kod napisany przez niego w~asemblerze wszedł w~skład
  danego programu.

  Jest tak dlatego, że~nawet najlepsi programiści zbyt łatwo mylą~się
  pisząc w~asemblerze, a~pomyłki na jego poziomie są szczególnie
  niebezpieczne. Jeśli są zainteresowani, to możemy omówić ten temat
  szerzej, ale tylko po zajęciach. Wykracza on bowiem mocno poza zakres tego
  przedmiotu.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Dlaczego potrzebujemy kompilatorów?}

  \vspace{-0.75em}


  Co więc robimy by uniknąć pisania kodu w~języku asemblera? Tworzymy
  język programowania taki jak~C czy Python, który jest dla nas prostszy
  w~użyciu, niż dany dialekt asemblera i~piszemy program w~tym właśnie
  języku. Proszę zwrócić uwagę, że~słowo „prostszy” wcale nie oznacza
  \alert{„prosty”}!

  Dobrze, ale komputer dalej rozumie tylko język asembler, a~nie~C czy
  Pytona, co więc musimy zrobić, by uruchomić programy napisany w~jednym
  z~tych języków? Potrzebny jest nam program komputerowy zwany
  \textbf{translatorem}, który \alert{przetłumaczy} kod napisany,
  przykładowo w~języku~C, na język asemblera.





  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Translator-01}

      \begin{tikzpicture}% [node distance=0.8]

        \node[diagram rectangle block] (Source code in C) at (0,0)
        {Kod programu (język C)};

        \node[diagram block,right=of Source code in C] (Translator)
        {Translator};

        \draw[thick diagram arrow] (Source code in C) -- (Translator);



        \node[diagram rectangle block,right=of Translator]
        (Code in assembly) {Kod programu (język asemblera)};

        \draw[thick diagram arrow] (Translator) -- (Code in assembly);

      \end{tikzpicture}

      \caption{Ilustracja działania translatora.}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka uwag uzupełniających}


  \alert{Dygresja.} Czy ktoś z~Państwa korzystał z~emulatora do gier?
  Choćby po to by uruchomić grę \textit{Pokemon Yellow/Red/Blue}
  przeznaczoną na GameBoya na swoim \textsc{pc}ecie? (To nie jedyny
  emulator do gier z~którego korzystałem.) Na tej samej zasadzie działają
  emulatory asemblerów, pozwalające uruchomić asemblera x86 na procesorze
  zbudowanym w~architekturze \textsc{arm}.

\end{frame}
% ##################





% ##################
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% ##################










% ######################################
\section{Praktyczny problem}
% ######################################



% ##################
\begin{frame}
  \frametitle{Kilka słów przypomnienia}


  Jak mówiliśmy wcześniej, na potrzeby tego kursu będziemy przyjmować,
  że~naturalnym językiem komputera jest język asembler i~nie będziemy
  wnikać głębiej w~to co~się tam dzieje. Jeśli jednak ktoś chce
  dowiedzieć~się czegoś więcej, to po zajęciach służę całą moją wiedzą w~tym
  temacie.

  \alert{Uwaga terminologiczna.} W~języku angielskim rozróżnia~się
  \textbf{język asemblera} (ang. \textit{assembly langauge})
  i~\textbf{program asembler} (ang. \textit{assembler}), który operuje
  na~kodzie źródłowym napisany w~języku danego asemblera. W~języku polskim
  „asembler” oznacza często język asembler, co może powodować pewne
  nieporozumienia. Będę~się starał rozróżniać te pojęcia, acz na pewno
  gdzieś przeoczę tę subtelność.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Typowy sposób wykonywania programu}


  Aby opisać jak z~grubsza wygląda wykonanie dowolnego programu na
  komputerze muszę wprowadzić pewną dozę uproszczeń. Po~pierwsze
  przyjmijmy, że~gra \textit{Hollow Knight} (nie gorszy przykład programu,
  niż dowolny inny), zawiera~się w~jednym pliku napisany w~języku asembler.
  Proces uruchamiania tej gry pokazuje poniższy diagram.





  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Running-Hollow-Knight}

      \begin{tikzpicture}

        \node[diagram rectangle block] (Hollow Knight) at (0,0)
        {\textit{Hollow Knight} (język asemblera)};

        \node[diagram block,right=of Hollow Knight] (Computer) {Komputer};

        \draw[thick diagram arrow] (Hollow Knight) -- (Computer);



        \node[diagram block,right=of Computer] (Playable computer)
        {Komputer z~włączoną grą \textit{HK}};

        \draw[thick diagram arrow] (Computer) -- (Playable computer);

      \end{tikzpicture}

      \caption{Typowy sposób uruchamiania programu na~komputerze.}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pisanie gier w~języku asembler?}

  \vspace{-0.75em}



  Jak już wspomnieliśmy, pisanie czegokolwiek, w~tym gier wideo, w~języku
  asemblera to zwykle nie jest dobry pomysł. Znanym przykładem tego, że~jest
  to możliwe, jest gra \textit{RollerCoaster Tycoon} z~1999 roku, którą
  napisał \alert{w~pojedynkę} Chris Sawyer.




  \begin{textblock}{8}(2.6,2.9)

    \begin{figure}

      \label{fig:Feel-even-worse}

      % \centering


      \includegraphics[scale=0.27]
      {./Presentations-pictures/Feel-even-worse.jpg}

    \end{figure}

  \end{textblock}

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Jak uruchomić grę?}


  Dzisiaj gry zwykle tworzy~się w~środowiskach takich jak
  \colorhref{https://www.unrealengine.com/en-US}{Unreal Engine},
  \colorhref{https://unity.com/}{Unity} czy
  \colorhref{https://godotengine.org/}{Godot}, nie zaś pisze kod źródłowy
  od zera. Unreal Engine i~Godot są napisane w~większości w~języku C++,
  Unity w~języku C\#. W~tym momencie nie mam pewności, w~czym został
  napisany \textit{Hollow Knight}, ale mędrcy internetu twierdzą, że~został
  stworzony w~Unity, więc w~języku C\#. Dlaczego jednak poniższy diagram
  jest błędny?





  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Running-Hollow-Knight-good}

      \begin{tikzpicture}

        \node[diagram rectangle block] (Hollow Knight) at (0,0)
        {\textit{Hollow Knight} (język C\#)};

        \node[diagram block,right=of Hollow Knight] (Computer) {Komputer};

        \draw[thick diagram arrow] (Hollow Knight) -- (Computer);



        \node[diagram block,right=of Computer] (Playable computer)
        {Komputer z~włączoną grą \textit{HK}};

        \draw[thick diagram arrow] (Computer) -- (Playable computer);

      \end{tikzpicture}

      \caption{Błędny sposób uruchamiania gry \textit{Hollow Knight}}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak uruchomić grę?}


  Komputer jako taki nie rozumie języka~C\#, więc nie jest w~stanie
  uruchomić gry napisanej w~takim języku. Aby ją uruchomić, translator
  musi najpierw przetłumaczyć ją na język asemblera. To co kupujemy
  nabywając \textit{Hollow Knight}, to jest właśnie kod w~języku asemblera.





  \begin{textblock}{10.1}(1.4,3.6)

    \begin{figure}

      \begin{tikzpicture}

        \node[diagram rectangle block] (Hollow Knight in C-sharp) at (0,0)
        {\textit{Hollow Knight} (język C\#)};

        \node[diagram block,right=of Hollow Knight in C-sharp] (Translator)
        {Translator};

        \draw[thick diagram arrow] (Hollow Knight in C-sharp) --
        (Translator);



        \node[diagram rectangle block,right=of Translator]
        (Hollow Knight in assembly)
        {\textit{Hollow Knight} (język asemblera)};

        \draw[thick diagram arrow] (Translator) --
        (Hollow Knight in assembly);



        \node[diagram block,below=of Hollow Knight in assembly] (Computer)
        {Komputer};

        \draw[thick diagram arrow] (Hollow Knight in assembly) -- (Computer);


        \node[diagram block,left=of Computer]
        (Computer running Hollow Knight)
        {Komputer z~włączoną grą \textit{HK}};

        \draw[thick diagram arrow]
        (Computer) -- (Computer running Hollow Knight);

      \end{tikzpicture}

      \caption{Poprawny sposób włączania gry \textit{Hollow Knight}.}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czy to znaczy\ldots}


  Może~się Państwu nasunąć taka myśl. „Ja słyszałem, że~istnieje
  oprogramowanie o~otwarty kodzie, jak system operacyjny GNU/Linux
  i~o~zamkniętym kodzie, takie jak system Windows. Każdy może przeczytać
  kod źródłowy otwartego oprogramowania,
  ale tego o~zamkniętym kodzie tylko ci którzy pracują dla takich firm jak
  Microsoft. A~Pan tu twierdzi, że~program który dostaję na moim komputerze
  jest napisany w~języku assemblera, więc jeśli tylko otworzę ten program
  i~zrozumiem asemblera wewnątrz niego, to tak jakby miał on otwarty kod.
  Po co więc całe to rozróżnienie na kod otwarty i~zamknięty?”

  Wszystko to prawda. Haczyk tkwi w~stwierdzeniu \alert{„zrozumiem asemblera
    wewnątrz [tego pliku]”}. Zrozumienie działania kodu źródłowego
  w~języku~C, czy~Python jest często nieznośnie trudne, a~język asembler
  czyni to zadanie jeszcze mniej przyjemnym.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Proszę~się nie poddawać}


  Proszę~się jednak nie poddawać i~pamiętać, że~„wszystko ma otwarty
  kod, jeśli potrafisz przeprowadzić jego inżynierię wsteczną”
  (org.~\textit{Everything is open source, if you can reverse engineering
    it.},
  \parencite{Low-Level-Everything-is-open-source-if-ETC-Ver-2023})~;).

  \vspace{1.5em}





  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x4} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr r1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov r2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hspace{5em} \vdots

\end{frame}
% ##################





% ##################
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% ##################










% ######################################
\section{Translatory, kompilatory i~interpretery}
% ######################################



% ##################
\begin{frame}
  \frametitle{Translatory}

  \vspace{-0.75em}


  W~tym momencie już mam nadzieję wszyscy rozumiemy, czemu potrzebujemy
  kompilatorów. Zanim jednak przejdziemy dalej, potrzebujemy, choć to może
  być dość nudne, wprowadzić trochę nowych pojęć i~doprecyzować odrobinę
  terminologię.

  \textbf{Translator} to dowolny obiekt który tłumaczy tekst z~języka~A,
  na odpowiedni tekst w~języku~B. Bardziej formalnie, język~A nazywamy
  \textbf{językiem źródłowym} (ang.~\textit{source language}), a~język~B
  \textbf{językiem wynikowym} (ang.~\textit{target language}).
  Wedle tej definicji człowiek tłumaczący z~polskiego na angielski też
  jest translatorem. To nie jest bug tej definicji, to jest jej feature.




  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Translator-01}


      \begin{tikzpicture}

        \node[diagram rectangle block] (Text in language A) at (0,0)
        {Tekst w~języku~A};

        \node[diagram block,right=of Text in language A] (Translator)
        {Translator};

        \draw[thick diagram arrow] (Text in language A) -- (Translator);


        \node[diagram rectangle block,right=of Translator]
        (Text in language B)
        {Tekst w~języku~B};

        \draw[thick diagram arrow] (Translator) -- (Text in language B);

      \end{tikzpicture}

      \caption{Sposób działania translatora}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Translatory}

  \vspace{-0.75em}


  W~kontekście języków programowania, słowo „tekst” będzie dla nas
  równoważne słowom „kod” i~„program”, choć zwykle przez „program”
  rozumiemy obiekt, który można od razu uruchomić na~komputerze. Jednak nie
  możemy tak uruchomić programu (tekstu kodu źródłowego)
  napisanego w~języku~C, bo komputer rozumie tylko swój dialekt języka
  asembler. Musimy najpierw przetłumaczyć go odpowiednim translatorem na ów
  dialekt i~dopiero ten nowy program możemy uruchomić. Mam jednak
  nadzieję, że~ta kwestia nie będzie prowadzić do nieporozumień.
  Będziemy więc mówić o~„kodzie źródłowym” (ang. \textit{source code})
  i~„kodzie wynikowym” (ang. \textit{target code}).





  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Translator-02}


      \begin{tikzpicture}

        \node[diagram rectangle block] (Source code) at (0,0)
        {Kod źródłowy};

        \node[diagram block,right=of Source code] (Translator)
        {Translator};

        \draw[thick diagram arrow] (Source code) -- (Translator);



        \node[diagram rectangle block,right=of Translator]
        (Target code)
        {Kod wynikowy};

        \draw[thick diagram arrow] (Translator) -- (Target code);

      \end{tikzpicture}

      \caption{Sposób działania translatora}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Co ma robić translator?}


  W~definicji translatora jest powiedziane, że~tłumaczy on tekst
  w~języku~A, na \alert{odpowiedni} tekst w~języku~B. Co jednak znaczy
  słowo „odpowiedni”? Odpowiedź na to pytanie jest zaskakująco trudna
  i~złożona, zarówno jeśli chodzi o~tłumaczenie z~języka angielskiego
  na~polski, czy~z~C na~dialekt asemblera i~dokładne wyjaśnienie wykracza
  poza zakres tego przedmiotu. Ogólnie rzecz biorąc korzystamy tu
  z~koncepcji czarnej skrzynki: programy są równoważne, jeśli przy tych
  samych danych wejściowych dają te same dane wyjściowe.





  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Program-as-black-box-01}


      \begin{tikzpicture}

        \node[diagram rectangle block] (Input) at (0,0)
        {Dane wejściowe};

        \node[diagram block,fill=black,right=of Input] (Program)
        {Program (czarna skrzynka)};

        \draw[thick diagram arrow] (Input) -- (Program);



        \node[diagram rectangle block,right=of Program] (Output)
        {Dane wyjściowe};

        \draw[thick diagram arrow] (Program) -- (Output);

      \end{tikzpicture}

      \caption{Program komputerowy jako czarna skrzynka.}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Co ma robić translator?}


  Co jest w~środku danego programu (czarnej skrzynki) nas nie obchodzi.
  Może tam być i~smok wykonujący odpowiednia działania, byleby tylko
  na zadane dane wejściowa, dawał poprawną odpowiedź na wyjściu.

  Od translatora będziemy więc żądać, by~przetwarzał kod źródłowy
  na równoważny mu kod wynikowy, w~sensie koncepcji czarnej skrzynki.





  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Program-as-black-box-02}


      \begin{tikzpicture}

        \node[diagram rectangle block] (Input) at (0,0)
        {Dane wejściowe};

        \node[diagram block,fill=black,right=of Input] (Program)
        {Program (czarna skrzynka)};

        \draw[thick diagram arrow] (Input) -- (Program);



        \node[diagram rectangle block,right=of Program] (Output)
        {Dane wyjściowe};

        \draw[thick diagram arrow] (Program) -- (Output);

      \end{tikzpicture}

      \caption{Program komputerowy jako czarna skrzynka.}


    \end{figure}

  \end{textblock}
  % \begin{figure}

  %   \label{fig:Translator-04}


  %   \begin{tikzpicture}

  %     \node[diagram rectangle block] (Source code) at (0,0)
  %     {Kod źródłowy};

  %     \node[diagram block,fill=black,right=of Source code] (Translator)
  %     {Translator (czarna skrzynka)};

  %     \draw[thick diagram arrow] (Source code) -- (Translator);



  %     \node[diagram rectangle block,right=of Translator]
  %     (Target code)
  %     {Kod wynikowy};

  %     \draw[thick diagram arrow] (Translator) -- (Target code);

  %   \end{tikzpicture}

  %   \caption{Translator jako czarna skrzynka}


  % \end{figure}

\end{frame}
% ##################




% ##################
\begin{frame}
  \frametitle{Rodzaje translatorów}

  \vspace{-0.75em}


  Wyróżniamy dwa główne typy translatorów, \textbf{kompilatory}
  i~\textbf{interpretery}. Dawno temu można było dość łatwo podzielić
  języki programowania na języki kompilowane, czyli takie których translator
  jest kompilatorem i~języki interpretowane, zdefiniowane analogicznie.
  Typowymi językami kompilowanymi \alert{były} C i~C++, a~typowym językiem
  interpretowany \alert{był} Python.

  Jednak co najmniej od $2010$ roku sprawa ta nie jest taka prosta, ale ten
  podział jest wciąż bardzo użyteczny, gdy chcemy zrozumieć podstawy. Do
  tego jak dzisiaj to wygląda, może wrócimy w~dalszej części zajęć.

  \textbf{Kompilator} to translator, który analizuje program w~języku
  źródłowym i~tworzy obiekt zawierający program w~języku wynikowym.
  Kompilator \alert{tylko} przekłada kod z~jednego języka na drugi
  i~zapisuje wynik w~odpowiednim pliku, ale \alert{nie} uruchamia
  otrzymanego programu. Używając prostego przykładu, kompilator
  przetłumaczy „Eat the soup.” na „Zjedz zupę.”, ale nie powie nikomu,
  że~ma zjeść zupę.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kompilator}

  \vspace{-0.75em}


  Dla ustalenia uwagi, przyjmijmy, że~językiem źródłowym jest~C
  (Czy Państwo dobrze znają ten język?), a~językiem docelowym dialekt
  asemblera.

  W~przypadku języków kompilowanych mamy więc rozdział na \textbf{fazę
    kompilacji} (fazę translacji) i~\textbf{fazę wykonania programu}.
  W~fazie kompilacji niezrozumiały dla komputera program w~języku~C,
  jest tłumaczony na zrozumiały dla niego program w~dialekcie asemblera
  („Eat soup.” $\mapsto$ „Zjedz zupę.”). W~fazie wykonania program jest
  uruchamiany i~komputer realizuje zawarte w~nim polecenia (ktoś dostaje
  informację „Zjedz zupę.” i~zaczyna ją jeść).




  \begin{textblock}{10.1}(1.4,5.6)

    \begin{figure}

      \label{fig:Translator-04}


      \begin{tikzpicture}

        \node[diagram rectangle block] (Source program) at (0,0)
        {Program źródłowy (język~C)};

        \node[diagram block,right=of Source program] (Compiler)
        {Kompilator};

        \draw[thick diagram arrow] (Source program) -- (Compiler);



        \node[diagram rectangle block,right=of Compiler]
        (Target program)
        {Program wynikowy (dia. asemblera)};

        \draw[thick diagram arrow] (Translator) -- (Target program);

      \end{tikzpicture}

      \caption{Kompilacja programu w~języku~C}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Faza kompilacji i~faza wykonania}

  \vspace{-0.5em}



  \begin{figure}

    \label{fig:Translator-05}


    \begin{tikzpicture}[node distance=0.5]

      \node[diagram rectangle block] (Source code) at (0,0) {Kod źródłowy};

      \node[diagram block,below=of Source code] (Compiler) {Kompilator};

      \draw[thick diagram arrow] (Source code) -- (Compiler);



      \node[diagram rectangle block,below=of Compiler] (Target program)
      {Program wynikowy};

      \draw[thick diagram arrow] (Compiler) -- (Target program);



      \node[below=0.1em of Target program] {a) Faza kompilacji};





      \begin{scope}[xshift=5cm]


        \node[diagram rectangle block] (Input) at (0,0) {Wejście};

        \node[diagram block,below=of Input] (Running target program)
        {Uruchomiony program wynikowy};

        \draw[thick diagram arrow] (Input) -- (Running target program);



        \node[diagram rectangle block,below=of Running target program]
        (Results) {Wyniki działania programu};

        \draw[thick diagram arrow] (Running target program) --
        (Results);



        \node[below=0.1em of Results] {b) Faza wykonania};

      \end{scope}

    \end{tikzpicture}

    \caption{Ilustracja podziału na fazę kompilacji i~fazę wykonania
      programu.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak to wygląda w~praktyce?}


  Załóżmy, że~pracuję na komputerze z~systemem operacyjny GNU/Linux
  wyposażonym w~standardowy zespół narzędzi programistycznym oraz plik
  z~kodem źródłowy w~języku~C o~nazwie \texttt{helloWorld.c}.

  Faza kompilacji kodu źródłowego \texttt{helloWorld.c} polega na
  wywołaniu polecenie \\
  \texttt{\$ gcc --std=c99 -pedantic helloWorld.c -o outProg} \\
  W~rezultacie dostajemy program wynikowy \texttt{outProg}.

  Faza wykonania polega na wywołaniu polecenia \\
  \texttt{\$ ./outProg} \\
  w~wyniku którego uruchomiony zostanie program \texttt{outProg}, który
  wypisze na ekranie zdanie \texttt{Hello, World!}.

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Interpreter}


  \textbf{Interpreter} to translator, który tłumaczy polecenia zawarte
  w~kodzie źródłowym na operacje kodu wynikowego i~natychmiast je wykonuje.
  Interpreter \alert{nie} tworzy obiektu zawierającego program wynikowy.
  Wszystkie rezultaty jego działania idą bezpośrednio na procesor i~tam
  znikają (zostają nadpisane przez nadchodzące dane).





  \begin{textblock}{10.3}(1.4,4.1)

    \begin{figure}

      \begin{tikzpicture}

        \node[diagram rectangle block] (Source code) at (0,0)
        {Kod źródłowy};

        \node[diagram block,right=of Source code] (Interpreter)
        {Interpreter};

        \draw[thick diagram arrow] (Source code) -- (Interpreter);



        \node[diagram rectangle block,above=1.5em of Interpreter] (Input)
        {Wejście};

        \draw[thick diagram arrow] (Input) -- (Interpreter);



        \node[diagram rectangle block,right=of Interpreter] (Results)
        {Wynik działania programu};

        \draw[thick diagram arrow] (Interpreter) -- (Results);

      \end{tikzpicture}

      \caption{Ilustracja działania interpretera}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Interpreter}


  Wracając do poprzedniego przykładu, gdy interpreter dostaje string „Eat
  soup.”, natychmiast mówi komuś „Zjedz zupę.” i~ta osoba zaczyna ją jeść.




  \begin{textblock}{10.3}(1.4,4.1)

    \begin{figure}

      \begin{tikzpicture}

        \node[diagram rectangle block] (Source code) at (0,0)
        {Kod źródłowy};

        \node[diagram block,right=of Source code] (Interpreter)
        {Interpreter};

        \draw[thick diagram arrow] (Source code) -- (Interpreter);



        \node[diagram rectangle block,above=1.5em of Interpreter] (Input)
        {Wejście};

        \draw[thick diagram arrow] (Input) -- (Interpreter);



        \node[diagram rectangle block,right=of Interpreter] (Results)
        {Wynik działania programu};

        \draw[thick diagram arrow] (Interpreter) -- (Results);

      \end{tikzpicture}

      \caption{Ilustracja działania interpretera}


    \end{figure}

  \end{textblock}

\end{frame}
% ##################










% ######################################
\section{Krótkie opis działania interpreterów
  i~kompilatorów}
% ######################################



% ##################
\begin{frame}
  \frametitle{Przykładowy program}


  Zacznijmy od rozpatrzenia następującego pseudokodu.

  \texttt{sum = 0} \\

  \texttt{for i in (1, 2, ..., 100)} \\
  \hphantom{aaaa} \texttt{sum += i} \\

  \texttt{print("sum = ", sum)}

  Program ten wylicza wartość sumy $1 + 2 + \ldots + 100$ i~wyświetla ją na
  ekranie. Przeanalizujemy teraz jak taki program prawdopodobnie wykonałby
  interpreter, a~jak kompilator.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak wykona go interpretera?}


  \texttt{sum = 0} \\

  \texttt{for i in (1, 2, ..., 100)} \\
  \hphantom{aaaa} \texttt{sum += i} \\

  \texttt{print("sum = ", sum)}

  Typowy interpreter wykona zapewne następującą procedurę.

  1)~Tworzymy zmienną \texttt{$\text{sum}$} i~nadajemy jej wartość~$0$. \\
  2) Wchodzimy do pętli \texttt{for}. \\
  2.1) Dodajemy do wartości zmiennej \texttt{$\text{sum}$} liczbę $1$. Teraz
  \texttt{$\text{sum} = 1$}. \\
  2.2) Dodajemy do wartości zmiennej \texttt{$\text{sum}$} liczbę $2$.
  Teraz \texttt{$\text{sum} = 3$}. \\
  \hphantom{aaa} $\vdots$ \\
  2.100) Dodajemy do wartości zmiennej \texttt{$\text{sum}$} wartość
  $100$. \\
  Teraz \texttt{$\text{sum} = 5050$}. \\
  3) Wypisujemy na ekranie \texttt{$\text{sum} = 5050$}.

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Jak wykona go kompilator?}


  \texttt{sum = 0} \\

  \texttt{for i in (1, 2, ..., 100)} \\
  \hphantom{aaaa} \texttt{sum += i} \\

  \texttt{print("sum = ", sum)}

  Dobry kompilator wykona następującą procedurę.

  1) Analizujemy programu pod względem treści, ale \alert{bez}
  wykonywania żadnej z~podanych w~nich instrukcji. Porównać można
  to do przeczytania przepisu kucharskiego, ale bez wykonania zawartym
  w~nim instrukcji. Czytamy więc, że~mamy zdobyć dwa kilogramy, ale
  nie idziemy do sklepu je kupić. \\
  2) W~trakcie tej analizy kompilator wykryje, że~to co chcemy
  zrobić to wyliczyć sumę $1 + 2 + \ldots + 100$. Tak, współczesne kompilatory
  potrafią wykrywać takie rzeczy i~wiele innych.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak wykona go kompilator?}


  \texttt{sum = 0} \\

  \texttt{for i in (1, 2, ..., 100)} \\
  \hphantom{aaaa} \texttt{sum += i} \\

  \texttt{print("sum = ", sum)}

  3) Wiedząc, że~chcemy obliczyć sumę $1 + 2 + \ldots + 100$ korzystamy
  ze wzoru: \\[0.3em]
  $\displaystyle \sum_{ i = 1 }^{ n } i = \frac{ n ( n + 1 ) }{ 2 }$. \\[0.5em]
  Na jego mocy \\[0.3em]
  $\displaystyle \sum_{ i = 1 }^{ 100 } i = \frac{ 100 \cdot 101 }{ 2 } = 5050$.
  \\[0.5em]
  4) Tworzony jest program, który składa~się z~jednej instrukcji: \\
  \texttt{print("sum = ", 5050)}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Co z~tego wynika?}


  Przedstawiony przykład jest oczywiście bardzo uproszczoną wersją tego
  jak działa współczesny interpreter i~kompilator, ale już on pozwala
  zrozumieć kilka ważnych rzeczy.

  Przede wszystkim, podkreślmy to mocno,  kompilator korzysta z~zasady
  czarnej skrzynki. Nie interesuje nas jak będzie działa program wytworzony
  przez kompilator, jeśli będzie dawał poprawny wynik i~będzie działa
  możliwie szybko. Szybkość dla kompilatorów \alert{jest} ważna.

  Nie jest więc ważne, czy program pracowicie będzie liczył sumę
  $1 + 2 + 3 + \ldots$, czy wyliczy wzór $100 \cdot 101 / 2$.
  Z~naszego punktu widzenia w~środku programu może być smok, który wykonuje
  odpowiednie obliczenia matematyczne, byleby tylko ten smok liczył
  poprawnie i~możliwie szybko.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak to jest w~praktyce?}


  Ja szacuję, że~98\% programistów myśli o~działaniu programów nad którymi
  pracują w~taki sposób, jakby był on wykonywany przez interpreter, nawet
  gdy piszą w~języku „silnie” kompilowanym. Mnie tak nauczono myśleć
  o~programach i~tak uczymy dziś większość informatyków. Jak Państwo widzą,
  to wcale nie musi mieć wiele wspólnego z~tym jak \alert{naprawdę} będzie
  działa \alert{rzeczywisty} program.

  Tego jednak nie należy uważać za problem. Program działa poprawnie? Jeśli
  tak, to czym~się mamy przejmować? A~nauka programowania jest wystarczająco
  trudna bez wchodzenia w~to, jak naprawdę działa program po dokonaniu
  kompilacji. To zresztą dopiero pierwsze drugie dno całej sprawy, a jest
  jeszcze drugie drugie dno i~trzecie drugie dno, etc. Ale nie musimy~się
  tym specjalnie przejmować.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak to jest w~praktyce?}


  A~nawet jeśli trafimy na ten wyjątkowy przypadek, że~fakt, iż~nasz
  program działa w~inny sposób niż to sobie wyobrażamy, to w~większości
  przypadków będzie to nasze najmniejszy zmartwienie. Chyba, że~jesteśmy
  ekspertami od cyberbezpieczeństwa, bo wtedy to jak \alert{naprawdę}
  działa program, jest niezwykle ważne. To jest jednak temat na osobny
  przedmiot.

  Teraz przejdziemy do kilku praktycznych kwestii, które ilustruje
  poprzedni przykład.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Szybkość}


  \texttt{sum = 0} \\

  \texttt{for i in (1, 2, ..., 100)} \\
  \hphantom{aaaa} \texttt{sum += i} \\

  \texttt{print("sum = ", sum)}

  Program w~języku interpretowanym tępo wykonuje obliczenia, ten
  w~języku kompilowanym oblicza wynik stosując sprytny trik. Współczesne
  kompilatory znają setki takich trików, dzięki czemu programy w~językach
  kompilowanych są \alert{dużo} szybsze, niż równoważne programy napisane
  w~języku interpretowanym. Tutaj spokojnie można mówić o~czynniku~$100$.

  Jednocześnie języki interpretowane są często bardziej „user friendly”.
  Rozpatrzmy jeden przykład: informacje o~błędach. Jeśli interpreter
  znajdzie błąd, to doskonale wie w~którym miejscu programu go znalazł
  i~nam o~tym powie.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Oczywiście, życie nie może\ldots}


  W~przypadku języka kompilowanego, błąd może zostać znaleziony dopiero
  w~momencie, gdy program został przekształcony do formy, która
  nie ma już nic wspólnego z~kodem, który napisaliśmy. Skutkiem tego,
  kompilatory potrafią zwracać błędy, które są niezrozumiałe dla normalnego
  programisty.

  Oczywiście, życie nie może być takie proste i~w~praktyce coraz rzadziej
  mamy do czynienia z~czystymi językami interpretowanymi oraz kompilowanymi.
  Ale o~tym będziemy mówić, tylko jeśli zostanie nam trochę czasu pod
  koniec kursu.

\end{frame}
% ##################





% % % ##################
% % \jagiellonianendslide{Dziękuję za~uwagę.}
% % % ##################


% % ######################################
% \section{????}
% % ######################################










% ######################################
\appendix
% ######################################










% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ####################################################################

% End of the document
\end{document}
