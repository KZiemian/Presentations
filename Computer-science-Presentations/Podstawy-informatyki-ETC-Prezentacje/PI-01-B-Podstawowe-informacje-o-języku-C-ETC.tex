% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle,frametitlecolorstyle=general,titleframebackgroundcolorstyle=dark]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located in
% the directory "preambule"
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/ImportingLocalPackages.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Podstawy-informatyki-ETC-Bibliography.bib}





% ------------------------------------------------------
% Importing packages, libraries and setting their configuration
% ------------------------------------------------------
\usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation
\usepackage{./Local-packages/local-settings}

% Styles for arrows
\usepackage{./Local-packages/PGF-TikZ-Arrows-styles}

% Stylef for drawing diagrams
\usepackage{./Local-packages/PGF-TikZ-Diagram-styles}











% ------------------------------------------------------------------------------------------------------------------
\title{Podstawy informatyki z~językiem~C}
\subtitle{Podstawowe wiadomości o~języku~C i~?????}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% Number of chars: 62k+, 73k+, 43k+, 52k+, 69k+, 77k+, 32k+,
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################





% ######################################
\section{Dygresja o~diagramach występujących w~tych
  prezentacjach}
% ######################################



% ##################
\begin{frame}
  \frametitle{Konwencja}


  \begin{textblock}{2.8}(2,1.5)

    \begin{tikzpicture}

      \node[diagram block] at (0,0) {Coś robi};

    \end{tikzpicture}

  \end{textblock}



  \begin{textblock}{2.8}(8,1.5)

    \begin{tikzpicture}

      \node[diagram rectangle block] at (0,0) {Czymś jest};

    \end{tikzpicture}

  \end{textblock}


  \vspace{6em}





  Bloki diagramu które mają kształt prostokąta z~zaokrąglonymi rogami
  (zwykle~są koloru niebieskiego) oznaczają \textbf{aktorów}, czyli
  taki obiekt który wykonuje jakąś czynność na zadanych obiektach
  wejściowych. Takim obiektem może być człowiek, komputer, program
  komputerowy, fragment programu komputerowego, etc.

  Bloki diagramu które mają kształt prostokąta z~ostrymi rogami (zwykle~są
  koloru karmelowego), przedstawiają rzeczy które są pobierane na~wejście
  przez aktorów lub przez nich wytwarzane.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przykładowy diagram}


  Konwencję tą ilustruje poniższy, zrobionym z~przymrużeniem oka, diagram.
  Przedstawia on proces tworzenia przez człowieka za pomocą klawiatury
  i~komputera programu w~języku programowania~C.





  \begin{figure}

    \label{fig:Creating-code-in-C}


    \begin{tikzpicture}

      \node[diagram block] (Man) at (0,0) {Człowiek};

      \node[diagram block,right=of Man] (Keyboard) {Klawiatura};

      \draw[thick diagram arrow] (Man) -- (Keyboard);



      \node[diagram block,right=of Keyboard] (Computer) {Komputer};

      \draw[thick diagram arrow] (Keyboard) -- (Computer);



      \node[diagram rectangle block,below=of Computer] (Source code)
      {Kod źródłowy w~języku~C};

      \draw[thick diagram arrow] (Computer) -- (Source code);

    \end{tikzpicture}

    \caption{Diagram ilustrujący tworzenie kodu w~języku~C.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Inny diagram}


  Czy poniższy diagram jest lepszy czy gorszy od poprzedniego? Zależy
  od~tego jakie informacje ma dany diagram przekazywać. Proszę~się więc nie
  dziwić, jeśli na danym diagramie czegoś nie ma, a~nawet, że~nie ma czegoś
  co było na poprzedniej wersji diagramu. Zawsze trzeba dokonać selekcji co
  na diagramie zostanie umieszczone, a~co nie i~ten wybór często zależy
  od kontekstu.

  Jeśli uważają Państwo, że~na diagramie nie ma czegoś, co być powinno,
  albo coś innego jest nie w~porządku, \alert{proszę} to mi powiedzieć.
  Całkiem możliwe, że~popełniłem błąd rysując dany diagram.






  \begin{figure}

    \label{fig:Also-creating-code-in-C}


    \begin{tikzpicture}

      \node[diagram block] (Man) at (0,0) {Człowiek};

      \node[diagram rectangle block,right=of Man] (Source code)
      {Kod źródłowy w~języku~C};

      \draw[thick diagram arrow] (Man) -- (Source code);

    \end{tikzpicture}

    \caption{Inna wersja diagramu ilustrującego tworzenie kodu w~języku~C.}


  \end{figure}

\end{frame}
% ##################





% % ##################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ##################










% ######################################
\section{Podstawowe informacje o~języku~C}
% ######################################



% ##################
\begin{frame}
  \frametitle{Podstawowe informacje o~języku~C}


  Język~C został stworzony przez Dennis Ritchie (1941--2011), by ułatwić
  Kenowi Thompsonowi (ur. 1943), pracę nad systemem operacyjnym
  \textsc{unix}. Pierwsza jego wersja ukazała~się w~1972 roku.

  Język~C w 2022 roku obchodził 50 (!) lecie swojego istnienia. Jego wiek
  niestety często czuć, bo wiele funkcjonalności które dziś uważamy
  za~niezbędne w~pracy programisty albo są w~nim nieobecne, albo są,
  ale w~dość koślawej wersji. Niektórych rzeczy nie da~się w~sposób
  elegancki dodać do języka z~lat 70-tych XX wieku.

  Do tego język~C został pomyślany jako mały język, więc on z~premedytacją
  \alert{nie} wprowadził pewnych rzeczy znanych już koło 1970 roku. To
  niestety też nie ułatwia nam życia. Co gorsza, dla początkujących~C i~tak
  może sprawiać wrażenie ogromnego języka. On jest mały w~porównaniu
  z~innymi językami, ale to niewiele zmienia, gdy~się dopiera zaczyna swoją
  przygodę z~informatyką.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czy 1972 rok był bardzo dawno temu?}


    \begin{figure}

    \centering


    \includegraphics[scale=0.3]
    {./PresentationsPictures/Meeting-01/Dennis-Ritchie-Ken-Thompson-PDP-11.jpg}

    \caption{Dennis Ritchie (stojący) i~Ken Thompson pracują na komputerze
      PDP-11 firmy Digital Equipment Corporation.}

    \label{fig:Ritchie-Thompson-PDP-11}

  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przesadnie pedantyczna lista featurów języka~C}


  \begin{itemize}

  \item[1)] Zmienne.

  \item[2)] Typy zmiennych: \texttt{char}, \texttt{short int}, \texttt{int},
    \texttt{long int}, \texttt{float}, \ldots

  \item[3)] Operator przypisania: \texttt{=}.

  \item[4)] Operator arytmetyczne: \texttt{+}, \texttt{-}, \texttt{*},
    \texttt{/}, \texttt{\%}.
    (Jeśli Państwo myślą, że~to banalnie proste, to~się Państwo
    nieprzyjemnie zdziwią.)

  \item[5)] Operatory porównania: \texttt{==} (nie pomylić z~operatorem
    przypisania~\texttt{=}),

  \item[6)] Instrukcje warunkowe: \texttt{if \ldots{} else \ldots}, \texttt{switch}.

  \item[7)] Pętle: \texttt{while}, \texttt{for}, \texttt{do \ldots{} while}.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{?????}


  Nie potrafię teraz powiedzieć, czy zdążymy, choćby bardzo pobieżnie,
  przerobić \alert{wszystkie} featury języka~C. Proszę pamiętać, że~to jest
  kurs \alert{podstaw informatyki}, więc nie należy~się spodziewać,
  że~nauczymy~się tu wszystkiego. Nawet o~podstawach informatyki.

  Lubię myśleć o~języku programowania jako o~skrzynce z~narzędziami.
  Im lepiej znasz swoją skrzynkę, tym prościej ci wykonać dane zadanie.
  Przykładowo, można wyciągnąć śrubę ze~ściany obcęgami, ale lepiej
  wiedzieć, że w~skrzynce jest śrubokręt.

  Tak samo proszę myśleć o~naszej nauce języka~C. Na początku będziemy
  poznawali pojedyncze „narzędzia” jakie są w~tej „skrzynce” są, co niestety
  dla wielu osób jest nudne. Dopiero jednak jak będziemy znali ich
  odpowiednią liczbę ma sens zabieranie~się

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zalety języka~C}


  \begin{itemize}

  \item Pozwala tworzyć bardzo szybkie programy.

  \item Jeśli poznamy~C, to nauka języka który na nim bazuje będzie
    już prostsza. A~60\% najważniejszych języków jakie istnieją, w~jakimś
    stopniu bazuje na~C.

  \item Na świecie jest tyle kodu napisanego w~języku~C, że~jeśli umie~się
    go dobrze, można znaleźć naprawdę dobrze płatną pracę.

  \item Pozwala lepiej poznać jak komputer działa na niskim poziomie.
    (Kwestią dyskusyjną jest to, czy to zaleta, czy raczej wada?)

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wady języka~C}


  \begin{itemize}

  \item Pisane w~C nie jest wcale proste.

  \item C oferuje nam bardzo mało zabezpieczeń przed nami samymi, co
    skutkuje tym, że~bardzo łatwo stworzyć kod w~którym kryją~się
    koszmarnie niebezpieczne rzeczy. To jednak temat na inny przedmiot.

  \item Metody operowania na stringach. A~raczej brak takich metod.

  \item Wiele standardowych funkcji języka~C \alert{nie} powinno być
    używane. Powtarzam, wielu standardowych funkcji dostępnych w~języku~C
    \alert{nie należy} używać pod żadnym pozorem.

  \item Trudne do zapamiętania nazewnictwo. Czasem nazwy w~C są zwyczajnie
    głupie, jak \texttt{unsigned char} (pl.~\textit{znak bez znaku}) na
    oznaczenie pojedynczego bajtu.

  \item Brak normalnego typu boolowskiego. Nawet \texttt{stdbool.h} nie
    rozwiązuje tej sprawy.

  % \item I~miliona innych udogodnień, które daje ci dobry, nowoczesny język
  %   programowania (1972 rok był dawno temu).

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wady języka~C}


  \begin{itemize}

  \item Domyślna konwersja typów. To naprawdę nie pasuje do takiego
    języka jak~C.

  \item Toporny i~niewygodny model kompilacji: pliki nagłówkowe,
    preprocesor, etc.

  \item Brak modułowości.

  \item I~miliona innych udogodnień, które daje ci dobry, nowoczesny język
    programowania (1972 rok był dawno temu).

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jaki jest związek między C a~C++?}


  Taki jak między krzesłem, a~krzesłem elektrycznym. Lub mechaniką
  i~mechaniką kwantową. To są jednak dwa bardzo różne języki programowania,
  które ze~względów historycznych mają pewne wspólne cechy.

  Mówiłem Państwu, że~C to taka skrzynka z~narzędziami. C++ to cały Leroy
  Merlin. Naprawdę, ogarnięcie wszystkich featurów jest zupełnie nie do
  ogarnięcia.

  Języki takie jak C\#, to osobna dyskusja.

\end{frame}
% ##################





% % ##################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ##################










% ######################################
\section{C~to teraźniejszość. A~co jest przyszłością?}
% ######################################



% ##################
\begin{frame}
  \frametitle{C ma ponad 50~lat, co dalej?}


  Jak powiedział amerykański filozof i~bejsbolista Yogi Berra
  (właśc. Lawrence Peter Berra, $1925 \text{--} 2015$) „Przewidywanie jest
  bardzo trudne. Zwłaszcza jeśli próbuje~się przewidywać przyszłość.”
  Dlatego muszę zastrzec, że~to co mówią odnośnie przyszłości, są to moje
  osobiste refleksje. Nie mogę dać żadnej gwarancji, że~się sprawdzą.

  Język~C stworzony w~1972 roku, ma już ponad 50 lat, więc to jasne,
  że~pojawiają~się pomysły na języki które mają go zastąpić. W~pewnym sensie
  C++ jest takim językiem. Jednak od momentu pojawienia~się C++, za taką
  datę możemy przyjąć 1985~rok, minęło sporo czasu, zamiast zastąpić~C,
  język ten żyje obok niego. Ale to bardziej temat na zajęcia o~C++.

  Proszę pamiętać, że~relacja między~C, a~C++, jest jak między krzesłem,
  a~krzesłem elektrycznym.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Nie należy liczyć, że}


  Przez ponad pół wieku~(!) w~C napisano niewiarygodne ilość rewelacyjnie
  działającego kodu (co nie znaczy, że~kod ten jest pozbawiony błędów
  i~wad). Ponieważ utrzymywanie starego kodu jest zwykle prostsze niż
  pisanie nowego, który robi to samo, więc część z~tego kody będzie
  utrzymywana tak długo jak tylko~się będzie dało. Przykładowo, jądro
  systemu operacyjnego Linux jest napisane w~98\% w~języku~C (zobacz
  statystki jego \colorhref{https://github.com/torvalds/linux}{repozytorium}
  na~GitHubie). A~bez tego jądra internet pewnie~się zawali.

  Trzeba też pamiętać, że~cała masa innych języków programowania zależna
  jest od kodu napisanego w~dużej części w~C. Przykładowo, szeroko stosowana
  w~obliczeniach numerycznych biblioteka \texttt{numpy} języka Python,
  w~35\% jest napisana w~języku~C (zob. jego
  \colorhref{https://github.com/numpy/numpy}{repozytorium} na~GitHubie).

  Przyczyna tego jest zwykle prosta: C~pozwala tworzyć bardzo szybki kod.
  Kod napisany w~czystym Pythonie jest niestety relatywnie wolny.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka pojęcia}


  Dobrze, ale co z~kodem napisanym w~C, który chcemy zastąpić nowym oraz
  nowo tworzonym kodem? Czy tutaj język~C jest dalej niezastąpiony? Krótka
  i~bardzo uproszczona odpowiedź jest taka: C~jest tam już zastępowany
  nowymi językami, acz sprawa toczy~się stosunkowo wolno. W~tym momencie
  powiedziałbym, że~C wciąż ma przyszłość.

  Patrząc trochę w~przyszłość, moja opinia na dzień dzisiejszy jest taka,
  że~języka~C \alert{nie} zastąpi jeden język, tylko kilka. Każdy z~nich
  będzie dopasowany do konkretnej dziedziny
  zastosowań, którą obecnie obejmuje (przynajmniej częściowo) język~C.

  W~mojej ocenie, 80\% dotychczasowego pola zastosowań~C przejmą trzy
  języki: \colorhref{https://go.dev/}{Go},
  \colorhref{https://www.rust-lang.org/}{Rust}
  i~\colorhref{https://ziglang.org/}{Zig}. Pozostałe 20\% przyjmie kilka
  innych, wysoce wyspecjalizowanych języków, ale tutaj nie mam odwagi
  zgadywać, jakie to będą.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Uruchamianie komputera z~systemem Pentium}


  Jeśli ktoś chce rozszerzyć swoją wiedzę o~jeden z~wymienionych wcześniej
  języków, Go, Rust i~Zig, to proponuję zacząć od~języka~Go. Jest on
  stosunkowo mały, wygodny w~użyciu i~najbardziej z~całej trójki zbliżony
  do~C, więc studiowanie go równolegle z~C, powinno wymagać najmniej pracy.

  Instrukcje jak pobrać i~zainstalować język~Go, można znaleźć
  \colorhref{https://go.dev/learn/}{tutaj}.

  Gdy chodzi o~materiały do nauki, to początkującym polecam zacząć od
  \colorhref{https://www.youtube.com/watch?v=akosxcqJorU}{\textit{Go for
      Absolute Beginners~-- Tutorial}} kanału freeCodeCamp.org
  i~kursu
  \colorhref{https://www.youtube.com/watch?v=WVjc_wl17FA}{\textit{Go
      tutorial for beginners}} Thomasa Langhorsta. Osoby bardziej
  zaawansowane mogą sięgnąć od razu po oficjalne wprowadzenie do~języka
  \colorhref{https://go.dev/tour/welcome/1}{\textit{A~Tour~of Go}}
  (większość tego wprowadzenia jest dostępna również w~języku polskim).

\end{frame}
% ##################





% % ##################
% \begin{frame}
%   \frametitle{Uruchamianie komputera z~systemem Pentium}


%   \begin{itemize}

%   \item[10)] Jeśli system operacyjny dysponuje wszystkimi sterownikami,
%     to ładuje je do jądra systemu.



%   \item[11)] System operacyjny tworzy tabele systemowe oraz procesy
%     działające w~tle.



%   \item[12)] Uruchamiane jest okno logowania.

%   \end{itemize}

% \end{frame}
% % ##################










% ######################################
\section{Dlaczego istnieją języki takie jak~C?}
% ######################################



% ##################
\begin{frame}
  \frametitle{Dlaczego w~ogóle istnieją takie języki jak~C?}

  \pause


  Żeby komputer coś zrobił musimy więc mu przekazać polecenie w~języku,
  który rozumie. Dla mnie pierwotny językiem jest język polski, co zaś
  jest pierwotnym językiem komputera? Na potrzeby tego kursu przyjmiemy,
  że~pierwotnym językiem komputera jest \textbf{język asembler}
  (ang. \textit{assembly language}).

  Tak jak niektórzy ludzie mają jako swój pierwotny język angielski,
  hiszpański, japoński, niemiecki, polski, etc., tak komputer również
  posługują~się różnymi rodzajami języka asembler, takimi jak \textsc{arm}
  czy x86/Intel. Typ asemblera jest ustalony przez firmę, która
  wyprodukowała procesor, bowiem asembler jest zdefiniowany przez to jak są
  „podpięte kable” w~rzeczonym procesorze.

  Tutaj pojawia~się pewien problem. Przyjrzyjmy~się teraz jednemu programowi
  napisanemu w~typach języka asembler \textsc{arm}, AArch64,
  i~\textsc{nasm} oraz językach C i~Python.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze ARM,
    \parencite{Low-Level-Learning-You-Can-Learn-ARM-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x4} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr r1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov r2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{svc 0} \\

  \hphantom{aaaaaaaa} \texttt{mov x8, \#0x5d} \\
  \hphantom{aaaaaaaa} \texttt{mov x0, \#0x41} \\

  \hphantom{aaaaaaaa} \texttt{svc 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze AArch64,
    \parencite{Low-Level-Learning-You-Can-Learn-AArch64-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov x8, \#64} \\
  \hphantom{aaaaaaaa} \texttt{mov x0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr x1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov x2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#65} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze x86
    \parencite{Anonymous-Hello-World-in-x86-Assembly-Language}}


  \texttt{org 0x100} \\
  \vspace{0.8em}

  \texttt{mov dx, msg} \\
  \texttt{mov ah, 9} \\
  \texttt{int 0x21} \\
  \vspace{0.8em}

  \texttt{mov ah, 0x4c} \\
  \texttt{int 0x21} \\
  \vspace{0.8em}

  \texttt{msg db 'Hello, World!', 0x0d, 0x0a, '\$'}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze NASM
    \parencite{Toal-NASM-Tutorial-Ver-2024}}


  \hphantom{aaaaaaaaa} \texttt{global} \hphantom{aa} \texttt{\_start} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section} \hphantom{a} \texttt{.text} \\
  \texttt{\_start:} \hphantom{a} \texttt{mov} \hphantom{aaaaaa}
  \texttt{rax, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdi, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa}
  \texttt{rsi, message} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdx, 14} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rax, 60} \\
  \hphantom{aaaaaaaaa} \texttt{xor} \hphantom{aaaaaa} \texttt{rdi, rdi} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section .data} \\
  \vspace{0.8em}

  \texttt{message: db} \hphantom{aaaaa} \texttt{"Hello, World!", 10}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~C}


  \texttt{\#include <stdio.h>} \\
  \vspace{0.8em}
  \texttt{int main() \{ } \\
  \hphantom{aaaa} \texttt{printf("Hello, World!\textbackslash n");} \\
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \hphantom{aaaa} \texttt{return 0;} \\
  \texttt{ \} }

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~Python}


  \texttt{print("Hello, World!")}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Co z~tego wynika?}


  Na pierwszy rzut oka powinno być jasne, że~C jest prostszy od~asemblera,
  a~Python prostszy od~C.

  \alert{Ważne.} Czy od tego momentu kursu możemy uznać, że~język
  asemblera sam w~sobie nas zupełnie nie interesuje?

  Jeśli jednak ktoś z~Państwa chce~się dowiedzieć więcej o~asemblerze,
  to bardzo mnie to cieszy, ale musimy to przełożyć na czas po zajęciach.

  Może zadają sobie Państwo pytanie. Czemu w~takim wypadku ten kurs jest
  prowadzony w~C, a~nie w~Pythonie? Gdybym ja miał na to wpływ, to może
  byłby prowadzony w~Pythonie, ale ja o~tym nie decyduje.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Problemy z~asemblerem}


  Większość ludzi zrobi wszystko, by tylko uniknąć pracy w~asemblerze.
  Mam nadzieję, że~nie muszę tłumaczyć dlaczego.  A~nawet jeśli
  znajdzie~się człowieka, który lubi w~nim pisać, to unika~się jak tylko
  można tego, by kod napisany przez niego w~asemblerze wszedł w~skład
  danego programu.

  Jest tak dlatego, że~nawet najlepsi programiści zbyt łatwo mylą~się
  pisząc w~asemblerze, a~pomyłki na jego poziomie są szczególnie
  niebezpieczne. Niestety, wyjaśnienie czemu tak jest, to temat na osobny
  wykład. W~skrócie, błędy w~asemblerze to raj dla hakerów.

  Jak rozwiązujemy ten problem dziś? Tworzymy język taki jak~C, piszemy
  w~nich programy, a~następnie odpowiedni program zwany
  \textbf{kompilatorem} tłumaczy ten program na język asembler.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Prosty schemat działania kompilatora}


  \begin{figure}

    \begin{tikzpicture}[node distance=0.7]

      \path (0,0) -- (-3.5,0);



      \node[diagram rectangle block] (C source code) at (0,0)
      {Kod programu w~języku C};

      \node[diagram block,below=of C source code] (Compiler) {Kompilator};

      \node[color=jNormalTextFGColor,right=of Compiler] (Magic) {Magia};


      \draw[pointing arrow orange] (Magic) -- (Compiler);


      \draw[thick diagram arrow] (C source code) -- (Compiler);


      \node[diagram rectangle block,below=of Compiler] (Assembly code)
      {Kod programu w~asemblerze};


      \draw[thick diagram arrow] (Compiler) -- (Assembly code);

    \end{tikzpicture}

    \caption{Typowy sposób tworzenia programu w~oparciu o~kod źródłowy
      napisany w~języku~C.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Program „Hello, World!” skompilowany z~C\ldots}


  Żeby zobaczyć jaki kod w~języku asembler tworzy kompilator \texttt{gcc}
  należy uruchomić komendę: \\
  \texttt{\$ gcc -S program.c -o program-w-jezyku-asembler.asm}

  Kod języka asemblera jaki zostanie utworzony zależy od miliarda rzeczy
  (typu procesora, wersji kompilatora, etc.). W~każdym razie na moim
  komputerze program „Hello, World!” kompiluje~się do następującego kodu
  języka asemblera.

\end{frame}
% ##################




% ##################
\begin{frame}
  \frametitle{Program „Hello, World!” skompilowany z~C\ldots}


  \hphantom{aaaaa} \texttt{.file} \hphantom{aaa}
  \texttt{"PI-01-A-Program-pokazowy-01.c"} \\
  \hphantom{aaaaa} \texttt{.text} \\
  \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa} \texttt{.rodata} \\
  \texttt{.LC0:} \\
  \hphantom{aaaaa} \texttt{.string "Hello, World!"} \\
  \hphantom{aaaaa} \texttt{.text} \\
  \hphantom{aaaaa} \texttt{.globl} \hphantom{aa} \texttt{main} \\
  \hphantom{aaaaa} \texttt{.type} \hphantom{aaa}
  \texttt{main, @function} \\
  \texttt{main:} \\
  \texttt{.LFB0:} \\
  \hphantom{aaaaa} \texttt{.cfi\_startproc} \\
  \hphantom{aaaaa} \texttt{endbr64} \\
  \hphantom{aaaaa} \texttt{pushq} \hphantom{aaa} \texttt{\%rbp} \\
  \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_offset 16} \\
  \hphantom{aaaaa} \texttt{.cfi\_offset 6, -16} \\

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Program „Hello, World!” skompilowany z~C\ldots}


  % \hphantom{aaaaa} \texttt{.file} \hphantom{aaa}
  % \texttt{"PI-01-A-Program-pokazowy-01.c"} \\
  % \hphantom{aaaaa} \texttt{.text} \\
  % \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa} \texttt{.rodata} \\
  % \texttt{.LC0:} \\
  % \hphantom{aaaaa} \texttt{.string "Hello, World!"} \\
  % \hphantom{aaaaa} \texttt{.text} \\
  % \hphantom{aaaaa} \texttt{.globl} \hphantom{aa} \texttt{main} \\
  % \hphantom{aaaaa} \texttt{.type} \hphantom{aaa}
  % \texttt{main, @function} \\
  % \texttt{main:} \\
  % \texttt{.LFB0} \\
  % \hphantom{aaaaa} \texttt{.cfi\_startproc} \\
  % \hphantom{aaaaa} \texttt{endbr64} \\
  % \hphantom{aaaaa} \texttt{pushq} \hphantom{aaa} \texttt{\%rbp} \\
  % \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_offset 16} \\
  % \hphantom{aaaaa} \texttt{.cfi\_offset 6, -16} \\
  \hphantom{aaaaa} \texttt{movq} \hphantom{aaa} \texttt{\%rsp, \%rbp} \\
  \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_regitser 6} \\
  \hphantom{aaaaa} \texttt{leaq} \hphantom{aaa}
  \texttt{.LC0(\%rip), \%rax} \\
  \hphantom{aaaaa} \texttt{movq} \hphantom{aaa} \texttt{\%rax, \%rdi} \\
  \hphantom{aaaaa} \texttt{call} \hphantom{aaa} \texttt{puts@PLT} \\
  \hphantom{aaaaa} \texttt{movl} \hphantom{aaa} \texttt{\$0, \%eax} \\
  \hphantom{aaaaa} \texttt{popq} \hphantom{aaa} \texttt{\%rbp} \\
  \hphantom{aaaaa} \texttt{.cfi\_def\_cfa 7, 8} \\
  \hphantom{aaaaa} \texttt{ret} \\
  \hphantom{aaaaa} \texttt{.cfi\_endproc} \\
  \texttt{.LFE0:} \\
  \hphantom{aaaaa} \texttt{.size} \hphantom{aaa} \texttt{main, .-main} \\
  \hphantom{aaaaa} \texttt{.ident} \hphantom{aa}
  \texttt{"GCC: (Ubuntu 11.4.0-1ubuntu1-22.04) 11.4.0"} \\
  \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa}
  \texttt{.note.GNU-stack,"",@progbits} \\
  \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa}
  \texttt{.note.gnu.property,"a"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Program „Hello, World!” skompilowany z~C\ldots}


  % \hphantom{aaaaa} \texttt{.file} \hphantom{aaa}
  % \texttt{"PI-01-A-Program-pokazowy-01.c"} \\
  % \hphantom{aaaaa} \texttt{.text} \\
  % \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa} \texttt{.rodata} \\
  % \texttt{.LC0:} \\
  % \hphantom{aaaaa} \texttt{.string "Hello, World!"} \\
  % \hphantom{aaaaa} \texttt{.text} \\
  % \hphantom{aaaaa} \texttt{.globl} \hphantom{aa} \texttt{main} \\
  % \hphantom{aaaaa} \texttt{.type} \hphantom{aaa}
  % \texttt{main, @function} \\
  % \texttt{main:} \\
  % \texttt{.LFB0} \\
  % \hphantom{aaaaa} \texttt{.cfi\_startproc} \\
  % \hphantom{aaaaa} \texttt{endbr64} \\
  % \hphantom{aaaaa} \texttt{pushq} \hphantom{aaa} \texttt{\%rbp} \\
  % \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_offset 16} \\
  % \hphantom{aaaaa} \texttt{.cfi\_offset 6, -16} \\
  % \hphantom{aaaaa} \texttt{movq} \hphantom{aaa} \texttt{\%rsp, \%rbp} \\
  % \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_regitser 6} \\
  % \hphantom{aaaaa} \texttt{leaq} \hphantom{aaa}
  % \texttt{.LC0(\%rip), \%rax} \\
  % \hphantom{aaaaa} \texttt{movq} \hphantom{aaa} \texttt{\%rax, \%rdi} \\
  % \hphantom{aaaaa} \texttt{call} \hphantom{aaa} \texttt{puts@PLT} \\
  % \hphantom{aaaaa} \texttt{movl} \hphantom{aaa} \texttt{\$0, \%eax} \\
  % \hphantom{aaaaa} \texttt{popq} \hphantom{aaa} \texttt{\%rbp} \\
  % \hphantom{aaaaa} \texttt{.cfi\_def\_cfa 7, 8} \\
  % \hphantom{aaaaa} \texttt{ret} \\
  % \hphantom{aaaaa} \texttt{.cfi\_endproc} \\
  % \texttt{.LFE0:} \\
  % \hphantom{aaaaa} \texttt{.size} \hphantom{aaa} \texttt{main, .-main} \\
  % \hphantom{aaaaa} \texttt{.ident} \hphantom{aa}
  % \texttt{"GCC: (Ubuntu 11.4.0-1ubuntu1-22.04) 11.4.0"} \\
  % \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa}
  % \texttt{.note.GNU-stack,"",@progbits} \\
  % \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa}
  % \texttt{.note.gnu.property,"a"}
  \hphantom{aaaaa} \texttt{.align 8} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{1f - 0f} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{4f - 1f} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{5} \\
  \texttt{0:} \\
  \hphantom{aaaaa} \texttt{.string "GNU"} \\
  \texttt{1:} \\
  \hphantom{aaaaa} \texttt{.align 8} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{0xc0000002} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{3f - 2f} \\
  \texttt{2:} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{0x3} \\
  \texttt{3:} \\
  \hphantom{aaaaa} \texttt{.align 8} \\
  \texttt{4:}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jakie są inne języki programowania?}


  Wymieńmy 20 najpopularniejszych języków programowania według indeksu
  \textsc{tiobe} (\colorhref{https://www.tiobe.com/tiobe-index/}
  {https://www.tiobe.com/tiobe-index/}). Poniżej prezentowany jest stan
  tego indeksu na lipiec 2024. Podane wielkości procentowe przedstawiają
  wyliczoną przez twórców indeksu część programistów używających danego
  języka.

  \begin{itemize}

  \item[1)] Python, 16.12\%.

  \item[2)] C++, 10.34\%.

  \item[3)] C, 9.48\%.

  \item[4)] Java, 8.59\%.

  \item[5)] C\#, 6.72\%.

  \item[6)] JavaScript, 3.79\%.

  \item[7)] Go, 2.19\%.

  \item[8)] Visual Basic, 2.08\%.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jakie są inne języki programowania?}


  \begin{itemize}

  \item[9)] Fortran, 2.05\%.

  \item[10)] SQL, 2.04\%.

  \item[11)] Delphi/Object Pascal, 1.89\%.

  \item[12)] MATLAB, 1.34\%.

  \item[13)] Rust, 1.18\%.

  \item[14)] Ruby, 1.16\%.

  \item[15)] Scratch, 1.15\%.

  \item[16)] PHP, 1.15\%.

  \item[17)] Swift, 1.13\%.

  \item[18)] Assembly language, 1.11\%.

  \item[19)] COBOL, 1.08\%.

  \item[20)] Kotlin, 1.05\%.

  \end{itemize}

\end{frame}
% ##################





% % ##################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ##################































% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ############################
% End of the document

\end{document}
