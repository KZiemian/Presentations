% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located
% in the directory "preambule".
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/ImportingLocalPackages.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Podstawy-informatyki-ETC-Bibliography.bib}





% ------------------------------------------------------
% Importing packages, libraries and setting their configuration
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
% \usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation.
\usepackage{./Local-packages/local-settings}

% Package containing various command useful for working with a text.
\usepackage{./Local-packages/general-commands}

% % Styles for drawing diagrams
% \usepackage{./Local-packages/PGF-TikZ-Diagram-styles}

% % Jagiellonian theme's colors
% \usepackage{./Local-packages/jagiellonian-theme-colors}










% ------------------------------------------------------------------------------------------------------------------
\title{Podstawy informatyki z~językiem~C}
\subtitle{3. Programowanie nie jest trudne, debugowanie już
  tak}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Number of chars: 7k+,
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################










% ######################################
\section{Programowanie nie jest trudne. Debugowanie już tak}
% ######################################


% ##################
\begin{frame}
  \frametitle{Programowanie nie jest trudne. Debugowanie już
    tak}


  \textit{Debugowanie programu jest dwa razy trudniejsze, niż jego
    napisanie. Jeśli więc napiszesz program w~najbardziej inteligentny
    sposób jaki możesz, to nie jesteś wystarczająco mądry by go
    zdebugować.} \\
  Prawo
  \colorhref{https://en.wikipedia.org/wiki/Brian\_Kernighan}{Kernighana}.

  Proszę pamiętać, że~pisanie programów nie jest trudne, ich debugowanie już
  tak. Na tych zajęciach będziemy próbować wspólnie stawiać pierwsze kroki
  na drodze nauki debugowania programów.

  Przypomnijmy jak działa język~C. Piszemy program z~kodem źródłowym
  w~języku~C, który ma być zawarty w~pliku, którego nazwa \alert{kończy~się
    na~\texttt{.c}}. Następnie program zwany kompilatorem na podstawie
  tego kodu źródłowego generuje program wykonywalny \texttt{prog.out}.
  Kompilator to też program komputerowy, więc to my, ludzie, ustalamy
  jego zasady działania.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Błędy}


  Twórcy języka~C przyjęli, że~jeśli coś jest nie tak, to kompilator może
  zwrócić jedną z~dwóch rodzai wiadomości: \textbf{błąd}
  (ang.~\textit{error}) i~\textbf{ostrzeżenie} (ang.~\textit{warning}).
  Różnica między nimi jest następująca.

  Zwrócenie błędu przez kompilator można zrozumieć, jako następująca
  informację od niego. „Człowieku, ten kod który napisałeś w~linii
  numer~X (mniej więcej) jest tak zły, że~ja nie wygenerują ci pliku
  wykonywalnego. Napraw ten błąd i~spróbuj jeszcze raz.”

  Ze względu na to jak skomplikowany jest proces kompilacji oraz na~wiek
  języka~C, informacje o~błędach są często bardzo trudne w~zrozumieniu
  i~niezbyt precyzyjne. To naprawdę skomplikowany temat. Jedną z~rzeczy,
  które należy rozumieć jest to, że~jeśli kompilator twierdzi, że~błąd
  jest w~linii $20$, to on zwykle w~tej linii jest, ale kompilator
  może~się mylić i~błąd znajduje~się wcześniej albo później. Bo dlaczego
  życie miałoby być proste?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ostrzeżenia}


  Jeśli kompilator zwróci ostrzeżenie, to można to rozumieć jakby mówił:
  „Kod w~tym miejscu wygląda na zły, ale skoro tak chcesz, to wygeneruję
  program wykonalny zgodnie z~tym kodem. Jeśli samolot spadnie przez to
  z~nieba, to ja nie biorę za to odpowiedzialności.”

  Warto dodać, że~twórcy języka Go, stwierdzili, że~kompilator nie
  powinien zwracać ostrzeżeń, bo dzieje~się dokładnie to czego można~się
  było spodziewać: programiści ignorują ostrzeżenia. Bo czy program~się
  uruchamia? Tak. To czym~się przejmować? Skutkiem tego istniejący
  kod jest pełen podejrzanych miejsc, których programistą nie chciało~się
  zwyczajnie poprawić. Z~tego powodu w~języku Go są tylko błędy, więc
  programista musi je wszystkie poprawić.

  Na tym przedmiocie obowiązuje zasada, że~każdy program ma zostać
  doprowadzony do stanu, w~którym kompilator podczas jego przetwarzania
  nie zgłasza żadnego ostrzeżenia. Państwo na pewno rozumieją, dlaczego
  przyjęliśmy takie zasady.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Błąd? Ostrzeżenie? Who cares?}


  Niestety, jedną z~problemów w~pracy z~językiem~C jest to, że~czasem
  dostajemy od kompilatora ostrzeżenie, a~jak~się przyjrzymy, to
  okazuje~się, że~wystąpił błąd. Czyli widzimy, że~kompilator pisze
  „Ostrzegam ciebie\ldots” i~myślimy sobie „Okej, uruchomię plik i~zobaczę jak
  działa.”. A~pliku nie ma. Bo czemu życie miałoby być proste?

  Można by powiedzieć pewne rzeczy na usprawiedliwienie kompilatora,
  ale~to temat na inny przedmiot. Przyjmijmy po prostu, że~kompilator
  to dość uciążliwy przyjaciel.

\end{frame}
% ##################










% ######################################
\section{Trochę terminologi}
% ######################################


% ##################
\begin{frame}
  \frametitle{Terminologia w~informatyce to nie jest nic
    przyjemnego}


  Powiedzmy sobie szczerze, terminologia w~informatyce potrafi dać w~kość.
  Jednak trzeba przez to przejść, by~się całkiem nie pogubić.

  Fragment kodu, który mówi językowi~C, że~ma coś zrobić nazywamy
  \textbf{poleceniem}. Polecenia dzielą~się na \textbf{wyrażenia}
  (ang. \textit{expression}) i~\textbf{instrukcje}. Wyrażenie robi
  coś i~zwraca wynik, podczas gdy instrukcja tylko coś robi.

  Typowy przykład wyrażenia to \\
  \texttt{1 + 2} \\
  które dokonuje obliczenia (coś robi) i~zwraca jako rezultat~$3$.
  Przykładem instrukcji jest instrukcja sterująca \texttt{if}. W~pliku
  \texttt{PI-04-F-Wyrażenia-i-instrukcje.c} znajduje~się kod ilustrujący
  różnice między wyrażeniami, a~instrukcjami.


\end{frame}
% ##################










% ######################################
\section{Intuicyjne wprowadzenie do algebr Boole’a}
% ######################################



% ##################
\begin{frame}
  \frametitle{Logika i~algebry Boole’a}


  W~programowaniu niezwykle ważne jest posiadanie umiejętność operowania
  na~pojęciach logicznej prawdy oraz fałszu i~dokonywania na nich operacji
  iloczynu oraz sumy logicznej. Z~tego powodu zdecydowaliśmy~się przygotować
  to krótki omówienie tych zagadnień i~włączyć je do kursu
  \textit{Podstaw informatyki}. To, że~naszymi adresatami są informatycy
  mocno wpłynęło na~wybór i~sposób prezentacji materiału, o~czym należy
  pamiętać ucząc~się go. Staraliśmy~się również, by wykład był możliwie
  prosty, stąd liczne uproszczenia i~pominięcie wielu subtelności jakie te
  zagadnienia sobą prezentują.

  Tematyka ta funkcjonuje pod kilkoma nazwami: „logika”, „logika
  matematyczna”, „klasyczny rachunek zdań”, „algebra Boole’a”,~etc.
  Spośród wymienionych nazw jedne są bardziej, drugie mniej trafne.
  W~informatyce pojęcie „zmiennej boolowskiej” i,~trochę mniej, „algebry
  Boole’a”, są mocno rozpowszechnione, dlatego zdecydowaliśmy właśnie
  ich używać.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Logiczna prawda i~fałsz}


  Dla algebry Boole’a podstawowe są dwie wielkości oznaczające odpowiednio
  wartość logiczną prawdy i~fałszu. Prawdę logiczną będziemy oznaczać
  symbolem \texttt{true}, zaś~fałsz symbolem \texttt{false}. Nazywamy
  jej \textbf{wartościami boolowskimi} (ang. \textit{boolean values})
  lub \textbf{wartościami logicznymi} (ang. \textit{logical values}).

  W~praktyce istnieje wiele różnych sposobów oznaczania tych wielkości
  w~komputerze. W~języku Go są one oznaczane przez \texttt{true}
  i~\texttt{false}. W~języku Python przez \texttt{True} i~\texttt{False}
  (proszę zwrócić uwagę na wielkość liter). W~języku C fałsz reprezentuj
  liczba całkowita równa $0$, prawdą jest każda inna liczba całkowita.
  Domyślnie w~języku~C, prawdę reprezentuje liczba~$1$.

  Należy pamiętać, że~to iż prawdę w~języku~C reprezentuje liczba~$1$,
  to \alert{nie} jest własność języka~C, ale umowa między programistami.
  Niemniej tej umowy \alert{absolutnie} nie wolno łamać, jeśli komuś
  jest drogie zdrowie i~życie.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  W~języku~C można również korzystać z~protezy typu boolowskiego jaką daje
  nam \texttt{stdbool.h}. W~języku C++ sytuacja jest w~zasadzie taka sama
  jak w~języku~C++.

  Spróbujemy teraz wyjaśnić intuicyjny sens algebry Boole’a, wychodząc
  od pojęcia \textbf{zdania logicznego}. Zdaniem logicznym nazywamy
  dowolne stwierdzenie, któremu możemy przypisać wartość logicznej prawdy
  lub fałszu. Zdaniami takimi mogą być „Jan jest na mieście.”, „Jan je
  kanapkę.”, czy znane nam już z~języka~C wyrażenia takie jak
  „\texttt{intVar1 == 5}”, „\texttt{intVar1 < 3}”,
  „\texttt{intVar1 > -4}”,~etc. Zdania „Gra \textit{Nine Sols} jest
  lepsza, niż \textit{Hollow Knight}.”, czy „Teodor Parnicki jest
  lepszym pisarzem niż Sienkiewicz.”, nie zaliczymy do zdań logicznych,
  bo~nie jest wcale jasne, czy są one prawdziwe czy nie.

  Podstawową cechą algebry Boole’a jest możliwość łączenia zdań logicznych
  w~większe zdania logiczne. Zademonstrujemy to na przykładzie łącznika
  zdań~„i”.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  Weźmy zdania „Jan jest na mieście.” oraz „Jan je kanapkę.”. Z~pomocą
  łącznika „i” możemy teraz utworzyć nowe zdanie \\
  „Jan jest na mieście i~Jan je kanapkę.” \\
  Kiedy to zdanie jest prawdziwe? Przyjmujemy, że~jest ono prawdziwe
  tylko wtedy, gdy jednocześnie jest prawdą, że~Jan jest na mieści, jak
  i~to, że~je kanapkę. W~każdym innym przypadku zdanie to uważamy, za
  fałszywe. Czyli zdanie to jest fałszywe, jeśli Jan jest na mieście,
  ale nie je kanapki. Jak również wtedy, gdy Jan je kanapkę siedząc w~domu
  oraz gdy ja siedzi w~domu i~niczego nie je.

  Takie rozumienie łącznika „i”~jest zgodne ze znaczeniem, jakie ten wyraz
  często posiada w~języku polskim i~innych językach. Musimy podkreślić,
  że~w~algebrze Boole’a łącznik „i”~ma proste znaczenie. Tworzy z~dwóch
  zdań jedno i~to zdanie wynikowe jest prawdziwe, tylko wtedy, gdy oba
  zdania składowa są prawdziwe.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  To, że~w~języku polskim słowo~„i” może występować w~innych znaczeniach,
  wychodzi poza interesujący nas temat. Przykładowo „i”~ma inny sens
  w~zdaniu „Weź mleko i~jajka i~mąkę.”, niż ten który właśnie omówiliśmy.
  Jednak dla nas, jako dla informatyków, interesujące jest nie badanie
  takich zawiłości języków naturalnych, czyli używanych przez ludzi,
  lecz pewna bardzo konkretne procedury rachunkowe. To mamy nadzieję zaraz
  stanie~się bardziej zrozumiałe.

  Aby podkreślić, że~używamy słowa „i” w~tym konkretnym znaczeniu,
  zamiast „i” będziemy pisać „\texttt{\&\&}”. Ten dziwaczny wybór
  jest podyktowany tym, że~w~języku~C, jak i~większości innych języków,
  spójnik „i” oznacza~się właśnie tym symbolem. Będziemy więc pisać \\
  „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.” \\
  Może ten zapis wygląda dziwnie, ale informatycy są do niego
  przyzwyczajeni i~w~takiej czy innej formie jest powszechnie stosowany.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  By użyć bardziej informatycznego przykładu, zdanie \\
  \texttt{(intVar1 < 3) \&\& (-5 < intVar1)} \\
  oznacza, że~wartość przechowywana przez zmienną \texttt{intVar1}
  spełnia nierówność \texttt{-5 < intVar1 < 3}. Jeśli to nie jest jasne,
  to proszę~się nad tym chwilę zastanowić. Ewentualnie poprosić o~dalsze
  wyjaśnienia.

  Znaczenie algebry Boole’a dla informatyki polega na tym, że~teraz
  możemy napisać choćby następujący kod. Jego pełna wersja jest w~pliku
  \texttt{PI-04-E-Przykład-wykorzystania-iloczynu-logicznego.c}. \\[0.3em]
  \texttt{if ((intVar1 < 3) \&\& (-5 < intVar1)) \{ } \\
  \hphantom{aaaa} \texttt{printf("Wartość zmiennej intVar1 zawiera się "} \\
  \hphantom{aaaaaaaaaaa}
  \texttt{"w pożądanym zakresie.\textbackslash n");} \\
  \texttt{ \} else \{ } \\
  \hphantom{aaaa} \texttt{printf("Wartość zmiennej intVar1 znajduje~się
    poza "}
  \\
  \hphantom{aaaaaaaaaaa} \texttt{"pożądany zakres.\textbackslash n");} \\
  \texttt{ \} }
  % Gdy chodzi o~notację dla iloczynu logicznego to ta jest dość zróżnicowana.
  % Język C i~większość najpopularniejszych języków programowania oznacza
  % go za~pomocą symbolu . Proszę zauważyć, że~w~tych językach
  % symbol „\texttt{\&}” oznacza pewną operację, która jednak \textit{nie
  %   jest} iloczynem logicznym. Język Python oznacza ją za pomocą
  % angielskiego symbolu „\texttt{and}”. W~matematyce często zapisuję~się ją
  % za pomocą symbolu~„$\wedge$”.

  % My~będziemy korzystać z~symbolu „\texttt{\&\&}”.

  % To, że~w~języku polskim słowo~„i” może występować w~innych znaczeniach,
  % wychodzi poza interesujący nas temat. Przykładowo „i”~ma inny sens
  % w~zdaniu „Weź mleko i~jajka i~mąkę.”, niż ten który właśnie omówiliśmy.
  % Jednak dla nas, jako dla informatyków, interesujące jest nie badanie
  % takich zawiłości języków naturalnych, czyli używanych przez ludzi,
  % lecz pewna bardzo konkretne procedury rachunkowe. To mamy nadzieję zaraz
  % stanie~się bardziej zrozumiałe.

  % Aby podkreślić, że~używamy słowa „i” w~tym konkretnym znaczeniu,
  % zamiast „i” będziemy pisać „\texttt{\&\&}”. Ten dziwaczny wybór
  % jest podyktowany tym, że~w~języku~C, jak i~większości innych języków,
  % spójnik „i” oznacza~się właśnie tym symbolem. Będziemy więc pisać \\
  % „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.” \\
  % Może ten zapis wygląda dziwnie, ale informatycy są do niego
  % przyzwyczajeni.
  % By użyć bardziej informatycznego przykładu, zdanie \\
  % \texttt{(intVar1 < 3) \&\& (-5 < intVar1)} \\
  % oznacza, że~wartość przechowywana przez zmienną \texttt{intVar1}
  % spełnia nierówność \texttt{-5 < intVar1 < 3}. Jeśli to nie jest jasne,
  % to proszę~się nad tym chwilę zastanowić.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pewna osobliwości algebry Boole’a}


  Musimy wskazać na pewną osobliwość spójnika \texttt{\&\&} i~samej
  algebry Boole’a. Rozpatrzmy zdanie \\
  „Jan je kanapkę \texttt{\&\&} Paryż jest stolicą Francji.” \\
  Zdanie to jest prawdziwe, jeśli oba tworzące go zdania są prawdziwe.
  Jednak łatwo zauważyć, że~nie ma żadnego związku między tym, że~Jan
  je kanapkę, a~tym czy dane miasto jest stolicą Francji, co może~się
  wydawać nienaturalne.

  Gdy łączymy dwa zdania za pomocą \texttt{\&\&} to o~prawdziwości nowo
  powstałego zdania decyduje tylko prawdziwość lub~fałszywość zdań
  składowych, \alert{nie} ich treść. Jest to świadomy wybór, który ma duże
  znaczenie z~punktu widzenia informatyki. Redukuje on sprawdzenie
  prawdziwość nowego zdania do prostego rachunku, a~w~rachunkach
  komputery są bardzo dobre.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Rachunkowa strona algebry Boole’a}


  Jest to ważne bo komputery mają naprawdę duże problemy z~operowaniem
  na treściach zdań. Przykładowo, jeśli mamy zdanie „Paryż jest stolicą
  Francji.”, to język~C nie posiada narzędzi, które pozwalałby ustalić, czy
  to zdanie dotyczy osoby, mebla, czy miasta. Jeśli jednak C wie, że~to
  zdanie jest prawdziwe, to cała reszta redukuje~się do rachunków,
  w~których~C jest bardzo dobry.

  Spójrzmy na to od innej strony. Oznaczmy przez \texttt{zdanie1} zdanie
  „Jan je kanapkę.”, zaś przez \texttt{zdanie2} „Paryż jest stolicą
  Francji.”. Zdanie \\
  „Jan je kanapkę \texttt{\&\&} Paryż jest stolicą Francji.” \\
  możemy teraz zapisać jako \\
  \texttt{zdanie1 \&\& zdanie2} \\
  Jeśli to zdanie jest prawdziwe to piszemy \\
  \texttt{zdanie1 \&\& zdanie2 == true} \\
  Jeśli zaś jest fałszywe to piszemy \\
  \texttt{zdanie1 \&\& zdanie2 == false}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Rachunkowa strona algebry Boole’a}


  Fakt, że~połączenie dwóch zdań prawdziwych za pomocą \texttt{\&\&}
  daje zdanie prawdziwe, zapisujemy jako \\
  \texttt{true \&\& true == true}

  Teraz wszystkie własności rachunkowe łącznika \texttt{\&\&} możemy
  zawrzeć w~prostej tabeli.



  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    zdanie1 & zdanie2 & zdanie1 \&\& zdanie2 \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Podsumowanie}


  Na tym zakończymy nasze intuicyjne wprowadzenie do algebr Boole’a
  i~przejdziemy do bardziej technicznego ich omówienia. Jeśli Państwo
  uważają, że~to intuicyjne omówienie nie jest satysfakcjonujące to
  proszę do nas napisać \email.

\end{frame}
% ##################










% ######################################
\section{Podstawy algebry Boole’a}
% ######################################


% ##################
\begin{frame}
  \frametitle{Zmienne boolowskie}


  Pojęcia logicznej prawdy i~fałszu zostały już omówione i~nie będziemy
  ich szerzej dyskutować, gdyż jest to bardziej przedmiotem filozofii, niż
  informatyki. A~materiał z~informatyki mamy na tym kursie dość.

  W~informatyce oprócz wartości logiczny \texttt{true} i~\texttt{false}
  dużą rolę odgrywają \textbf{zmienne boolowskimi}, zwane też
  \textbf{zmiennymi logicznymi}. Są~to zmienne które mogą przechowywać
  wartości logiczne \texttt{true} i~\texttt{false}. Tak jak w~przypadku
  sposobu reprezentowania wartości logicznych, również gdy chodzi
  o~zmienne, sposób ich działania zależy w~dużej mierze od używanego języka.

  Wyjątkowo zaczniemy od przytoczenia przykładu z~języka Go, gdyż pozwala
  pracować na wartościach i~zmiennych boolowskich w~dużo prostszy
  i~bezpieczniejszy sposób, niż język~C.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zmienne boolowskie}




  Rozpatrzmy przypadek języka~C. Ponieważ wartości logiczne reprezentują
  w~nim liczby całkowite, więc jako zmiennej logicznej możemy użyć dowolnej
  zmiennej która przechowuje wartości całkowitoliczbowe. Zmienne tego typu
  w~języku~C są zwykle typu \texttt{int}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zmienne boolowskie}


  Poniżej prezentujemy przykładowy fragment programu napisanego w~języku~Go
  operujący na zmiennych logicznych. Symbol „\texttt{//}” oznacza, że~tekst
  na prawo od niego jest komentarzem dla człowieka i~jest zupełnie
  ignorowany przez komputer.

  \textit{Uwaga.} To jest tylko fragment programu w~języku~Go i~ze względu
  na brakujące części nie da~się go uruchomić.

  \texttt{// Tworzymy zmienną logiczną "boolVar" i~nadajemy jej} \\
  \texttt{// wartość "false".} \\
  \texttt{var boolVar bool = false} \\
  \vspace{0.8em}
  \texttt{// Zmieniamy wartość logiczną zmiennej "boolVar" na "true".} \\
  \texttt{boolVar = true}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wyrażenie boolowskie}


  \textbf{Wyrażeniem boolowskim} (ang.~\textit{boolean expression}) zwane
  też \textbf{wyrażeniem logicznym} (ang.~\textit{logical expression})
  zwane  to dowolne wyrażenie w~wyniku obliczenia którego zostaje zwrócona
  wartość boolowska \texttt{true} albo \texttt{false}.

  \textit{Ważne.} Wyrażenie jest tylko i~wyłącznie obiekt, który
  \textit{zwraca} pewną wartość. W~przeciwnym razie mamy do czynienia
  z~\textbf{poleceniem} (ang. \textit{statement}).

  Przyjmujemy, że~wartości boolowskie \texttt{true} i~\texttt{false}, które
  zwracają jako swoją wartość same siebie. Nawet jeśli wydaje~się to dziwne
  i~przekombinowane, to taki sposób myślenia ma swoje zastosowania
  w~informatyce.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Operatory boolowskie}


  Jeśli funkcja o~nazwie \texttt{funBool} zwraca jako wartość zmienną
  boolowską, to jej wywołanie \\
  \texttt{funBool(argumenty funkcji)} \\
  jest wyrażeniem boolowskim. Takie funkcje spotyka~się w~praktyce, jednak
  częściej wyrażenia boolwskie tworzy~się za pomocą odpowiednich operatorów
  logicznych.

  \textbf{Operatorem boolowskim} (ang. \textit{boolean operator}) lub
  \textbf{operatorem logicznym} (ang. \textit{logcial operator})
  nazywamy symbol reprezentujący \textbf{operacje}, która to operacja
  pozwala z~dwóch wyrażeń boolowskich utworzyć nowe wyrażenie. Cztery
  podstawowe, z~punktu widzenia informatyki, operatory boolowskie to:
  logiczny iloczyn, logiczna suma, logiczna negacja i~operacja porównania.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Operatory boolowskie}


  \textbf{Iloczyn logiczny}, zwany też \textbf{koniunkcją logiczną},
  odpowiada zasadniczo temu co~w~języku polskim oznacza spójnik~„i”. Łączy
  on parę dwa wyrażenie boolowskie, zwracając logiczną prawdę wtedy i~tylko
  wtedy gdy wartość pierwszego \textit{i}~drugiego wyrażenia są~prawdziwe.
  W~przeciwny razie zwraca logiczny fałsz.



\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Iloczyn logiczny}


  Zgodnie z~tym co powiedziano wcześniej, wyrażenie \\
  \texttt{true \&\& false} \\
  jest wyrażeniem boolowskim i~zwraca wartość to \texttt{false}.

  Własności iloczynu logicznego można podsumować za pomocą następującej
  tabeli, gdzie \texttt{boolVar1} i~\texttt{boolVar2} to odpowiednie zmienne
  boolowskie. Jeśli zmienne \texttt{boolVar1} i~\texttt{boolVar2} mają
  wartości takie jak w~dwóch pierwszych kolumnach, to wartość iloczynu
  logicznego tych zmiennych podana jest w~trzeciej kolumnie.

  \vspace{1em}





  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    boolVar1 & boolVar2 & boolVar1 \&\& boolVar2 \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Tabelki operatorów logicznych}


  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    boolVar1 & boolVar2 & boolVar1 \&\& boolVar2 \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

  \vspace{1em}





  Choć w~tabeli powyższe występują zmienne boolowskie, to jest ona
  prawdziwa dla dowolnych wyrażeń boolowskich. Proszę przy tym pamiętać,
  że~każda zmienna boolowska jest dla nas wyrażeniem boolowskim, ale nie
  każde wyrażenie boolowskie jest po prostu zmienną boolowską. Niezależnie
  od tych subtelności, jeśli wartości zwracane przez dwa wyrażenia
  boolowskie są takie jak w~dwóch pierwszych tabelach, to ich iloczyn
  logiczny ma wartości wyrażoną w~trzeciej.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Suma logiczna}


  \textbf{Suma logiczna}, zwana też \textbf{alternatywą logiczną} odpowiada
  mniej więcej temu, co w~języku polskim oznacza spójnik „lub”. Łączy ona
  dwa wyrażenia boolowskie dając nową wyrażenie, która wartość \texttt{true}
  jeśli wartość pierwszego \textit{lub} drugiego jest równa \texttt{true}.

  Podobnie jak dla iloczynu logicznego, język C i~za nim większość
  najpopularniejszy języków programowania oznacza sumę logiczną symbolem
  „\texttt{||}”. Ponownie, trzeba mieć na uwagę, że~w~tych językach~symbol
  „\texttt{|}” posiada osobne znaczenie. W~Pythonie operację tą oznacza
  symbol „\texttt{or}”. W~matematyce często stosuje~się symbol~„$\vee$”.

  My będziemy go zapisywać za~pomocą symbolu „\texttt{||}”.

  Na podstawie tego co powiedziano powyżej \\
  \texttt{false || true} \\
  jest wyrażeniem logicznym i~zwraca wartość \texttt{true}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Suma logiczna}


  Podstawowe własności sumy logicznej podaje poniższa tabela.

  \vspace{1em}





  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    \texttt{boolVar1} & \texttt{boolVar2}
    & \texttt{boolVar1 || boolVar2} \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{true}  \\
    \texttt{false} & \texttt{true}  & \texttt{true}  \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Negacja logiczna}


  \textbf{Negacja logiczna} odpowiada w~przybliżeniu co polskie słowo „nie”.
  Negacja prawdy logicznej jest fałszem, a~negacja fałszu jest prawdą.

  W~językach programowania negację danego wyrażenia \texttt{expr}, zwykle
  oznacza~się poprzez poprzedzenie go symbolem~„\texttt{!}” i~my też
  będziemy korzystać z~tego zapisu. W~matematyce często stosuje~się symbol
  „\texttt{$\neg$}”. Negację wyrażenia \texttt{expr} zapiszemy więc odpowiednio
  jako \texttt{!expr} lub \texttt{$\neg$expr}.

  Własności negacji logicznej podsumowuje poniższa tabelka.

  \vspace{1em}





  \begingroup

  \centering

  \begin{tabular}{|c|c|}
    \hline
    \texttt{boolVar1} & \texttt{!boolVar1} \\
    \hline
    \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{true}  \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Porównanie logiczne}


  \textbf{Porównanie logiczne} jest prawdą, wtedy i~tylko wtedy, gdy obie
  porównywane strony mają tą samą wartość logiczną.

  W~informatyce do porównywania zwykle używamy podwójnego znaku równości
  „\texttt{==}”, my też z~niego będziemy korzystali. Oczywiście, tutaj też
  muszą być wyjątki od tej reguły, ale prawdziwe źródło komplikacji
  leży gdzie indziej. Zanim o~nich powiemy, przytoczymy tabelę
  podsumowującą własności tej operacji.

  \vspace{1em}





  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    \texttt{boolVar1} & \texttt{boolVar2}
    & \texttt{boolVar1 == boolVar2} \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{true}  \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Porównanie logiczne}


  Podstawowy problem z~operatorem „\texttt{==}” polega na tym,
  że~w~większości języków służy nie tylko do porównywania wyrażeń
  boolowskich, ale do porównywania wszystkich obiektów, których wartości
  można porównywać. Dostajemy w~ten sposób wyrażenie boolowskie.

  Przykładowo, w~języku C, Go czy w~Pythonie można za~jego pomocą
  porównywać liczby całkowite, tworząc odpowiednie wyrażenia boolowskie.
  Tym samym \\
  \texttt{0 == 1} \\
  jest w~tych językach wyrażeniem boolowskim, którego wartość logiczna jest
  równa \texttt{false}. Proszę pamiętać, że~w~każdym z~tych języków
  wartości logiczne są trochę inaczej reprezentowane.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Porównanie logiczne}


  Należy zwrócić uwagę, że~operator „\texttt{==}” zwykle sprawdza równość
  \textit{wartość} wyrażeń, nie ich \textit{identyczność}. Przykładowo,
  załóżmy, że~mamy dwie zmienne typu \texttt{int} w~języku~C, niech~się
  nazywają \texttt{intVar1} i~\texttt{intVar2}. Każda z~nich zawiera pewną
  wartość i~możemy~się pytać o~równość tych wartości. Możemy~się też
  zapytać, czy obie zmienne zajmują ten sam obszar pamięci (choćby pamięci
  \textsc{ram}), wtedy pytamy~się o~ich identyczność.

  Tym samym w~języku~C wyrażenie \\
  \texttt{intVar1 == intVar2} \\
  sprawdza, czy \textit{wartość} przechowywane przez obie te
  zmienne są równe, nie czy te zmienne są identyczne. Powtórzymy,
  identyczność zmiennych oznacza, że~są one po prostu dwiema różnymi
  nazwami na~to~samo (ten sam obszar pamięci).

\end{frame}
% ##################










% ######################################
\section{Parsowanie i~ewalucaja wyrażeń boolowskich}
% ######################################



% ##################
\begin{frame}
  \frametitle{Co to jest „parsowanie”?}


  Słowo „parsowanie” (ang.~\textit{parsing}) jest wzięte z~angielskiego
  i~oznacza, przynajmniej dla nas, tyle co „analiza składniowa wyrażenia”
  (ang. \textit{syntax analysis~of expression}), czyli ustalenie co dane
  wyrażenie tak naprawdę znaczy. Można uznać, że~jest to mądrze brzmiące
  słowo na zrozumienie co dany wzór znaczy.

  Przykładowo, co oznacza następujące wyrażenie arytmetyczne? \\
  \texttt{1 + 2 * 3} \\
  Parsowanie tego wyrażenia, które mamy tak wbite do głowy, że~pewnie o~tym
  nie myślimy, mówi nam, że~najpierw musimy wykonać mnożenie
  \texttt{2 * 3}, dostając liczbę \texttt{6}, następnie dodajemy do
  niej liczbę~\texttt{1} dostając w~wyniku~\texttt{7}.

  Teraz omówimy reguły parsowania wyrażeń boolowskich, ale najpierw musimy
  wyjaśnić co to jest ewaluacja przez krótkie spięcie.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ewaluacja przez krótkie spięcie}


  \textbf{Ewaluacja} (ang. \textit{evaluation}) oznacza obliczanie wartości
  danego wyrażenia. Nie potrafię znaleźć lepszego tłumaczenia tego zwrotu
  na~język polski.

  \textbf{Ewaluacja przez krótkie spięcie} (ang. \textit{short-circut
    evaluation}) to powszechnie stosowana w~informatyce technika obliczania
  wyrażeń boolowskich będących ciągiem \texttt{\&\&} lub \texttt{||}.
  Metody ta jest stosowana w~większości najpopularniejszy języków
  programowania.

  Rozpatrzmy wyrażenie boolowskie postaci \\
  \texttt{boolExpr1 \&\& boolExpr2 \&\& boolExpr3 \&\& boolExpr4} \\
  Można je przepisać jako \\
  \texttt{boolExpr1 \&\& (boolExpr2 \&\& (boolExpr3 \&\& boolExpr4))} \\
  Pomimo, że~nie omówiliśmy reguł obliczania tego typu wyrażeń, sens
  powyższej notacji powinien być jasny poprzez analogię z~arytmetyką.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ewaluacja przez krótkie spięcie}


  \texttt{boolExpr1 \&\& (boolExpr2 \&\& (boolExpr3 \&\& boolExpr4))}

  Z~własności iloczynu logicznego wynika, że~jeśli co najmniej jedno
  wyrażenie boolowskie \texttt{boolExpr1}, \texttt{boolExpr2},
  \texttt{boolExpr3}, \texttt{boolExpr4} zwraca wartość \texttt{false}, to
  cały iloczyn ma wartość \texttt{false}.

  Wynik ten automatycznie przenosi~się na wyrażenie o~tej samej formie
  zbudowane z~$N$ wyrażeń boolowskich: \\
  \texttt{boolExpr1 \&\& boolExpr2 \&\& \ldots{} \&\& boolExprN}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ewaluacja przez krótkie spięcie}


  Rozpatrzmy teraz następujące wyrażenie. \\
  \texttt{false \&\& (false || (true \&\& false)) \&\& (true \&\&
    (false || \\ }
  \hphantom{aaaa}\texttt{|| (true \&\& false)))}

  Mamy tu trzy wyrażenia w~iloczynie logicznym i~powinno być dość
  oczywiste, że~obliczenie drugie i~trzeciego z~nich będzie
  nasz kosztowało trochę pracy. Jednak obliczanie ich jest zupełnie
  zbytecznie, bo skoro pierwsze wyrażenie ma wartość \texttt{false} to
  wartość całego wyrażenie jest równa \texttt{false} i~nie musimy obliczać
  konkretnej wartości dwóch pozostałych wyrażeń. Oszczędza to nam sporo
  pracy.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ewaluacja przez krótkie spięcie}


  \texttt{false \&\& (false || (true \&\& false)) \&\& (true \&\&
    (false || \\ }
  \hphantom{aaaa}\texttt{|| (true \&\& false)))}

  \textit{Uwaga.} W~rozumowaniu przedstawionym na poprzednim slajdzie
  przyjęliśmy, że~interesuje nas tylko wartość logiczna \textit{całego}
  wyrażenie, nie rezultaty zwrócone przez konkretne wyrazy.

  Można napisać kod w~którym wartość zwrócone przez konkretne wyrażenia
  składowe mają znaczenie, ale pisanie takiego kodu jest bardzo złą
  praktyką. Dlatego ten przypadek będziemy ignorować.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ewaluacja przez krótkie spięcie}


  \texttt{false \&\& (false || (true \&\& false)) \&\& (true \&\&
    (false || \\ }
  \hphantom{aaaa}\texttt{|| (true \&\& false)))}

  % \vspace{0.8em}


  Regułę ewaluacji przez krótkie spięcie dla iloczynu logicznego można więc
  opisać w~następujący sposób. Jeśli na najwyższym poziomie analizowane
  wyrażenie jest ciągiem mniejszych wyrażeń połączonych symbolem
  \texttt{\&\&} to obliczamy je od lewej do prawej, aż~dojdziemy do końca
  lub do pierwszego wyrażenia które zwróciło jako swoją wartość
  \texttt{false}. W~tym ostatnim przypadku zwracamy jako wartość całego
  wyrażenia \texttt{false} i~nie obliczamy dalszych wyrazów. W~pozostałych
  przypadkach zwracamy \texttt{true} jako wartość całego wyrażenia.

  Jeśli to wyrażenie jest dla Państwa intuicyjnie zrozumiałe, to jest to
  ważniejsze, niż ewentualne luki w~jego sformułowaniu.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ewaluacja przez krótkie spięcie}


  \texttt{boolExpr1 || boolExpr2 || boolExpr3 || \ldots{} || boolExprN}

  Analogicznie działa ewaluacja przez krótkie spięcie dla ciągu wyrażeń
  połączonych operacją \texttt{||}. Tym razem korzystamy z~tego, że~jeśli
  w~tym ciągu choć jedno wyrażenie ma wartość logiczną \texttt{true} to całe
  to wyrażenie ma wartość ma wartość \texttt{true}.

  Jeśli więc na najwyższym poziomie analizowane wyrażenie jest ciągiem
  mniejszych wyrażeń połączonych operatorem \texttt{||} to obliczamy je od
  lewej do prawej, aż~dojdziemy do końca lub do pierwszego wyrażenia które
  zwróciło jako swoją wartość \texttt{true}. W~tym ostatnim przypadku
  zwracamy jako wartość całego wyrażenia \texttt{true} i~nie obliczamy
  dalszych wyrazów. W~pozostałych przypadkach zwracamy \texttt{false} jako
  wartość całego wyrażenia.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Parsowanie i~ewaluacja wyrażeń boolowskich}


  Reguły mówiące w~jakiej kolejności obliczać wyrażenia boolowskie
  są podane poniżej, przy czym najpierw wykonujemy te o~niższym numerze.
  Od razu musimy zaznaczyć, że~zasady te obowiązują w~większości języków
  programowania, acz, bo czemu życie miałoby być tak proste, zdarzają~się
  wyjątki.

  \begin{itemize}

  \item[1)] Jeżeli na najwyższym poziomie wyrażenie jest ciągiem
    \texttt{\&\&} albo \texttt{||} to dokonujemy ewaluacji przez krótkie
    spięcie.



  \item[2)] Wyrażenie w~nawiasach.



  \item[2)] Negacja logiczna.



  \item[3)] Iloczyn logiczny.



  \item[4)] Suma logiczna.



  \item[5)] Porównanie logiczne.

  \end{itemize}

  Tutaj ponownie, intuicyjna zrozumiałość jest ważniejsza, niż precyzyjne
  sformułowanie tych reguł.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przykład~1}


  Rozpatrzmy wyrażenie \\
  \texttt{false || true \&\& (false || !false) || !true \&\& true}

  W~wyniku jego parsowania na podstawie reguł 2--5 dostajemy: \\
  \texttt{false || (true \&\& (false || (!false))) ||
    ((!true) \&\& true)} \\
  Teraz stosujemy ewaluację przez krótkie spięcie. Wyrażenie \texttt{false}
  ma wartość \texttt{false}, więc przechodzi do drugiego z~nich: \\
  \texttt{(true \&\& (false || (!false)))} \\
  Stosując kilkakrotnie regułę~2 dochodzimy do wniosku, że~najpierw musimy
  obliczyć \\
  \texttt{!false == true}. \\
  Mamy więc \\
  \texttt{(true \&\& (false || true))} \\
  Znów z~reguły~2 wynika, że~najpierw należy wyliczyć \\
  \texttt{(false || true) == true}.

\end{frame}
% ##################








% ##################
\begin{frame}
  \frametitle{Przykład~1}


  Mamy więc \\
  \texttt{(true \&\& (false || (!false))) == true \&\& true == true}.

  Z~tego wynika, że~drugi wyrażenie w \\
  \texttt{false || true \&\& (false || !false) || !true \&\& true}, \\
  ma wartość logiczną \texttt{true}, więc na mocy ewaluacji przez krótkie
  spięcie, całe to wyrażenie ma wartość logiczną \texttt{true} i~nie
  ma potrzeby obliczanie wartości trzeciego wyrażenia.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przykład~2}


  Rozpatrzmy teraz kilka bardzo prostych, ale również bardzo użytecznych
  w~informatyce wyrażeń boolowskich, ewaluowanych metodą krótkiego spięcia.

  \texttt{boolExpr1 \&\& boolExpr2} \\
  Załóżmy, że~\texttt{boolExpr1} zwraca nam wartość \texttt{true}. Wówczas
  wyrażenie przyjmuje postać \\
  \texttt{true \&\& boolExpr2}. \\
  W~takiej sytuacji wyrażenie \texttt{boolExpr2} musi zostać obliczone i~na
  podstawie przytoczonej tabelki dla \texttt{\&\&} możemy~się łatwo
  przekonać, że~zachodzi zależność \\
  \texttt{true \&\& boolExpr2 == boolExpr2}.

  Jeśli \texttt{boolExpr1} zwraca wartość \texttt{false}, to~zgodnie
  z~zasadą ewaluacji przez krótkie spięcie wartość \texttt{boolExpr2}
  nie zostanie nigdy wyliczona.

\end{frame}
% ##################



% ##################
\begin{frame}
  \frametitle{Rachunkowa strona algebry Boole’a}




  Gdy chodzi o~notację dla iloczynu logicznego to ta jest dość zróżnicowana.
  Język C i~większość najpopularniejszych języków programowania oznacza
  go za~pomocą symbolu . Proszę zauważyć, że~w~tych językach
  symbol „\texttt{\&}” oznacza pewną operację, która jednak \textit{nie
    jest} iloczynem logicznym. Język Python oznacza ją za pomocą
  angielskiego symbolu „\texttt{and}”. W~matematyce często zapisuję~się ją
  za pomocą symbolu~„$\wedge$”.

  My~będziemy korzystać z~symbolu „\texttt{\&\&}”.

  To, że~w~języku polskim słowo~„i” może występować w~innych znaczeniach,
  wychodzi poza interesujący nas temat. Przykładowo „i”~ma inny sens
  w~zdaniu „Weź mleko i~jajka i~mąkę.”, niż ten który właśnie omówiliśmy.
  Jednak dla nas, jako dla informatyków, interesujące jest nie badanie
  takich zawiłości języków naturalnych, czyli używanych przez ludzi,
  lecz pewna bardzo konkretne procedury rachunkowe. To mamy nadzieję zaraz
  stanie~się bardziej zrozumiałe.

  Aby podkreślić, że~używamy słowa „i” w~tym konkretnym znaczeniu,
  zamiast „i” będziemy pisać „\texttt{\&\&}”. Ten dziwaczny wybór
  jest podyktowany tym, że~w~języku~C, jak i~większości innych języków,
  spójnik „i” oznacza~się właśnie tym symbolem. Będziemy więc pisać \\
  „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.” \\
  Może ten zapis wygląda dziwnie, ale informatycy są do niego
  przyzwyczajeni.
  By użyć bardziej informatycznego przykładu, zdanie \\
  \texttt{(intVar1 < 3) \&\& (-5 < intVar1)} \\
  oznacza, że~wartość przechowywana przez zmienną \texttt{intVar1}
  spełnia nierówność \texttt{-5 < intVar1 < 3}. Jeśli to nie jest jasne,
  to proszę~się nad tym chwilę zastanowić.

  Gdy chodzi o~notację dla iloczynu logicznego to ta jest dość zróżnicowana.
  Język C i~większość najpopularniejszych języków programowania oznacza
  go za~pomocą symbolu . Proszę zauważyć, że~w~tych językach
  symbol „\texttt{\&}” oznacza pewną operację, która jednak \textit{nie
    jest} iloczynem logicznym. Język Python oznacza ją za pomocą
  angielskiego symbolu „\texttt{and}”. W~matematyce często zapisuję~się ją
  za pomocą symbolu~„$\wedge$”.

  My~będziemy korzystać z~symbolu „\texttt{\&\&}”.

    Gdy chodzi o~notację dla iloczynu logicznego to ta jest dość zróżnicowana.
  Język C i~większość najpopularniejszych języków programowania oznacza
  go za~pomocą symbolu . Proszę zauważyć, że~w~tych językach
  symbol „\texttt{\&}” oznacza pewną operację, która jednak \textit{nie
    jest} iloczynem logicznym. Język Python oznacza ją za pomocą
  angielskiego symbolu „\texttt{and}”. W~matematyce często zapisuję~się ją
  za pomocą symbolu~„$\wedge$”.

  My~będziemy korzystać z~symbolu „\texttt{\&\&}”.

  To, że~w~języku polskim słowo~„i” może występować w~innych znaczeniach,
  wychodzi poza interesujący nas temat. Przykładowo „i”~ma inny sens
  w~zdaniu „Weź mleko i~jajka i~mąkę.”, niż ten który właśnie omówiliśmy.
  Jednak dla nas, jako dla informatyków, interesujące jest nie badanie
  takich zawiłości języków naturalnych, czyli używanych przez ludzi,
  lecz pewna bardzo konkretne procedury rachunkowe. To mamy nadzieję zaraz
  stanie~się bardziej zrozumiałe.

  Aby podkreślić, że~używamy słowa „i” w~tym konkretnym znaczeniu,
  zamiast „i” będziemy pisać „\texttt{\&\&}”. Ten dziwaczny wybór
  jest podyktowany tym, że~w~języku~C, jak i~większości innych języków,
  spójnik „i” oznacza~się właśnie tym symbolem. Będziemy więc pisać \\
  „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.” \\
  Może ten zapis wygląda dziwnie, ale informatycy są do niego
  przyzwyczajeni.
  By użyć bardziej informatycznego przykładu, zdanie \\
  \texttt{(intVar1 < 3) \&\& (-5 < intVar1)} \\
  oznacza, że~wartość przechowywana przez zmienną \texttt{intVar1}
  spełnia nierówność \texttt{-5 < intVar1 < 3}. Jeśli to nie jest jasne,
  to proszę~się nad tym chwilę zastanowić.

\end{frame}
% ##################




% ##################
\begin{frame}
  \frametitle{Kim był Boole?}


  % \begin{figure}

  %   \centering

  %   \includegraphics[scale=0.195]
  %   {./Presentations-pictures/George-Boole.jpeg}

  %   \caption{George Boole (1815--1864), brytyjski matematyk i~filozof.
  %     Wprowadził metody algebraiczne do logiki. \textbf{Algebra Boole’a}
  %   została nazwana na jego cześć.}

  %   \label{fig:George-Boole}

  % \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Algebry Boole’a w~informatyce}


  Algebra Boole’a może już być Państwu znana pod nazwą „logiki”,
  „logiki matematycznej”, „rachunku zdań”, etc. Najbardziej poprawną
  nazwą w~tym kontekście jest \textbf{klasyczny rachunku zdań}, jednak
  informacje o~nim ograniczymy do niezbędnego minimum. Osoby zainteresowany
  tym tematem mogą sięgnąć do następujących pozycji.
  \begin{itemize}

  \item Andrzej Grzegorczyk \textit{Zarys logiki matematycznej}
    \parencite{Grzegorczyk-Zarys-logiki-matematycznej-Pub-1975}.



  \item Willard von Ormian Quine \textit{Logika matematyczna}
    \parencite{Quine-Logika-matematyczna-Pub-1974}.



  \item Zdzisław Kraszewski \textit{Logika. Nauka rozumowania}
    \parencite{Kraszewski-Logika-Pub-1984}.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Algebry Boole’a w~informatyce}


  Do informatyki algebry Boole’a wprowadził je zapewne Claude E.~Shannon
  (1916--2001), gdy zrozumiał jakie użyteczne w~projektowaniu układów
  elektronicznych mogą być idea Boole’a, które poznał na kursie
  z~filozofii. Obecnie są one powszechnie stosowane tak w~teorii jak
  i~praktyce informatyki, że~każdy dobry informatyk musi~się umieć nimi
  posługiwać.

\end{frame}
% ##################










% ######################################
\appendix
% ######################################





% ######################################
\EndingSlide{Dziękujemy! Pytania?}
% ######################################









% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ############################
% End of the document

\end{document}
