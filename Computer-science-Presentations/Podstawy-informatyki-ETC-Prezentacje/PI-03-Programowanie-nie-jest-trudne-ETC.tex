% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located in
% the directory "preambule"
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/ImportingLocalPackages.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Podstawy-informatyki-ETC-Bibliography.bib}





% ------------------------------------------------------
% Importing packages, libraries and setting their configuration
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
% \usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation
\usepackage{./Local-packages/local-settings}

% % Styles for arrows
% \usepackage{./Local-packages/PGF-TikZ-Arrows-styles}

% % Styles for drawing diagrams
% \usepackage{./Local-packages/PGF-TikZ-Diagram-styles}

% % Jagiellonian theme's colors
% \usepackage{./Local-packages/jagiellonian-theme-colors}










% ------------------------------------------------------------------------------------------------------------------
\title{Podstawy informatyki z~językiem~C}
\subtitle{Programowanie nie jest trudne, debugowanie już tak}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Number of chars: 7k+,
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################










% ######################################
\section{Programowanie nie jest trudne. Debugowanie już tak}
% ######################################


% ##################
\begin{frame}
  \frametitle{Programowanie nie jest trudne. Debugowanie już
    tak}


  \textit{Debugowanie programu jest dwa razy trudniejsze, niż jego
    napisanie. Jeśli więc napiszesz program w~najbardziej inteligentny
    sposób jaki możesz, to nie jesteś wystarczająco mądry by go
    zdebugować.} \\
  Prawo
  \colorhref{https://en.wikipedia.org/wiki/Brian\_Kernighan}{Kernighana}.

  Proszę pamiętać, że~pisanie programów nie jest trudne, ich debugowanie już
  tak. Pomimo tego postaram~się postawić wspólnie kilka kroków na trudnej
  ścieżce nauki debugowania programów.

  Przypomnijmy jak działa język~C. Piszemy program z~kodem źródłowym
  w~języku~C, który ma być zawarty w~pliku, którego nazwa \alert{kończy~się
    na~\texttt{.c}}. Następnie program zwany kompilatorem na podstawie
  tego kodu źródłowego generuje program wykonywalny \texttt{prog.out}.
  Kompilator to też program komputerowy, więc to my, ludzie, ustalamy
  jego zasady pracy.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Błędy}


  Twórcy języka~C przyjęli, że~kompilator może zwrócić nam dwa rodzaje
  wiadomości, że~coś jest nie tak: \textbf{błędy} (ang.~\textit{errors})
  i~\textbf{ostrzeżenia} (ang.~\textit{warnings}). Różnica między nimi
  jest następująca.

  Zwrócenie błędu przez kompilator można zrozumieć, jako następująca
  informację od niego. „Człowieku, ten kod który napisałeś w~linii
  numer X (mniej więcej) jest tak zły, że~ja nie wygenerują ci pliku
  wykonywalnego. Napraw ten błąd i~spróbuj jeszcze raz.”

  Ze względu na to jak skomplikowany jest proces kompilacji oraz wieku
  języka~C, informacje o~błędach często są bardzo trudne w~zrozumieniu
  i~niezbyt precyzyjne. To naprawdę skomplikowany temat. Jedną z~rzeczy,
  które należy rozumieć jest to, że~jeśli kompilator twierdzi, że~błąd
  jest w~linii $20$, to on zwykle w~tej linii jest, ale kompilator
  może~się mylić i~błąd znajduje~się wcześniej albo później. Bo dlaczego
  życie miałoby być proste?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ostrzeżenia}


  Jeśli kompilator zwróci ostrzeżenie, to można to rozumieć jak mówił:
  „Kod w~tym miejscu wygląda na potencjalnie wadliwy, ale skoro tak chcesz,
  to wygeneruję program zgodnie z~nim. Jeśli samolot spadnie przez to
  z~nieba, to ja nie biorę za to odpowiedzialności.”

  Warto dodać, że~twórcy języka Go, stwierdzili, że~kompilator nie
  powinien zwracać ostrzeżeń, bo dzieje~się dokładnie to czego można~się
  byłoby spodziewać. Programiści ignorują ostrzeżenia, bo czy program został
  wygenerowany? Tak. To czym~się przejmować? Skutkiem tego istniejący
  kod jest pełen podejrzanych miejsc, których programistą nie chciało~się
  zwyczajnie poprawić. Z~tego powodu w~języku Go są tylko błędy, więc
  programista musi je wszystkie poprawić.

  Na tym przedmiocie obowiązuje zasada, że~każdy program ma zostać
  doprowadzony do stanu, w~którym kompilator podczas jego przetwarzania
  nie zgłasza żadnego ostrzeżenia. Państwo rozumieją, dlaczego takie zasady
  przyjęliśmy.

\end{frame}
% ##################










% ######################################
\section{Typy zmiennych}
% ######################################


% ##################
\begin{frame}
  \frametitle{Czym są typy zmiennych?}


  Widzieliśmy już kilka typów zmiennych, takich jak liczby całkowite
  i~liczby zmiennoprzecinkowe: \\
  \texttt{int intVar1 = 0;} \\
  \texttt{int float64Var1 = 0.0;} \\
  Czym jednak dokładniej jest typ zmiennej? To wbrew pozorom jest bardzo
  głęboki problem, który pojawił~się w~rozważaniach
  filozoficzno-matematycznych kilka dekad wcześniej, nim ludzkość
  skonstruowała pierwszy komputer z~prawdziwego zdarzenia. Powinno być
  oczywiste, że~na takim przedmiocie jak \textit{Podstawy informatyki}
  możemy omówić ten temat tylko na intuicyjnym poziomie.

  Dzisiejsze komputery buduje~się w~ten sposób, że~najmniejszą porcją pamięci
  jakiej możemy używać jest jeden bajt, czyli $8$~bitów. Techniczny
  termin na taką najmniejszą jednostkę pamięci nazywamy
  \textbf{słowem} (ang.~\textit{word}). Historycznie istniały komputery,
  których najmniejszą jednostką było powiedzmy $6$~bitów, ale to nie są
  zajęcia z~historii informatyki.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Abstrakcja w~informatyce}


  Historycznie istniały komputery, których najmniejszą jednostką było
  powiedzmy $6$~bitów, ale to nie są zajęcia z~historii informatyki.

  Moglibyśmy korzystać komputera operując tylko na bajtach jako takich,
  ale byłaby to męka nie do pojęcia. Jeśli ktoś z~Państwa pisał kiedyś
  w~jakimś dialekcie assemblera, wie o~co chodzi.

  By to zilustrować, proszę sobie wyobrazić, że~zamiast zdjęcia na dysku,
  musimy operować ręcznie na milionie~(!) bajtów które taki rysunek tworzą.
  Kopiowanie zdjęcia wyglądałoby wtedy mniej więcej tak. Weź bajty
  o~numerach od $1 \, 555 \, 000$ do $2 \, 554 \, 000$ i~skopiuj
  zawartość każdego z~nich do bajtów o~numerach $11 \, 000 \, 073$
  do~$12 \, 000 \, 072$. Koszmar na~jawie!

  By tego uniknąć wprowadzamy coś, co w~informatyce określamy terminem
  \textbf{abstrakcja}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Abstrakcja w~informatyce}


  Zdjęcie na komputerze to pewna abstrakcja, która zwalnia nas z~myślenia
  o~nim jako o~milionie bajtów, które tworzą ten rysunek na~dysku. Inny
  przykładem tego typu zachowania jest to, że zamiast mówić „To jest
  zwierzę, które jest ssakiem, ma cztery nogi, ogon, futro, jest
  drapieżnikiem,\ldots” powiemy „To jest pies.”. Takie dzielenie rzeczy na różne
  kategorie i~operować tak wprowadzonymi kategoriami okazuje~się być bardzo
  wygodne. Mamy nadzieję, że~takie wyjaśnienie koncepcji abstrakcji
  w~informatyce jest dla Państwa wystarczająca.

  Typy zmiennych istnieją z~tego samego powodu, zamiast myśleć „Tu mam kilka
  bajtów.”, prościej jest myśleć „Tu mam liczbę całkowitą”. Poza tym, typy
  zmiennych pozwalają komputerowi lepiej kontrolować działanie programów,
  to jest jednak temat rzeka, zbyt obszerny na ramy tego przedmiotu,
  pozostaniemy na poziomie kilku ogólnych uwag.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pożytek z~typów}


  Rozpatrzmy następujący, mocno uproszczony przykład. Powiedzmy, że~używamy
  dwóch rodzajów plików: graficznych oraz tekstowych. Dzięki typom, nasz
  program może rozpoznać, że~chcemy zapisać coś do~pliku graficznego, ale
  otwarliśmy plik tekstowy i~zgłosi błąd, co jest bardzo pożądanym
  zachowaniem. Jeśli Państwo jeszcze tego nie widzą, to myślę, że~na tym
  przedmiocie napotkamy dostatecznie wiele przykładów, które pokazując,
  czemu jest to dobra rzecz.

  Należy też dodać, że~w~różnych językach granica między typami jest mniej
  lub bardziej ostra. Przykładowo, czy w~miejscu, gdzie program oczekuje
  liczby zmiennoprzecinkowej, mogę użyć liczby całkowitej~$1$? Wedle
  niektórych języków, tak, bo wszak wiadomo jak zamienić liczbę całkowitą~$1$
  na liczbę zmiennoprzecinkową~$1.0$. Wedle innych języków, nie,
  bo~taka zmiana jednego typu liczbowego na drugi, może prowadzić do
  błędów numerycznych, których programista może nie być świadomy pisząc
  program.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pożytek z~typów}


  W~tym drugim typie~;) języków, programista musi jawnie poprosić
  o~\textbf{konwersje typów}. Czyli musi napisać kod, który mówi coś
  w~stylu „Wiem, że~to jest liczba całkowita i~w~tym miejscu masz
  ją zamienić na liczbę zmiennoprzecinkową. Ja biorę odpowiedzialność
  za to co~się stanie.” O~konwersji typów powiem w~swoim czasie.

  Język~C stosuje podejście mieszane. Bo czemu życie miałoby być proste?
  Przykładowo, liczby całkowite zamienia na zmiennoprzecinkowe bez
  pytania~się programisty o~pozwolenie, przy innych typach musimy~się sami
  napracować. Wolelibyśmy uniknąć szczegółowej dyskusji tego typu zagadnień,
  gdyż są ważniejsze rzeczy, którym należy poświęcić czas na~przedmiocie
  \textit{Podstawy informatyki}.

\end{frame}
% ##################










% % ############################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ############################































% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ############################
% End of the document

\end{document}
