% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located
% in the directory "preambule".
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/ImportingLocalPackages.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Podstawy-informatyki-ETC-Bibliography.bib}





% ------------------------------------------------------
% Importing packages, libraries and setting their configuration
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
% \usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation.
\usepackage{./Local-packages/local-settings}

% Package containing various command useful for working with a text.
\usepackage{./Local-packages/general-commands}

% % Styles for drawing diagrams
% \usepackage{./Local-packages/PGF-TikZ-Diagram-styles}

% % Jagiellonian theme's colors
% \usepackage{./Local-packages/jagiellonian-theme-colors}










% ------------------------------------------------------------------------------------------------------------------
\title{Podstawy informatyki z~językiem~C}
\subtitle{3. Programowanie nie jest trudne, debugowanie już
  tak}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Number of chars: 7k+, 44k+,
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################










% ######################################
\section{Programowanie nie jest trudne. Debugowanie już tak}
% ######################################


% ##################
\begin{frame}
  \frametitle{Programowanie nie jest trudne. Debugowanie już
    tak}


  \textit{Debugowanie programu jest dwa razy trudniejsze, niż jego
    napisanie. Jeśli więc napiszesz program w~najbardziej inteligentny
    sposób jaki możesz, to nie jesteś wystarczająco mądry by go
    zdebugować.} \\
  Prawo
  \colorhref{https://en.wikipedia.org/wiki/Brian\_Kernighan}{Kernighana}.

  Proszę pamiętać, że~pisanie programów nie jest trudne, ich debugowanie już
  tak. Na tych zajęciach będziemy próbować wspólnie stawiać pierwsze kroki
  na drodze nauki debugowania programów.

  Przypomnijmy jak działa język~C. Piszemy program z~kodem źródłowym
  w~języku~C, który ma być zawarty w~pliku, którego nazwa \alert{kończy~się
    na~\texttt{.c}}. Następnie program zwany kompilatorem na podstawie
  tego kodu źródłowego generuje program wykonywalny \texttt{prog.out}.
  Kompilator to też program komputerowy, więc to my, ludzie, ustalamy
  jego zasady działania.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Błędy}


  Twórcy języka~C przyjęli, że~jeśli coś jest nie tak, to kompilator może
  zwrócić jedną z~dwóch rodzai wiadomości: \textbf{błąd}
  (ang.~\textit{error}) i~\textbf{ostrzeżenie} (ang.~\textit{warning}).
  Różnica między nimi jest następująca.

  Zwrócenie błędu przez kompilator można zrozumieć, jako następująca
  informację od niego. „Człowieku, ten kod który napisałeś w~linii
  numer~X (mniej więcej) jest tak zły, że~ja nie wygenerują ci pliku
  wykonywalnego. Napraw ten błąd i~spróbuj jeszcze raz.”

  Ze względu na to jak skomplikowany jest proces kompilacji oraz na~wiek
  języka~C, informacje o~błędach oraz ostrzeżeniach są często bardzo trudne
  w~zrozumieniu i~niezbyt precyzyjne. To naprawdę zawiły temat.
  Jedną z~rzeczy, które należy rozumieć jest to, że~jeśli kompilator
  twierdzi, że~błąd jest w~linii $20$, to on zwykle w~tej linii jest, ale
  kompilator może~się mylić i~błąd znajduje~się wcześniej albo później. Bo
  dlaczego życie miałoby być proste?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Ostrzeżenia}


  Jeśli kompilator zwróci ostrzeżenie, to można to rozumieć jakby mówił:
  „Kod w~tym miejscu wygląda na zły, ale skoro tak chcesz, to wygeneruję
  program wykonalny zgodnie z~tym kodem. Jeśli samolot spadnie przez to
  z~nieba, to ja nie biorę za to odpowiedzialności.”

  Warto dodać, że~twórcy języka Go, stwierdzili, że~kompilator nie
  powinien zwracać ostrzeżeń, bo dzieje~się dokładnie to czego można~się
  było spodziewać: programiści ignorują ostrzeżenia. Bo czy program~się
  uruchamia? Tak. To czym~się przejmować? Skutkiem tego istniejący
  kod jest pełen podejrzanych miejsc, których programistą nie chciało~się
  zwyczajnie poprawić. Z~tego powodu w~języku Go są tylko błędy, więc
  programista musi je wszystkie poprawić.

  Na tym przedmiocie obowiązuje zasada, że~każdy program ma zostać
  doprowadzony do stanu, w~którym kompilator podczas jego przetwarzania
  nie zgłasza żadnego ostrzeżenia. Państwo na pewno rozumieją, dlaczego
  przyjęliśmy takie standardy.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Błąd? Ostrzeżenie? Who cares?}


  Niestety, jedną z~problemów w~pracy z~językiem~C jest to, że~czasem
  dostajemy od kompilatora ostrzeżenie, a~jak~się przyjrzymy, to
  okazuje~się, że~wystąpił błąd. Czyli widzimy, że~kompilator pisze
  „Ostrzegam ciebie\ldots” i~myślimy sobie „Okej, uruchomię plik i~zobaczę jak
  działa.”. A~pliku nie ma. Bo czemu życie miałoby być proste?

  Można by powiedzieć pewne rzeczy na usprawiedliwienie kompilatora,
  ale~to temat na inny przedmiot. Przyjmijmy po prostu, że~kompilator
  to dość uciążliwy przyjaciel.

\end{frame}
% ##################










% ######################################
\section{Trochę terminologi}
% ######################################


% ##################
\begin{frame}
  \frametitle{Terminologia w~informatyce to nie jest nic
    przyjemnego}


  Powiedzmy sobie szczerze, terminologia w~informatyce potrafi dać w~kość.
  Jednak trzeba przez to przejść, by~się całkiem nie pogubić.

  Fragment kodu, który mówi językowi~C, że~ma coś zrobić nazywamy
  \textbf{instrukcją} (ang.~\textit{instruction}). Instrukcje dzielą~się na
  \textbf{wyrażenia}(ang.~\textit{expression}) i~\textbf{orzeczenia}
  (ang.~\textit{statement}). Wyrażenie robi coś i~zwraca wynik, podczas gdy
  orzeczenie tylko coś robi.

  Typowy przykład wyrażenia to \\
  \texttt{1 + 2} \\
  które dokonuje obliczenia (coś robi) i~zwraca jako rezultat~$3$.
  Przykładem orzeczenia jest instrukcja sterująca \texttt{if}. W~pliku
  \texttt{PI-04-F-Wyrażenia-i-instrukcje.c} znajduje~się kod ilustrujący
  różnice między wyrażeniami, a~orzeczeniami.


\end{frame}
% ##################










% ######################################
\section{Intuicyjne wprowadzenie do algebr Boole’a}
% ######################################



% ##################
\begin{frame}
  \frametitle{Logika i~algebry Boole’a}


  W~programowaniu niezwykle ważne jest posiadanie umiejętność operowania
  na~pojęciach logicznej prawdy oraz fałszu i~dokonywania na nich operacji
  iloczynu oraz sumy logicznej. Z~tego powodu zdecydowaliśmy~się przygotować
  to krótki omówienie tych zagadnień i~włączyć je do materiałów
  z~\textit{Podstaw informatyki}. To, że~naszymi adresatami są informatycy
  mocno wpłynęło na~wybór i~sposób prezentacji materiału, o~czym należy
  pamiętać ucząc~się go. Staraliśmy~się również, by wykład był możliwie
  prosty, stąd liczne uproszczenia i~pominięcie wielu subtelności jakie te
  zagadnienia sobą prezentują.

  Tematyka ta funkcjonuje pod kilkoma nazwami: „logika”, „logika
  matematyczna”, „klasyczny rachunek zdań”, „algebra Boole’a”,~etc.
  Spośród wymienionych nazw jedne są bardziej, drugie mniej trafne.
  W~informatyce pojęcie „zmiennej boolowskiej” i,~trochę mniej, „algebry
  Boole’a”, są mocno rozpowszechnione, dlatego zdecydowaliśmy właśnie
  ich używać.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Logiczna prawda i~fałsz}


  Dla algebry Boole’a podstawowe są dwie wielkości oznaczające odpowiednio
  wartość logiczną prawdy i~fałszu. Prawdę logiczną będziemy oznaczać
  symbolem \texttt{true}, zaś~fałsz symbolem \texttt{false}. Nazywamy
  jej \textbf{wartościami boolowskimi} (ang. \textit{boolean values})
  lub \textbf{wartościami logicznymi} (ang. \textit{logical values}).

  W~praktyce istnieje wiele różnych sposobów oznaczania tych wielkości
  w~komputerze. W~języku Go są one oznaczane przez \texttt{true}
  i~\texttt{false}. W~języku Python przez \texttt{True} i~\texttt{False}
  (proszę zwrócić uwagę na wielkość liter). W~języku C fałsz reprezentuj
  liczba całkowita równa $0$, prawdą jest każda inna liczba całkowita.
  Domyślnie w~języku~C, prawdę reprezentuje liczba~$1$.

  Należy pamiętać, że~to iż prawdę w~języku~C reprezentuje liczba~$1$,
  to \alert{nie} jest własność języka~C, ale umowa między programistami.
  Niemniej tej umowy \alert{absolutnie} nie wolno łamać, jeśli komuś
  jest drogie zdrowie i~życie.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  W~języku~C można również korzystać z~protezy typu boolowskiego jaką daje
  nam \texttt{stdbool.h}. W~języku C++ sytuacja jest w~zasadzie taka sama
  jak w~języku~C++.

  Spróbujemy teraz wyjaśnić intuicyjny sens algebry Boole’a, wychodząc
  od pojęcia \textbf{zdania logicznego}. Zdaniem logicznym nazywamy
  dowolne stwierdzenie, któremu możemy przypisać wartość logicznej prawdy
  lub fałszu. Zdaniami takimi mogą być „Jan jest na mieście.”, „Jan je
  kanapkę.”, czy znane nam już z~języka~C wyrażenia takie jak
  „\texttt{intVar1 == 5}”, „\texttt{intVar1 < 3}”,
  „\texttt{intVar1 > -4}”,~etc. Zdania „Gra \textit{Nine Sols} jest
  lepsza, niż \textit{Hollow Knight}.”, czy „Teodor Parnicki jest
  lepszym pisarzem niż Sienkiewicz.”, nie zaliczymy do zdań logicznych,
  bo~nie jest wcale jasne, czy są one prawdziwe czy nie.

  Podstawową cechą algebry Boole’a jest możliwość łączenia zdań logicznych
  w~większe zdania logiczne. Zademonstrujemy to na przykładzie łącznika
  zdań~„i”.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  Weźmy zdania „Jan jest na mieście.” oraz „Jan je kanapkę.”. Z~pomocą
  łącznika „i” możemy teraz utworzyć nowe zdanie \\
  „Jan jest na mieście i~Jan je kanapkę.” \\
  Kiedy to zdanie jest prawdziwe? Przyjmujemy, że~jest ono prawdziwe
  tylko wtedy, gdy jednocześnie jest prawdą, że~Jan jest na mieści, jak
  i~to, że~je kanapkę. W~każdym innym przypadku zdanie to uważamy, za
  fałszywe. Czyli zdanie to jest fałszywe, jeśli Jan jest na mieście,
  ale nie je kanapki. Jak również wtedy, gdy Jan je kanapkę siedząc w~domu
  oraz gdy ja siedzi w~domu i~niczego nie je.

  Takie rozumienie łącznika „i”~jest zgodne ze znaczeniem, jakie ten wyraz
  często posiada w~języku polskim i~innych językach. Musimy podkreślić,
  że~w~algebrze Boole’a łącznik „i”~ma proste znaczenie. Tworzy z~dwóch
  zdań jedno i~to zdanie wynikowe jest prawdziwe, tylko wtedy, gdy oba
  zdania składowa są prawdziwe.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  To, że~w~języku polskim słowo~„i” może występować w~innych znaczeniach,
  wychodzi poza interesujący nas temat. Przykładowo „i”~ma inny sens
  w~zdaniu „Weź mleko i~jajka i~mąkę.”, niż ten który właśnie omówiliśmy.
  Jednak dla nas, jako dla informatyków, interesujące jest nie badanie
  takich zawiłości języków naturalnych, lecz pewna bardzo konkretne
  procedury rachunkowe. To mamy nadzieję zaraz stanie~się bardziej
  zrozumiałe wraz z~przykładami.

  Przez „język naturalny” rozumiemy język taki jak angielski, francuski,
  hiszpański,~etc., których ludzie używają do komunikacji między sobą.

  Aby podkreślić, że~używamy słowa „i” w~tym konkretnym znaczeniu,
  zamiast „i” będziemy pisać „\texttt{\&\&}”. Ten dziwaczny wybór
  jest podyktowany tym, że~w~języku~C, jak i~większości innych języków,
  spójnik „i” oznacza~się właśnie tym symbolem. Będziemy więc pisać \\
  „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.”

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Intuicyjny sens algebry Boole’a}


  „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.” \\
  Może ten zapis wygląda dziwnie, ale informatycy są do niego
  przyzwyczajeni i~w~takiej czy innej formie jest powszechnie stosowany.
  Z~czasem dla Państwa też stanie~się on bardzo naturalny.

  Z~punktu widzenia języka polskiego zdanie \\
  „Jan jest na mieście \texttt{\&\&}~Jan je kanapkę.” \\
  zapisalibyśmy raczej jako \\
  „Jan jest na mieście \texttt{\&\&}~je kanapkę.” \\
  Zdecydowaliśmy~się na tą bardziej osobliwą formę, by uwypuklić rachunkową
  stronę tego zagadnienia.

  By użyć bardziej informatycznego przykładu, zdanie \\
  \texttt{(intVar1 < 3) \&\& (-5 < intVar1)} \\
  oznacza, że~wartość przechowywana przez zmienną \texttt{intVar1}
  spełnia nierówność \texttt{-5 < intVar1 < 3}. Jeśli to nie jest jasne,
  to proszę~się nad tym chwilę zastanowić. Ewentualnie poprosić o~dalsze
  wyjaśnienia.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zastosowanie w~programowaniu}


  Znaczenie algebry Boole’a dla informatyki polega na tym, że~teraz
  możemy napisać choćby następujący kod. Jego pełną wersję można
  znaleźć w~materiałach do nauki, w~pliku o~nazwie \\
  \texttt{PI-04-E-Przykład-wykorzystania-iloczynu-logicznego.c}.

  \vspace{1em}



  \texttt{if ((intVar1 < 3) \&\& (-5 < intVar1)) \{ } \\
  \hphantom{\texttt{aaaa}} \texttt{printf("Wartość zmiennej intVar1
    zawiera~się "} \\
  \hphantom{\texttt{aaaaaaaaaaa}}
  \texttt{"w pożądanym zakresie.\textbackslash n");} \\
  \texttt{ \} else \{ } \\
  \hphantom{\texttt{aaaa}} \texttt{printf("Wartość zmiennej intVar1
    znajduje~się poza "}
  \\
  \hphantom{\texttt{aaaaaaaaaaa}} \texttt{"pożądany
    zakres.\textbackslash n");} \\
  \texttt{ \} }

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pewna osobliwości algebry Boole’a}


  Musimy wskazać na pewną osobliwość spójnika \texttt{\&\&} i~samej
  algebry Boole’a. Rozpatrzmy zdanie \\
  „Jan je kanapkę \texttt{\&\&} Paryż jest stolicą Francji.” \\
  Zdanie to jest prawdziwe, jeśli oba tworzące go zdania są prawdziwe.
  Jednak łatwo zauważyć, że~nie ma żadnego związku między tym, że~Jan
  je kanapkę, a~tym czy dane miasto jest stolicą Francji, co może~się
  wydawać nienaturalne.

  Gdy łączymy dwa zdania za pomocą łącznika \texttt{\&\&} to o~prawdziwości
  nowo powstałego zdania decyduje tylko prawdziwość lub~fałszywość zdań
  składowych, \alert{nie} ich treść. Z~tego powodu, to czy treść
  dwóch zdań składowych jest ze sobą powiązana, czy nie, nie ma dla nas
  w~tym kontekście znaczenia. Jest to świadomy wybór, który ma duże
  znaczenie z~punktu widzenia informatyki. Redukuje on sprawdzenie
  prawdziwość nowego zdania do prostego rachunku, a~w~rachunkach
  komputery są bardzo dobre.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Rachunkowa strona algebry Boole’a}


  Jest to ważne bo komputery mają naprawdę duże problemy z~operowaniem
  na treściach zdań. Przykładowo, jeśli mamy zdanie „Paryż jest stolicą
  Francji.”, to język~C nie posiada narzędzi, które pozwalałby ustalić, czy
  to zdanie dotyczy osoby, mebla, czy miasta. Jeśli jednak C wie, że~to
  zdanie jest prawdziwe, to cała reszta redukuje~się do rachunków,
  w~których~C jest bardzo dobry.

  Spójrzmy na to od innej strony. Oznaczmy przez \texttt{zdanie1} zdanie
  „Jan je kanapkę.”, zaś przez \texttt{zdanie2} „Paryż jest stolicą
  Francji.”. Zdanie \\
  „Jan je kanapkę \texttt{\&\&} Paryż jest stolicą Francji.” \\
  możemy teraz zapisać jako \\
  \texttt{zdanie1 \&\& zdanie2} \\
  Jeśli to zdanie jest prawdziwe to piszemy \\
  \texttt{zdanie1 \&\& zdanie2 == true} \\
  Jeśli zaś jest fałszywe to piszemy \\
  \texttt{zdanie1 \&\& zdanie2 == false}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Rachunkowa strona algebry Boole’a}


  Fakt, że~połączenie dwóch zdań prawdziwych za pomocą \texttt{\&\&}
  daje zdanie prawdziwe, zapisujemy jako \\
  \texttt{true \&\& true == true}

  Obecnie wszystkie własności rachunkowe łącznika \texttt{\&\&}
  możemy zapisać w~prostej tabeli.

  \vspace{1em}



  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    \texttt{zdanie1} & \texttt{zdanie2} & \texttt{zdanie1 \&\& zdanie2} \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Podsumowanie}


  Na koniec musimy wspomnieć, że~w~języku~C symbole „\texttt{\&\&}”
  i~„\texttt{\&}” oznaczają radykalnie \alert{różne} rzeczy. Bo czemu życie
  miałoby być proste? Operator \texttt{\&} służy do operowania na niskim
  poziomie abstrakcji (czytaj: na poziomie, gdzie wszystko wygląda jak ciągi
  $0$ i~$1$) i~z~tego powodu, jego zrozumienie wymaga sporo pracy.
  Omówimy go, jeśli będziemy mieli odpowiednio dużo czasu.

  Na razie proszę zapamiętać, że~można używać \texttt{\&\&}, ale kto
  używa~\texttt{\&}, robi to na własną odpowiedzialność.

  Na tym zakończymy nasze intuicyjne wprowadzenie do algebr Boole’a
  i~przejdziemy do bardziej technicznego ich omówienia. Jeśli Państwo
  uważają, że~to intuicyjne omówienie nie jest satysfakcjonujące to
  proszę do nas napisać \email.

\end{frame}
% ##################










% ######################################
\section{Podstawy algebry Boole’a}
% ######################################


% ##################
\begin{frame}
  \frametitle{Zmienne boolowskie}


  Pojęcia logicznej prawdy i~fałszu zostały już omówione i~nie będziemy
  ich szerzej dyskutować, gdyż jest to bardziej przedmiotem filozofii, niż
  informatyki. A~tematów dotyczących informatyki na tym kursie mamy już
  wystarczająco dużo.

  W~informatyce oprócz wartości logicznych \texttt{true} i~\texttt{false}
  dużą rolę odgrywają \textbf{zmienne boolowskimi}, zwane też
  \textbf{zmiennymi logicznymi}. Są~to zmienne które mogą przechowywać
  wartości logiczne \texttt{true} i~\texttt{false}. Tak jak w~przypadku
  sposobu reprezentowania wartości logicznych, również gdy chodzi
  o~zmienne, sposób ich działania zależy w~dużej mierze od używanego języka.

  Wyjątkowo zaczniemy od przytoczenia przykładu z~języka Go, gdyż pozwala
  on pracować na wartościach i~zmiennych boolowskich w~dużo prostszy
  i~bezpieczniejszy sposób, niż język~C.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zmienne boolowskie w~Go}


  Poniżej prezentujemy przykładowy fragment programu napisanego w~języku~Go
  operujący na zmiennych logicznych. Symbol „\texttt{//}” oznacza, że~tekst
  na prawo od niego jest komentarzem dla człowieka i~jest zupełnie
  ignorowany przez komputer.

  \textit{Uwaga.} To jest tylko fragment programu w~języku~Go i~ze względu
  na brakujące części nie da~się go uruchomić. Pełna jego wersja
  znajduje~się w~pliku \texttt{PI-05-A-Zmienne-boolowskie-w-Go.go}.

  \texttt{// Tworzymy zmienną logiczną „boolVar1” i~nadajemy jej} \\
  \texttt{// wartość „false”.} \\
  \texttt{var boolVar1 bool = false} \\
  \vspace{0.8em}
  \texttt{// Zmieniamy wartość logiczną zmiennej „boolVar1” na „true”.} \\
  \texttt{boolVar1 = true}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zmienne boolowskie w~C}


  Rozpatrzmy przypadek języka~C. Ponieważ wartości logiczne reprezentują
  w~nim liczby całkowite, więc jako zmiennej logicznej możemy użyć dowolnej
  zmiennej która przechowuje wartości całkowitoliczbowe. Zmienne tego typu
  w~języku~C są zwykle typu \texttt{int}. Bo czemu życie miałoby być proste?

  Omówienie tych pseudoboolwskich zmiennych w~języku~C znajduje~się
  w~plikach \texttt{PI-05-B-Zmienne-pseudoboolowskie-w-C.c} \\
  i~\texttt{PI-05-C-stdbool-h.c}.

  \textbf{Wyrażeniem boolowskim} (ang.~\textit{boolean expression}) zwane
  też \textbf{wyrażeniem logicznym} (ang.~\textit{logical expression})
  to dowolne wyrażenie w~wyniku obliczenia którego zostaje zwrócona
  wartość boolowska \texttt{true} albo \texttt{false}. Wyrażenie boolowskie
  jest w~zasadzie bardziej informatyczną nazwą dla „zdania logicznego”,
  warto jednak znać oba te terminy. Na~potrzeby naszego kursu jest
  to wystarczające.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Operatory boolowskie}


  Przypomnijmy, że~wyrażeniem jest tylko i~wyłącznie taka instrukcja, która
  \textit{zwraca} pewną wartość. W~przeciwnym razie mamy do czynienia
  z~\textbf{orzeczeniem} (ang. \textit{statement}).

  Przyjmujemy, że~wartości boolowskie \texttt{true} i~\texttt{false},
  również są wyrażeniami, które zwracają jako swoją wartość same siebie.
  Nawet jeśli takie podejście wydaje~się to dziwne i~przekombinowane, to
  taki sposób myślenia ma swoje zastosowania w~informatyce.

  \textbf{Operatorem boolowskim} (ang.~\textit{boolean operator}) lub
  \textbf{operatorem logicznym} (ang.~\textit{logical operator})
  nazywamy operator, która łączy dwa wyrażenia boolowskie tworząc jedno
  nowe wyrażenie tego typu. Cztery podstawowe z~punktu widzenia informatyki
  operatory boolowskie to: iloczyn logiczny, suma logiczna, negacja logiczna
  i~operator porównania. I~tutaj widzimy, że~„operator boolowski” to
  w~zasadzie inna nazwa na „łącznik zdań”.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Iloczyn logiczny}


  \textbf{Iloczyn logiczny}, zwany też \textbf{koniunkcją logiczną},
  to operacja której dyskusje niedawno zakończyliśmy i~który oznaczamy
  symbolem~„\texttt{\&\&}”. Poniższa przypomnimy tabelę własności
  tego operatora.

  \vspace{1em}



  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    \texttt{zdanie1} & \texttt{zdanie2} & \texttt{zdanie1 \&\& zdanie2} \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Suma logiczna}


  \textbf{Suma logiczna}, zwana też \textbf{alternatywą logiczną} odpowiada
  mniej więcej temu, co w~języku polskim oznacza spójnik „lub”. Łączy ona
  dwa wyrażenia boolowskie dając nowe wyrażenie, która wartość \texttt{true}
  jeśli wartość pierwszego \alert{lub} drugiego jest równa \texttt{true}.

  Podobnie jak dla iloczynu logicznego, język C i~za nim większość
  najpopularniejszy języków programowania oznacza sumę logiczną symbolem
  „\texttt{||}”. Własności tego operatora podsumowuje podana poniżej tabela.

  \vspace{1em}



  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    \texttt{zdanie1} & \texttt{zdanie2}
    & \texttt{zdanie1 || zdanie2} \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{true}  \\
    \texttt{false} & \texttt{true}  & \texttt{true}  \\
    \texttt{false} & \texttt{false} & \texttt{false} \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Suma logiczna}


  Państwo powinni pamiętać, że~„\texttt{\&\&}” to iloczyn logiczny,
  a~„\texttt{\&}” to coś zupełnie innego. Ponieważ życie nie może być
  proste, więc tak jak „\texttt{||}” oznacza sumę logiczną, tak „\texttt{|}”
  oznacza coś zupełnie innego. Co oznacza ten osobny symbol, powiem jeśli
  będziemy mieli wystarczająco dużo czasu.

  Intuicyjny sens sumy logicznej moglibyśmy przeanalizować w~ten sam
  sposób, co w~przypadku iloczynu logicznego, mamy jednak nadzieję,
  że~nie jest to potrzebne. Jeśli Państwo chcą by taka analiza~się tu
  znalazła, proszę napisać pod adres~\email.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Negacja logiczna}


  \textbf{Negacja logiczna} odpowiada w~przybliżeniu co polskie słowo „nie”.
  Negacja prawdy logicznej jest fałszem, a~negacja fałszu jest prawdą.

  Przedtem pisaliśmy, że~operator to coś co pobiera dwie wartości i~na
  podstawie ich oblicza wynik. Negacja stanowi wyjątek od tej reguły,
  bo pobiera tylko jedną wartość i~na jej podstawie zwraca wynik. Mówimy,
  że~negacja jest \textbf{operatorem jednoargumentowym}.

  W~językach programowania negację danego wyrażenia \texttt{zdanie1}, zwykle
  oznacza~się poprzez poprzedzenie go symbolem~„\texttt{!}”, co daje
  \texttt{!zdanie1}, i~my też będziemy korzystać z~tego zapisu.

  Własności negacji logicznej podsumowuje poniższa tabelka.

  \vspace{1em}



  \begingroup

  \centering

  \begin{tabular}{|c|c|}
    \hline
    \texttt{zdanie1} & \texttt{!zdanie1} \\
    \hline
    \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{true}  \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Operator porównania}


  \textbf{Porównanie logiczne} jest prawdą, wtedy i~tylko wtedy, gdy obie
  porównywane strony mają tą samą wartość logiczną. Operator porównania
  w~języku~C i~większości innych języków to „\texttt{==}”. Jego własności
  podsumowuje poniższa tabela.

  \vspace{1em}



  \begingroup

  \centering

  \begin{tabular}{|c|c|c|}
    \hline
    \texttt{boolVar1} & \texttt{boolVar2}
    & \texttt{boolVar1 == boolVar2} \\
    \hline
    \texttt{true}  & \texttt{true}  & \texttt{true}  \\
    \texttt{true}  & \texttt{false} & \texttt{false} \\
    \texttt{false} & \texttt{true}  & \texttt{false} \\
    \texttt{false} & \texttt{false} & \texttt{true}  \\
    \hline
  \end{tabular}

  \endgroup

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Operator porównania}


  W~większości języków programowania „\texttt{==}” służy nie tylko do
  porównywania wyrażeń boolowskich, ale do porównywania wszystkich
  obiektów, których wartości można porównywać. Dwie wartości połączone tym
  operatorem już tworzą wyrażenie boolowskie.

  Przykładowo, w~języku C, Go czy w~Pythonie można za~jego pomocą
  porównywać liczby zmiennoprzecinkowe, tworząc odpowiednie wyrażenia
  boolowskie. Tym samym \\
  \texttt{0.5 == 1.5} \\
  jest w~tych językach wyrażeniem boolowskim, którego wartość logiczna jest
  równa \texttt{false}. Proszę pamiętać, że~w~każdym z~tych języków
  wartości logiczne są trochę inaczej reprezentowane.

  Te subtelności nie powinny jednak stanowić problemu w~zrozumieniu
  działania tego operatora.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Porównanie logiczne}


  Należy zwrócić uwagę, że~operator „\texttt{==}” zwykle sprawdza równość
  \alert{wartość} wyrażeń, nie ich \alert{identyczność}. Przykładowo,
  załóżmy, że~mamy dwie zmienne typu \texttt{int} w~języku~C, niech~się
  nazywają \texttt{intVar1} i~\texttt{intVar2}. Każda z~nich zawiera pewną
  wartość i~możemy~się pytać o~równość tych wartości. Możemy~się też
  zapytać, czy obie zmienne zajmują ten sam obszar pamięci (choćby pamięci
  \textsc{ram}), wtedy pytamy~się o~ich identyczność.

  Tym samym w~języku~C wyrażenie \\
  \texttt{intVar1 == intVar2} \\
  sprawdza, czy \alert{wartość} przechowywane przez obie te zmienne są
  równe, nie czy te zmienne są identyczne. Powtórzymy, identyczność
  zmiennych oznacza, że~są one po prostu dwiema różnymi nazwami na~to~samo
  (ten sam obszar pamięci). Czy tego typu subtelności mają jakiekolwiek
  praktyczne znaczenie? Niestety, niekiedy mają.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Bibliografia dla zainteresowanych}


  Temat rachunku zdań to w~zasadzie studnia bez dna, a~my możemy na tym
  kursie omówić tylko kilka jej najważniejszych i~najbardziej podstawowych
  elementów. Osoby zainteresowane głębszym wniknięciem w~tą tematykę, mogą
  sięgnąć po jedną z~poniższych pozycji lub jedną z~innych setek ksiązek
  w~tym temacie.

  \begin{itemize}

  \item Andrzej Grzegorczyk \textit{Zarys logiki matematycznej}
    \parencite{Grzegorczyk-Zarys-logiki-matematycznej-Pub-1975}.

  \item Willard von Ormian Quine \textit{Logika matematyczna}
    \parencite{Quine-Logika-matematyczna-Pub-1974}.

  \item Zdzisław Kraszewski \textit{Logika. Nauka rozumowania}
    \parencite{Kraszewski-Logika-Pub-1984}.

  \end{itemize}

\end{frame}
% ##################










% ######################################
\section{Terminologia i~notacja dla algebry Boole’a}
% ######################################


% ##################
\begin{frame}
  \frametitle{Kim był Boole?}


  \begin{figure}

    \centering


    \includegraphics[scale=0.195]
    {./Presentations-pictures/George-Boole.jpeg}

    \caption{George Boole (1815--1864), brytyjski matematyk i~filozof.
      Wprowadził metody algebraiczne do logiki, zaś \textbf{algebra Boole’a}
      została nazwana na jego cześć.}

    \label{fig:George-Boole}

  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Notacja dla operatorów logicznych}


  Dla porządku warto przytoczyć różne oznaczenia, jakie używamy do zapisu
  operatorów logicznych.

  W~informatyce standardowe oznaczenie na iloczyn logiczny to
  „\texttt{\&\&}”. Język Python używa angielskiego słowa „\texttt{and}”
  i~to pomimo tego, że~zaprojektował go
  \colorhref{https://pl.wikipedia.org/wiki/Guido\_van\_Rossum}{Holender}.
  W~matematyce często zapisuję ją za pomocą symbolu~„$\wedge$”.

  Standardowe oznaczenie dla sumy logicznej to „\texttt{||}”. W~Pythonie
  operator ten oznacza słowo „\texttt{or}”. W~matematyce często stosuje~się
  symbol~„$\vee$”.

  Negacja logiczna zwykle oznaczana jest symbolem~„\texttt{!}”.
  W~matematyce często stosuje~się symbol „\texttt{$\neg$}”, jak
  w~\texttt{$\neg$zdanie1}.

  Warto zwrócić uwagę, że~operator „różności” to~„\texttt{!=}” właśnie
  z~powodu tego znaczenia symbolu „\texttt{!}”. Dlaczego jednak nie wybrano
  dla niego symbolu „\texttt{!==}”? Pewnie, by nie pisać za dużo znaków.

\end{frame}
% ##################










% ######################################
\section{Typy zmiennych}
% ######################################


% ##################
\begin{frame}
  \frametitle{Czym są typy zmiennych?}


  Widzieliśmy już kilka typów zmiennych, takich jak liczby całkowite
  i~liczby zmiennoprzecinkowe: \\
  \texttt{int intVar1 = 0;} \\
  \texttt{int float64Var1 = 0.0;} \\
  Czym jednak dokładniej jest typ zmiennej? To wbrew pozorom jest bardzo
  głęboki problem, który pojawił~się w~rozważaniach
  filozoficzno-matematycznych kilka dekad wcześniej, nim ludzkość
  skonstruowała pierwszy komputer z~prawdziwego zdarzenia. Powinno być
  oczywiste, że~na takim przedmiocie jak \textit{Podstawy informatyki}
  możemy omówić ten temat tylko na intuicyjnym poziomie.

  Dzisiejsze komputery buduje~się w~ten sposób, że~najmniejszą porcją
  pamięci jakiej możemy używać jest jeden bajt, czyli $8$~bitów. Techniczny
  termin na taką najmniejszą jednostkę pamięci nazywamy
  \textbf{słowem} (ang.~\textit{word}).

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Abstrakcja w~informatyce}


  Historycznie istniały komputery, których najmniejszą jednostką było
  powiedzmy $6$~bitów, ale to nie są zajęcia z~historii informatyki.

  Moglibyśmy korzystać komputera operując tylko na bajtach jako takich,
  ale byłaby to męka nie do pojęcia. Jeśli ktoś z~Państwa pisał kiedyś
  w~jakimś dialekcie assemblera, wie o~co chodzi.

  By to zilustrować, proszę sobie wyobrazić, że~zamiast zdjęciem na dysku,
  musimy operować ręcznie na milionie~(!) bajtów które takie zdjęcie tworzą.
  Kopiowanie zdjęcia wyglądałoby wtedy mniej więcej tak. Weź bajty
  o~numerach od $1 \, 555 \, 000$ do $2 \, 554 \, 999$ i~skopiuj
  zawartość każdego z~nich do bajtów o~numerach $11 \, 000 \, 073$
  do~$12 \, 000 \, 072$. Koszmar na~jawie!

  By tego uniknąć wprowadzamy coś, co w~informatyce określamy terminem
  \textbf{abstrakcja}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Abstrakcja w~informatyce}


  Zdjęcie na komputerze to pewna abstrakcja, która zwalnia nas z~myślenia
  o~nim jako o~milionie bajtów, które tworzą to zdjęcie na~dysku. Inny
  przykładem tego typu zachowania jest to, że zamiast mówić „To jest
  zwierzę, które jest ssakiem, ma cztery nogi, ogon, futro, jest
  drapieżnikiem,\ldots” powiemy „To jest pies.”. Takie dzielenie rzeczy na różne
  kategorie i~operowanie tak wprowadzonymi kategoriami okazuje~się być
  bardzo wygodne nie tylko w~informatyce. Mamy nadzieję, że~takie
  wyjaśnienie koncepcji abstrakcji w~informatyce jest dla Państwa
  wystarczająca.

  Typy zmiennych istnieją z~tego samego powodu. Zamiast myśleć „Tu mam
  cztery bajty.”, prościej jest myśleć „Tu mam liczbę całkowitą”. Poza tym,
  typy zmiennych pozwalają komputerowi lepiej kontrolować działanie
  programów, lecz to jest jednak temat rzeka, zbyt obszerny na ramy tego
  przedmiotu, pozostaniemy więc na poziomie kilku ogólnych uwag.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pożytek z~typów}


  Rozpatrzmy następujący, mocno uproszczony przykład. Powiedzmy, że~używamy
  dwóch rodzajów plików: graficznych oraz tekstowych. Dzięki typom, nasz
  program może rozpoznać, że~chcemy zapisać coś do~pliku graficznego, ale
  otwarliśmy plik tekstowy, więc zgłosi on błąd, co jest bardzo pożądanym
  zachowaniem. Jeśli Państwo jeszcze nie rozumieją dlaczego, to na tym
  przedmiocie napotkamy zapewne dostatecznie wiele przykładów, które
  pokażą, czemu otrzymywanie błędów to dobra rzecz.

  Należy też dodać, że~w~różnych językach granica między typami jest mniej
  lub bardziej ostra. Przykładowo, czy w~miejscu, gdzie program oczekuje
  liczby zmiennoprzecinkowej, mogę użyć liczby całkowitej~$1$? Wedle
  niektórych języków, tak, bo wszak wiadomo jak zamienić liczbę
  całkowitą~$1$ na liczbę zmiennoprzecinkową~$1.0$. Wedle innych języków,
  nie, bo~taka zmiana jednego typu liczbowego na drugi, może prowadzić do
  błędów numerycznych, których programista może nie być świadomy pisząc
  program.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Pożytek z~typów}


  W~tym drugim typie~;) języków, programista musi jawnie poprosić
  o~\textbf{konwersje typów}. Czyli musi napisać kod, który mówi coś
  w~stylu „Wiem, że~to jest liczba całkowita i~w~tym miejscu masz
  ją zamienić na liczbę zmiennoprzecinkową. Ja biorę odpowiedzialność
  za to co~się stanie.” O~konwersji typów powiem w~swoim czasie.

  Język~C stosuje podejście mieszane. Bo czemu życie miałoby być proste?
  Przykładowo, liczby całkowite zamienia na zmiennoprzecinkowe bez
  pytania~się programisty o~pozwolenie, przy innych typach musimy~się sami
  napracować. Wolelibyśmy uniknąć szczegółowej dyskusji tego typu zagadnień,
  gdyż są ważniejsze rzeczy, którym należy poświęcić czas na~przedmiocie
  \textit{Podstawy informatyki}.

\end{frame}
% ##################










% ######################################
\appendix
% ######################################





% ######################################
\EndingSlide{Dziękujemy! Pytania?}
% ######################################









% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ############################
% End of the document

\end{document}
