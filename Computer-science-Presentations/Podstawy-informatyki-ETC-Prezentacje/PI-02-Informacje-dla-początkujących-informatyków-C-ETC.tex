% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located in
% the directory "preambule"
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/ImportingLocalPackages.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Podstawy-informatyki-ETC-Bibliography.bib}





% ------------------------------------------------------
% Importing packages, libraries and setting their configuration
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
\usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation
\usepackage{./Local-packages/local-settings}

% Styles for arrows
\usepackage{./Local-packages/PGF-TikZ-Arrows-styles}

% Styles for drawing diagrams
\usepackage{./Local-packages/PGF-TikZ-Diagram-styles}

% Jagiellonian theme's colros
\usepackage{./Local-packages/jagiellonian-theme-colors}










% ------------------------------------------------------------------------------------------------------------------
\title{Podstawy informatyki z~językiem~C}
\subtitle{Informacje dla początkujących programistów, etc.}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Number of chars: 62k+, 73k+, 43k+, 52k+, 69k+, 77k+, 32k+, 33k+, 62k+,
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Charakter tych zajęć}


  Niekiedy wejdziemy w~pewne zagadnienia teoretyczne, bo~są sytuacje, gdy
  niewiedza teoretyczna powoduje poważne problemy praktyczne. Jeśli ktoś
  nie wie, że~proch strzelniczy wybucha pod wpływem temperatury, to może
  nieopatrznie postawić pudełko naboi koło gorącego pieca. W~informatyce
  też zdarzają~się takie sytuacje, gdy brak wiedzy teoretycznej jest zbyt
  groźny, by można było pominąć dyskusję danego problemu.

  Jako kwestie praktyczne traktujemy też dobre praktyki programisty.
  Czyli jeśli nawet dany kod działa, ale w~dłuższej perspektywie może
  sprawiać problemy, to będziemy naciskali na jego zmianę. Wbrew
  pozorom~są to bardzo praktyczne sprawy.

  Proszę jednak pamiętać, że~ze względu na to treść tego kursu jest wysoce
  selektywna. O~wielu rzeczach z~premedytacją nie powiemy, uznając je
  za~zbyt teoretyczne.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Charakter tych zajęć}


  Może~się Państwu wydawać, że~ilość zagadnień teoretycznych na tym kursie
  i~tak jest bardzo duża. To zależy w~sporej mierze od perspektywy,
  bo~naprawdę wiele zagadnień teoretycznych zdecydowaliśmy~się pominąć.

  Jeśli oczywiście ktoś chce~się zagłębić w~te bardziej teoretyczne
  zagadnienia, to oczywiście służymy całą naszą wiedzą. Można
  nas o~to pytać po zajęciach i~pisać na e-maila \email.
  Prosimy takim e-mailom nadawać tytuły typu „Pytanie o~X”, tak by nie
  zaginęły one wśród kilkudziesięciu innych e-maili jakie zwykle dostajemy
  każdego miesiąca.

\end{frame}
% ##################










% ######################################
\section{Informacje dla początkujących programistów}
% ######################################



% ##################
\begin{frame}
  \frametitle{O~nazwach plików}


    \textit{Programowanie to radzenie sobie ze złożonością: złożoność
    problemu, który chcemy rozwiązać, potęguje złożoność maszyny, na które
    pracujemy. Właśnie z~uwagi na złożoność większość projektów kończy~się
    niepowodzeniem.} Bruce Eckel
  str.~$22$ \parencite{Eckel-Thinnking-in-Java-Ed-polska-Wyd-III-Pub-2003}.

  Powtórzmy kilka rzeczy. Rozszerzenie pliku, kropka i~to co następuje po
  niej w~nazwie tego pliku, informuje używane przez nas programy z~jakim
  typem pliku mają do czynienia. Dlatego każdy język programowania posiada
  własne, właściwe tylko jemu rozszerzenie. Pliki napisane w~języku~C mają
  mieć rozszerzenie~\texttt{.c}. Analogicznie, każdy program w~języku Python
  powinien~się kończyć na~\texttt{.py}, pliki w~języku C++ \texttt{.cpp},
  w~\textsc{bash}u \texttt{.sh},~etc.

  Nadanie plikowi nazwy bez rozszerzenia to nie jest dobry pomysł. Nazwa
  zawierająca spacje to proszenie~się o~problem, gdy pracujemy w~systemie
  GNU/Linux (\textsc{bash} i~inne sprawy). Nazwa pliku która zawiera
  dwie lub więcej kropek to wymysł Szatana i~wytwór piekieł. Proszę mi
  oszczędzić styczności z~tymi plugawymi tworami.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Rozszerzenia plików}


  Jak ktoś na zajęciach napisze program w~języku~C, który \alert{nie} ma
  rozszerzenia~\texttt{.c}, będzie to musiał przy mnie poprawić.
  Chyba, że~będę musiał od razu biec do kogoś innego. Ale proszę nie
  liczyć, że~zapomnę o~tej zniewadze. ;)

  Brak tego rozszerzenia sprawia, że~możemy zostać pozbawienie części
  wsparcia w~pracy z~C, jaką dają nam przeróżne programy. A~do tego
  \alert{nie} możemy dopuścić.

  Załóżmy, że~ktoś wymyśli taką szatańską nazwę \\
  \texttt{plik-numer.1.c} \\
  co jest absolutnym plugastwem. Programy których używamy mogą błędnie
  rozpoznać „\texttt{.1.c}” jako rozszerzenie pliku i~wtedy demony mają
  prawa wylecieć nam
  \colorhref{http://www.catb.org/jargon/html/N/nasal-demons.html}{z~nosa}.

  % Jak ktoś na zajęciach napisze program w~języku~C, który \alert{nie} ma
  % rozszerzenia~\texttt{.c}, będzie to musiał przy mnie poprawić.
  % Chyba, że~będę musiał od razu biec do kogoś innego. Ale proszę nie
  % liczyć, że~zapomnę o~tej zniewadze. ;)

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Plugawe nazwy plików}


  W~nazwie pliku powinna być \alert{jedna i~tylko jedna kropka}, ta
  poprzedzająca nazwę rozszerzenia pliku, czyli dla nas \texttt{.c}.
  Jeśli ta zasada nie jest prawdą wszędzie na świecie, to na pewno jest
  prawdą na tych zajęciach i~proszę o~tym pamiętać.

  Jeśli ktoś prześle mi plik, którego nazwa zawiera więcej lub mniej niż
  \alert{jedną} kropkę, to zastrzegam sobie prawo odesłania mu pliku
  z~prośbą o~zmianę nazwy na~poprawniejszą. Dla mnie to nie jest sposób
  karania, tylko metoda wyrabiania w~ludziach dobrych nawyków.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Te zajęcia są prowadzone w~C, ale\ldots}


  Czy ja powinienem~się skupić na nauce języka~C? To bardzo dobre
  pytanie i~każdy z~Państwa powinien je sobie zadać.

  Każdy dobry informatyk powinien dobrze znać co najmniej jeden język
  programowania, acz niekoniecznie musi to być język~C. Zupełnie zrozumiałe
  jest, że~ktoś z~Państwa zdecyduje, iż~językiem który chce poznać jest
  jakiś inny język niż~C i~będzie~się uczył~C tylko tyle ile wymaga ten
  przedmiot. Co~więcej, w~naszej ocenie jest to bardzo dobre podejście do
  nauki.

  Jeśli nie wiedzą Państwo, na nauce którego języka należy~się teraz skupić,
  proponuję sprawdzić~$20$ najpopularniejszych języków programowania
  według indeksu
  \colorhref{https://www.tiobe.com/tiobe-index/}{\textsc{tiobe}},
  poczytać o~każdym z~nich i~wybrać ten który Państwo uważają za~najlepszy.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Te zajęcia są prowadzone w~C, ale\ldots}


  W~grudniu $2024$ roku indeks
  \colorhref{https://www.tiobe.com/tiobe-index/}{\textsc{tiobe}}
  przedstawia~się w~następujący sposób: Python, C++, Java, C, C\#,
  JavaScript, Go, \textsc{sql}, Visual Basic, Fortran, Delphi/Object
  Pascal, \textsc{php}, Scratch, Rust, \textsc{matlab}, R, język asemblera,
  Ruby, \textsc{cobol}, Swift.

  Decyzję o~tym na nauce którego języka~się Państwo skupią, muszą
  oczywiście podjąć Państwo sami. Jeśli ktoś chce uzyskać od nas jakieś
  wskazówki, to służymy całą swoją osobą. Jeśli chcą Państwo napisać emaila
  w~tej sprawie to proszę go nazwać „Pytanie o~wybór języka do nauki”, czy
  coś podobnego.

  Bardzo~się ucieszymy, jeśli ktoś z~Państwa zdecyduje~się skupić na
  języku~C, ale to w~żadnym razie nie jest wymagane. Nie o~to chodzi w~nauce
  informatyki.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Tak to wygląda}

  \vspace{-0.5em}


  \begin{figure}

    \label{fig:Learning-any-language-at-100-procent}

    \centering


    \includegraphics[scale=0.195]
    {./Presentations-pictures/Learning-language-at-100.jpg}

  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka rad praktycznych}


  Edytor \textsc{gnu} \colorhref{https://www.nano-editor.org/}{nano} to nie
  jest, w~mojej ocenie, dobry edytor dla osób początkujących. Zbyt dużo
  czasu tracimy na przełączaniu~się między nim, a~powłoką, zamiast na
  próbie zrozumienia jak należy pisać programy komputerowe. Jeśli ktoś jest
  już zaawansowany programistą~C (czy jakiegokolwiek innego języka) lub
  wyjątkowo lubi nano, to oczywiście, może i~powinien z~niego korzystać.
  Po prostu uważam, że~dla osób początkujących to~nie jest zbyt dobry wybór.

  Dla tych którzy nigdy wcześniej nie programowali polecam edytor
  \colorhref{https://gedit-text-editor.org/}{gedit}, gdyż jest prosty
  w~obsłudze i~nie trzeba go samemu ustawiać. Potem warto rozważyć użycie
  potężniejszej technologii.

  Gdy chodzi o~edytory to ja normalnie używam
  \colorhref{https://www.gnu.org/software/emacs/}{\textsc{gnu} Emacsa},
  który jest niezwykle fajny, ale ogromnie skomplikowany w~użyciu.
  Tak trudny, że~aby go dobrze opanować, trzeba~się nauczyć nowego języka
  programowania o~nazwie \colorhref
  {https://www.gnu.org/software/emacs/manual/html_node/eintr/}{Emacs Lisp}
  (w~skrócie: elisp). I~to wcale nie jest żart. Oprócz tego legendarny
  \colorhref{https://www.vim.org/}{vim} wciąż ma wierną rzeszę fanów.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka rad praktycznych}


  \colorhref{https://www.vim.org/}{Vima} warto znać, bo jest praktycznie
  wszędzie, gdzie jest system GNU/Linux, a~takich edytorów nie ma wiele.
  Trzeba jednak wiedzieć, że~jest on dość trudny w~obsłudze.

  Odkładając na bok edytory, warto zwrócić uwagę na zintegrowane środowiska
  programistyczne (\textsc{ide}, ang.~\textit{Integrated Development
    Environment}). Dla języków C i~C++ jest dedykowane \textsc{ide}
  \colorhref{https://www.jetbrains.com/clion/promo/}{CLion} od firmy
  \colorhref{https://www.jetbrains.com/}{JetBrains}, z~którego mogą Państwo
  korzystać dzięki licencji uczelnianej. Warto~się mu przyjrzeć, jeśli
  ktoś chce programować w~C z~wykorzystaniem \textsc{ide}.

  Wybór oczywiście pozostawiamy Państwu. Jeśli ktoś chce więcej porad
  od nas, to oczywiście służymy całą naszą wiedzą.

\end{frame}
% ##################










% ######################################
\section{Kilka rad odnośnie języka~C}
% ######################################


% ##################
\begin{frame}
  \frametitle{Kilka rad odnośnie języka~C}


  Jeśli chcesz użyć \texttt{\#define} zastanów~się, czy nie można
  tego zrobić korzystając z~\texttt{const}. Jeśli można, to skorzystaj
  z~\texttt{const}.

  Jeśli nie wiesz czy użyć \texttt{float} czy \texttt{double}, użyj
  \texttt{double}.

  Jeśli masz dobry powód by użyć \texttt{float}, użyj \texttt{float}.

  Jeśli nic Państwo z~tego nie rozumieją, to proszę~się nie martwić.
  Będziemy o~tym mówić w~trakcie tego kursu.

\end{frame}
% ##################










% ######################################
\section{Kilka informacji o~języku~C}
% ######################################



% ##################
\begin{frame}
  \frametitle{Jak długo~C jest z~nami?}


  Język~C został stworzony przez Dennis Ritchie ($1941\text{--}2011$), by
  ułatwić Kenowi Thompsonowi (ur.~$1943$), pracę nad systemem operacyjnym
  \textsc{unix}. Pierwsza jego wersja ukazała~się w~$1972$ roku.

  Język~C w $2025$ rok ma $53$ (!) lata. Jego wiek
  niestety często czuć, bo wiele funkcjonalności które dziś uważamy
  za~niezbędne w~pracy programisty albo są w~nim nieobecne, albo są,
  ale w~dość koślawej wersji. Niektórych rzeczy nie da~się w~sposób
  elegancki dodać do języka z~lat 70-tych XX wieku.

  Do tego język~C został pomyślany jako mały język, więc on z~premedytacją
  \alert{nie} wprowadził pewnych rzeczy znanych w~$1972$~roku. To
  niestety też nie ułatwia nam życia. Co gorsza, dla początkujących~C i~tak
  może sprawiać wrażenie ogromnego języka. On jest mały w~porównaniu
  z~innymi językami, ale to niewiele zmienia, gdy~się dopiera zaczyna swoją
  przygodę z~informatyką.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czy 1972 rok był dawno temu?}


    \begin{figure}

    \centering


    \includegraphics[scale=0.3]
    {./Presentations-pictures/Meeting-01/Dennis-Ritchie-Ken-Thompson-PDP-11.jpg}

    \caption{Dennis Ritchie (stojący) i~Ken Thompson pracują na komputerze
      PDP-11 firmy Digital Equipment Corporation.}

    \label{fig:Ritchie-Thompson-PDP-11}

  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Zalety języka~C}


  \begin{itemize}

  \item Pozwala tworzyć bardzo szybkie programy. \alert{Bardzo szybkie}
      programy.

  \item Jeśli poznamy~C, to nauka języka który na nim bazuje będzie
    już prostsza. A~60\%, albo więcej, najważniejszych języków jakie
    istnieją, w~jakimś stopniu bazuje na~C.

  \item Na świecie jest tyle kodu napisanego w~języku~C, że~jeśli umie~się
    go dobrze, można dość łatwo znaleźć naprawdę dobrze płatną pracę. I~na
    razie nic nie wskazuje, by ta praca zniknęła przez następne $20$ lat
    (do $2044$~roku). Chat\textsc{gpt} też nie.

  \item Pozwala lepiej poznać jak komputer działa na niskim poziomie.
    Zdania uczonych są podzielone, czy to jest wada czy zaleta. Ja
    ostatnio~się skłaniam do stwierdzenia, że~to jest zaleta, ale rozumiem,
    jeśli według Państwa mylę się~totalnie.

  \item Jawne zarządzanie wskaźnikami.

  \end{itemize}

\end{frame}
% ##################







% ##################
\begin{frame}
  \frametitle{Wady języka~C}


  \begin{itemize}

  \item Pisane w~C nie jest wcale proste.

  \item Wersji języka~C, różniących~się drugorzędnymi kwestiami, jest
    zbyt dużo i~łatwo~się w~tym pogubić.

  \item C~oferuje nam bardzo mało zabezpieczeń przed nami samymi, co
    skutkuje tym, że~bardzo łatwo stworzyć kod w~którym kryją~się
    koszmarnie niebezpieczne rzeczy. To jednak temat na inny przedmiot.

  \item Jawne zarządzanie wskaźnikami. Tak, to było też w~dziale
    \textit{Zalety języka~C}.

  \item Arytmetyka wskaźników. To relikt minionej epoki.

  \item Metody operowania na stringach. A~raczej brak takich metod.

  \item Wiele standardowych funkcji języka~C \alert{nie} powinno być
    używane. Powtarzam, wielu standardowych funkcji dostępnych w~języku~C
    \alert{nie należy} używać pod żadnym pozorem.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wady języka~C}


  \begin{itemize}

  \item Trudne do zapamiętania nazewnictwo. Czasem nazwy w~C są zwyczajnie
    głupie, jak \texttt{unsigned char} (pl.~\textit{znak bez znaku}) na
    oznaczenie pojedynczego bajtu.

  \item  Sama nazwa języka, „C”, też jest w~sumie dość głupia. Dzisiaj
    staramy~się nadawać im nazwy będące pełnymi słowami.

  \item Brak normalnego typu boolowskiego. Nawet \texttt{stdbool.h} nie
    rozwiązuje tego problemu.

  \item Domyślna konwersja typów. To naprawdę nie pasuje do takiego
    języka jak~C.

  \item Obsługa błędów. Jak obsługa błędów?

  \item Toporny i~niewygodny model kompilacji: pliki nagłówkowe,
    preprocesor, etc.

  \item „The more I~C, the less I see.” Przykład: złożone typy danych.

  % \item Brak modułowości.

  % \item I~miliona innych udogodnień, które daje ci dobry, nowoczesny język
  %   programowania (1972 rok był dawno temu).

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{The more I~C, the less I~see}


  Jak głosi mądrość internetu, języki~C nie jest trudny.

  \texttt{void (* (*f[])())()}

  Poprawna kod w~języku~C, który definiuje~\texttt{f} jako tablicę
  o~nieokreślonej długości, zawierającej wskaźniki do funkcji, które
  to funkcje zwracając wskaźniki do~funkcji, które to funkcje~są typu
  \texttt{void}.

  Taaaaak, nic trudnego.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wady języka~C}


  \begin{itemize}

  \item Brak modułowości.

  \item I~miliona innych udogodnień, które daje ci dobry, nowoczesny język
    programowania (rok $1972$ to było kawał czasu temu).

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jaki jest związek między C a~C++?}


  Taki jak między krzesłem, a~krzesłem elektrycznym. Bardzie trafne byłoby
  powiedzenie, że~jak, między mechaniką i~mechaniką kwantową, ale mniej
  osób rozumie tą różnicę.

  Mimo wszystko to są dwa bardzo różne języki programowania, które
  ze~względów historycznych mają pewnie wspólny rdzeń.

  Jeśli~C to taka skrzynka z~narzędziami, to C++ to cały Leroy
  Merlin. Naprawdę, ogarnięcie wszystkich featurów C++, jest zupełnie nie do
  ogarnięcia. A~przynajmniej ja w~możliwość tego osiągnięcia nie wierzę.
  Jak zapytałem osobą prowadzącą kurs C++, czy ktoś zna cały ten język
  to odpowiedziała „Podobno Bjarne Stroustrup [twórca C++]. Ale to tylko
  plotki.”

  Języki takie jak C\#, to zupełnie osobna sprawa.

\end{frame}
% ##################













% % ##################
% \begin{frame}
%   \frametitle{AI, ChatGPT,\ldots}


%   Żeby nie pozostać za bardzo w~tyle, staram~się wprowadzić do zajęć
%   praktyki związane z~korzystanie ze~sztucznej inteligencji. Niemniej
%   nawet taki gigant programowania jak Linus Torvalds (czyta się:
%   \textit{turwalds}),
%   \colorhref{https://www.youtube.com/watch?v=VHHT6W-N0ak}{zapytany na
%     przełomie} $2023$ i~$2024$ roku o~rolę \textsc{ai} w~praktyce
%   programisty, odpowiedział w~sposób, który zdradzał jego wątpliwości
%   na temat tego, jak to będzie działać w~praktyce.

%   Ja zaś~$5$ września $2024$ przeprowadziłem z~Chatem\textsc{gpt} taką
%   rozmowę.

%   \textsc{kz:} Czy w~$2024$ roku warto~się uczyć języka~C?

%   Chat\textsc{gtp:} Tak, uczenie~się C~w~roku $2024$ wciąż jest dobrym
%   pomysłem. Oto dlaczego.

%   \textbf{1.~Podstawy informatyki.} C~pozwala nam dogłębnie zrozumieć
%   architekturę komputera i~zarządzania pamięcią, które~są kluczowe
%   dla przyswojenia sobie bardziej abstrakcyjnych koncepcji z~programowania.

%   % \textbf{2.~Duża wydajność.} C~jest znany ze swej szybkości
%   % i~niskopoziomowego dostępu do sprzętu, czyniąc go idealny kandydatem
%   % do programowania systemów (np. systemów operacyjnych, systemów
%   % wbudowanych, etc.). Wciąż jest szeroko stosowany w~przemyśle lotniczym,
%   % samochodowym i~telekomunikacji, gdzie wydajność i~kontrola nad sprzętem
%   % są kluczowe.

% \end{frame}
% % ##################







% % ##################
% \begin{frame}
%   \frametitle{AI, ChatGPT,\ldots}


%   % Żeby nie pozostać za bardzo w~tyle, staram~się wprowadzić do zajęć
%   % praktyki związane z~korzystanie ze~sztucznej inteligencji. Niemniej
%   % nawet taki gigant programowania jak Linus Torvalds (czyta się:
%   % \textit{turwalds}),
%   % \colorhref{https://www.youtube.com/watch?v=VHHT6W-N0ak}{zapytany na
%   %   przełomie} $2023$ i~$2024$ roku o~rolę \textsc{ai} w~praktyce
%   % programisty, odpowiedział w~sposób, który zdradzał jego wątpliwości
%   % na temat tego, jak to będzie działać w~praktyce.

%   % Ja zaś~$5$ września $2024$ przeprowadziłem z~Chatem\textsc{gpt} taką
%   % rozmowę.

%   % \textsc{kz:} Czy w~$2024$ roku warto~się uczyć języka~C?

%   % Chat\textsc{gtp:} Tak, uczenie~się C~w~roku $2024$ wciąż jest dobrym
%   % pomysłem. Oto dlaczego.

%   % \textbf{1.~Podstawy informatyki.} C~pozwala nam dogłębnie zrozumieć
%   % architekturę komputera i~zarządzania pamięcią, które~są kluczowe
%   % dla przyswojenia sobie bardziej abstrakcyjnych koncepcji z~programowania.

%   \textbf{2.~Duża wydajność.} C~jest znany ze swej szybkości
%   i~niskopoziomowego dostępu do sprzętu, czyniąc go idealny kandydatem
%   do programowania systemów (np. systemów operacyjnych, systemów
%   wbudowanych, etc.). Wciąż jest szeroko stosowany w~przemyśle lotniczym,
%   samochodowym i~telekomunikacji, gdzie wydajność i~kontrola nad sprzętem
%   są kluczowe.



% \end{frame}
% % ##################





% % ##################
% \begin{frame}
%   \frametitle{AI, ChatGPT,\ldots}


%   Żeby nie pozostać za bardzo w~tyle, staram~się wprowadzić do zajęć
%   praktyki związane z~korzystanie ze~sztucznej inteligencji. Niemniej
%   nawet taki gigant programowania jak Linus Torvalds (czyta się:
%   \textit{turwalds}),
%   \colorhref{https://www.youtube.com/watch?v=VHHT6W-N0ak}{zapytany na
%     przełomie} $2023$ i~$2024$ roku o~rolę \textsc{ai} w~praktyce
%   programisty, odpowiedział w~sposób, który zdradzał jego wątpliwości
%   na temat tego, jak to będzie działać w~praktyce.

%   Ja zaś $5$ września $2024$ przeprowadziłem z~Chatem\textsc{gpt} taką
%   rozmowę.

%   \textsc{kz:} Czy w~$2024$ roku warto~się uczyć języka~C?

%   Chat\textsc{gtp:} Tak, uczenie~się C~w~roku $2024$ wciąż jest dobrym
%   pomysłem. Oto dlaczego.

%   \textbf{1.~Podstawy informatyki.} C~pozwala nam dogłębnie zrozumieć
%   architekturę komputera i~zarządzania pamięcią, które~są kluczowe
%   dla przyswojenia sobie bardziej abstrakcyjnych koncepcji z~programowania.

%   \textbf{2.~Duża wydajność.} C~jest znany ze swej szybkości
%   i~niskopoziomowego dostępu do sprzętu, czyniąc go idealny kandydatem
%   do programowania systemów (np. systemów operacyjnych, systemów
%   wbudowanych, etc.). Wciąż jest szeroko stosowany w~przemyśle lotniczym,
%   samochodowym i~telekomunikacji, gdzie wydajność i~kontrola nad sprzętem
%   są kluczowe.


% \end{frame}
% % ##################



% % ##################
% \begin{frame}
%   \frametitle{AI, ChatGPT,\ldots}


%   \textbf{\textsc{kz}:} Czy Chat\textsc{gpt} jest dobry w~generowaniu kodu
%   w~C?

%   \textbf{Chat\textsc{gpt}:} Chat\textsc{gpt} jest stosunkowo dobry
%   w~generowaniu kodu w~C, zwłaszcza gdy kod ten dotyczy typowych zadań
%   i~problemów. Jednak, jakość i~dokładność generowanego kodu może zależeć
%   od złożoności zadań i~dokładności przekazanych instrukcji. Tutaj
%   jest kilka czynników które należy rozważyć.

%   1.~\textbf{Składnia i~biblioteka standardowa.} Chat\textsc{gpt} potrafi
%   dobrze generować fragmenty kodu, które są zgodne ze~składnią~C oraz
%   odwołują do standardowych bibliotek. Na przykład, może pisać kod
%   dla podstawowych operacji, struktur kontrolnych i~przetwarzania danych,
%   jak również używać standardowych funkcji z~bibliotek takich jak
%   \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{string.h}, etc.

%   2.~\textbf{Powszechne schematy i~idiomy.} Potrafi rozpoznawać i~powielać
%   schemat obecne w~programach w~C, takie jak pętle dla iteracji,
%   \texttt{if-else} dla logiki warunkowej, czy \texttt{switch-case} dla
%   rozgałęzień. Potrafi również obsługiwać popularne idiomy~C, takie jak
%   używanie wskaźników, dynamiczna alokacja pamięci za pomocą \texttt{malloc}
%   i~\texttt{free} i~operacje bitowe.

%   % 3. \textbf{Rozumienie konstrukcji właściwych dla C.} Chat\textsc{gpt}
%   % zwykle dobrze sobie radzi z~konstrukcjami właściwymi dla języka C, takimi
%   % jak wskaźniki, struktury, unie, czy zarządzanie pamięcią. Potrafi również
%   % generować kod do obsługi plików \textsc{i/o}, zarządzania procesami
%   % poprzez funkcje \texttt{fork()} i~\texttt{exec()} oraz obsługujący
%   % podstawową komunikację między procesami (\textsc{ipc}, ang.
%   % \textit{Inter-Process Communication}), za pomocą takich mechanizmów jak
%   % rury (ang. \textit{pipes}) czy współdzielona pamięć.

% \end{frame}
% % ##################




% % ##################
% \begin{frame}
%   \frametitle{AI, ChatGPT,\ldots}


%   % 1.~\textbf{Składnia i~biblioteka standardowa.} Chat\textsc{gpt} potrafi
%   % dobrze generować fragmenty kodu, które są zgodne ze~składnią~C oraz
%   % odwołują do standardowych bibliotek. Na przykład, może pisać kod
%   % dla podstawowych operacji, struktur kontrolnych i~przetwarzania danych,
%   % jak również używać standardowych funkcji z~bibliotek takich jak
%   % \texttt{stdio.h}, \texttt{stdlib.h}, \texttt{string.h}, etc.

%   % 2.~\textbf{Powszechne schematy i~idiomy.} Potrafi rozpoznawać i~powielać
%   % schemat obecne w~programach w~C, takie jak pętle dla iteracji,
%   % \texttt{if-else} dla logiki warunkowej, czy \texttt{switch-case} dla
%   % rozgałęzień. Potrafi również obsługiwać popularne idiomy~C, takie jak
%   % używanie wskaźników, dynamiczna alokacja pamięci za pomocą \texttt{malloc}
%   % i~\texttt{free} i~operacje bitowe.

%   3. \textbf{Rozumienie konstrukcji właściwych dla C.} Chat\textsc{gpt}
%   zwykle dobrze sobie radzi z~konstrukcjami właściwymi dla języka C, takimi
%   jak wskaźniki, struktury, unie, czy zarządzanie pamięcią. Potrafi również
%   generować kod do obsługi plików \textsc{i/o}, zarządzania procesami
%   poprzez funkcje \texttt{fork()} i~\texttt{exec()} oraz obsługujący
%   podstawową komunikację między procesami (\textsc{ipc}, ang.
%   \textit{Inter-Process Communication}), za pomocą takich mechanizmów jak
%   rury (ang. \textit{pipes}) czy współdzielona pamięć.

%   4.~\textbf{Obsługa błędów.} Chat\textsc{gpt} może zawrzeć w~plikach
%   podstawową obsługę błędów (np. sprawdzenie, czy \texttt{malloc} zwrócił
%   \texttt{NULL}), bardziej zaawansowane zarządzanie błędami może wymagać
%   dodatkowych ulepszeń pochodzących od użytkownika.

%   5. **Advanced Topics**: For more advanced topics, like implementing network protocols, writing multi-threaded applications, or interfacing with hardware, the generated code might need more careful review and modification. ChatGPT can provide a solid starting point, but may not always capture the nuances required for robust, production-quality code.

% 6. **Code Quality**: The code generated by ChatGPT may lack certain best practices, such as efficient memory usage, proper resource management, and comprehensive error handling. Therefore, it is advisable for a human programmer to review and refine the code, especially for critical applications.

% In summary, while ChatGPT can generate functional and syntactically correct C code for a wide range of scenarios, it may not always produce optimal or fully correct solutions, particularly for more complex tasks. It's a useful tool for generating initial code snippets, learning concepts, and exploring ideas, but it should be complemented with thorough testing and review by an experienced C programmer.

% \end{frame}
% % ##################





% ######################################
\section{Czy informatyka jest trudna?}
% ######################################



% ##################
\begin{frame}
  \frametitle{Czy informatyka jest trudna?}


  Ten przedmiot dotyczy podstaw informatyki w~języku~C, warto~się
  więc spytać, czy informatyka jest prosta czy trudna w~nauce?

  Informatyka to osobna dziedzina nauki i~jeśli zabrnie~się odpowiednio
  głęboko, to robi~się naprawdę złożona i~niebanalna. Jednak na stosunkowo
  płytkim poziomie to czy jest on trudna czy nie, to mocno zależy od~odczuć
  konkretnej osoby.

  Zadam takie pytanie: czy włączenie komputera jest skomplikowane?
  Odpowiemy na to pytanie na dwóch poziomach. Pierwszy to poziom normalnego
  użytkownika, drugi to opis pochodzący z~książki Andrewa S.~Tanenbauma
  \textit{Systemy operacyjne. Wydanie~III}
  \parencite{Tannenbaum-Systemy-Operacyjne-Wydanie-III-Pub-2013}
  i~dotyczy komputera z~systemem Pentium.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Włączanie komputera, poziom normalnego użytkownika}


  \begin{enumerate}

  \item Wciskamy przycisk \texttt{Power}.

  \item Czekamy minutę albo dłużej.

  \item W~oknie logowania wybieramy użytkownika i~wchodzimy na swoje konto.

  \end{enumerate}

  Co w~tym trudnego?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka pojęcia}


  Oczywiście, opis włączania komputera z~książki Tanenbauma jest tak
  skomplikowany, że~najpierw trzeba wprowadzić trochę pojęć.

  \textbf{\textsc{rom}}, ang.~\textit{Read Only Memory}, pl.~\textit{pamięć
    wyłącznie do~odczytu}. Pamięć komputera której zawartość została
  zapisana przez firmę, która ten fragment pamięci wyprodukowała
  i~użytkownik nie może zmodyfikować jej zawartości. Przynajmniej nie
  w~żaden normalny sposób.

  \textbf{\textsc{ram}}, ang.~\textit{Random Access Memory},
  pl.~\textit{pamięć o~dostępie w~trybie losowym}. Pamięć komputera o~tej
  własności, że~jeśli będę w~sposób losowy wybierał elementy tej pamięci,
  to czas odczytania informacji z~każdego z~tych elementów będzie taki sam.
  Inaczej mówiąc dostęp do dowolnego miejsca tej pamięci zajmuje tyle samo
  czasu.

  Tak naprawdę czas odczytu zależy od tego, w~jakiś sposób pamięć
  \textsc{ram} jest odczytywana, ale jeszcze długo nie będziemy się musieli
  tym przejmować.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka pojęcia}


  \textbf{Pamięć ulotna}, ang.~\textit{volatile memory}. Pamięć której
  zawartość jest tracona, gdy przestaje przez nią płynąć prąd. Typowym
  przykładem takiej pamięci jest \textsc{ram}.

  \textbf{Pamięć nieulotna}, ang.~\textit{non-volatile memory}. Pamięć,
  której treść jest zachowana, gdy przez układ przestaje płynąć prąd.
  Typowym przykładem jest dysk \textsc{ssd}.

  Żeby skomplikować życie, pamięcią nieulotną nazywa~się także tą pamięć,
  które jest ulotna w~ścisłym sensie, ale ponieważ jest zaopatrzona
  we~własną baterię, jej zawartość jest zachowana również po wyłączeniu
  komputera z~prądu. Bo~niby czemu życie ma być proste?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka pojęcia}


  \textbf{Pamięć \textsc{cmos}}, często po prostu \textbf{\textsc{cmos}}.
  Skrót pochodzi od angielskiej nazwy technologi \textit{Complementary
    Metal-Oxide-Semiconductor} (pl.~\textit{komplementarny półprzewodnik
    metalowo-tlenkowy}), w~której ta pamięć jest wykonana. Musi być zasilana
  prądem, by~zachowywała swój stan, ale ponieważ wyposażona jest w~baterię,
  klasyfikowana jest jako nieulotna.

  \textbf{\textsc{bios}} ang.~\textit{Basic Input Output System}, pl.
  \textit{podstawowy system wejścia, wyjścia}. Program znajdujący~się
  na płycie głównej komputera, odpowiedzialny między innymi za odczytywanie
  danych z~klawiatury, obsługę ekranu oraz operacje wejścia-wyjścia dysków.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Uruchamianie komputera z~systemem Pentium}


  \begin{itemize}

  \item[1)] Wciskamy przycisk \texttt{Power}.

  \item[2)] Z~płyty głównej ładowany jest program \textsc{bios}. Sprawdza on
    ilość zainstalowanej pamięci \textsc{ram}, czy komputer dysponuje
    klawiaturą i~innymi podstawowymi urządzeniami oraz sprawdza czy
    urządzenia te odpowiadają w~sposób prawidłowy. W~pierwszej
    kolejności skanowane są magistrale \textsc{isa}
    (ang. \textit{Industry Standard Architecture}) i~\textsc{pci}
    (ang.~\textit{Peripheral Component Interconnect}) w~celu wykrycia
    podłączonych do nich urządzeń.

  \item[3)] Jeśli do komputera podłączone są inne urządzenia, niż te które
    były dostępne przy jego ostatni uruchomieniu, nowe urządzenia są
    konfigurowane.

  \item[4)] Program \textsc{bios} odczytuje listę tzw. urządzeń rozruchowych
    z~pamięci \textsc{cmos}. Urządzenia rozruchowe to te, które mogą
    zawierać system operacyjny. W~przeszłości były nimi dyskietki, płyty
    \textsc{cd}-\textsc{rom}, \textsc{dvd}, dziś choćby pendriwy
    i~dyski~\textsc{ssd}.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Uruchamianie komputera z~systemem Pentium}


  \begin{itemize}

  \item[5)] \textsc{bios} testuje po kolei urządzenia rozruchowe
    z~wspomnianej wcześniej listy, aż~znajdzie pierwsze, który zawiera
    działający system operacyjny.

  \item[6)] \textsc{bios} wczytuje pierwszy sektor ze~znalezionego
    w~poprzednim punkcie urządzenia rozruchowego do pamięci i~go uruchamia.

  \item[7)] Program wczytany z~pierwszego sektora sprawdza zapisaną na jego
    końcu listę partycji, by~ustalić która z~nich jest partycją aktywną.
    Następnie wczytuje z~tej partycji pomocniczy program rozruchowy.

  \item[8)] Pomocniczy program rozruchowy wczytuje system operacyjny
    z~aktywnej partycji i~go uruchamia.

  \item[9)] System operacyjny odczytuje informacje konfiguracyjne z~systemu
    \textsc{bios}. Dla każdego dostępnego urządzenia sprawdza, czy posiada
    jego sterowniki. Jeśli nie, to prosi o~ich zainstalowanie
    z~odpowiedniego źródła.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Uruchamianie komputera z~systemem Pentium}


  \begin{itemize}

  \item[10)] Jeśli system operacyjny dysponuje wszystkimi sterownikami,
    to ładuje je do jądra systemu.

  \item[11)] System operacyjny tworzy tabele systemowe oraz procesy
    działające w~tle.

  \item[12)] Uruchamiane jest okno logowania.

  \end{itemize}

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Bootowanie}


  W~literaturze funkcjonuje termin \textbf{bootwoanie}, zwane też
  \textbf{uruchamianiem} lub \textbf{rozruchem}. Odnosi~się ono albo do
  całej procedury uruchamiania komputer opisanej powyżej, albo tylko
  stawiania systemu operacyjnego, czyli od kiedy \textsc{bios} wczytał
  pierwszy jego sektor do pamięci (punkt siedem i~dalej). Acz to pojęcie
  nie jest specjalnie ostro zdefiniowane.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czy uruchomienie komputera jest proste czy trudne?}


  Zależy jak do tego podchodzimy. I~tak jest z~większością rzeczy
  w~informatyce.

\end{frame}
% ##################








% ######################################
\section{Dygresja o~diagramach występujących w~tych
  prezentacjach}
% ######################################



% ##################
\begin{frame}
  \frametitle{Konwencja}


  \begin{textblock}{2.8}(2,1.5)

    \begin{tikzpicture}

      \node[diagram block] at (0,0) {Coś robi};

    \end{tikzpicture}

  \end{textblock}



  \begin{textblock}{2.8}(8,1.5)

    \begin{tikzpicture}

      \node[diagram rectangle block] at (0,0) {Czymś jest};

    \end{tikzpicture}

  \end{textblock}


  \vspace{6em}





  Bloki diagramu które mają kształt prostokąta z~zaokrąglonymi rogami
  (zwykle~są koloru niebieskiego) oznaczają \textbf{aktorów}, czyli
  taki obiekt który wykonuje jakąś czynność na zadanych obiektach
  wejściowych. Takim obiektem może być człowiek, komputer, program
  komputerowy, fragment programu komputerowego, etc.

  Bloki diagramu które mają kształt prostokąta z~ostrymi rogami (zwykle~są
  koloru karmelowego), przedstawiają rzeczy które są pobierane na~wejście
  przez aktorów lub przez nich wytwarzane.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Przykładowy diagram}


  Konwencję tą ilustruje poniższy, zrobionym z~przymrużeniem oka, diagram.
  Przedstawia on proces tworzenia przez człowieka za pomocą klawiatury
  i~komputera programu w~języku programowania~C.





  \begin{figure}

    \label{fig:Creating-code-in-C}


    \begin{tikzpicture}

      \node[diagram block] (Man) at (0,0) {Człowiek};

      \node[diagram block,right=of Man] (Keyboard) {Klawiatura};

      \draw[thick diagram arrow] (Man) -- (Keyboard);



      \node[diagram block,right=of Keyboard] (Computer) {Komputer};

      \draw[thick diagram arrow] (Keyboard) -- (Computer);



      \node[diagram rectangle block,below=of Computer] (Source code)
      {Kod źródłowy w~języku~C};

      \draw[thick diagram arrow] (Computer) -- (Source code);

    \end{tikzpicture}

    \caption{Diagram ilustrujący tworzenie kodu w~języku~C.}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Inny diagram}


  Czy poniższy diagram jest lepszy czy gorszy od poprzedniego? Zależy
  od~tego jakie informacje ma dany diagram przekazywać. Proszę~się więc nie
  dziwić, jeśli na danym diagramie czegoś nie ma, a~nawet, że~nie ma czegoś
  co było na poprzedniej wersji diagramu. Zawsze trzeba dokonać selekcji co
  na diagramie zostanie umieszczone, a~co nie i~ten wybór często zależy
  od kontekstu.

  Jeśli uważają Państwo, że~na diagramie nie ma czegoś, co być powinno,
  albo coś innego jest nie w~porządku, \alert{proszę} to mi powiedzieć.
  Całkiem możliwe, że~popełniłem błąd rysując dany diagram.






  \begin{figure}

    \label{fig:Also-creating-code-in-C}


    \begin{tikzpicture}

      \node[diagram block] (Man) at (0,0) {Człowiek};

      \node[diagram rectangle block,right=of Man] (Source code)
      {Kod źródłowy w~języku~C};

      \draw[thick diagram arrow] (Man) -- (Source code);

    \end{tikzpicture}

    \caption{Inna wersja diagramu ilustrującego tworzenie kodu w~języku~C.}


  \end{figure}

\end{frame}
% ##################





% % ##################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ##################










% ######################################
\section{Podstawowe informacje o~języku~C}
% ######################################








% ##################
\begin{frame}
  \frametitle{Przesadnie pedantyczna lista featurów języka~C}


  \begin{itemize}

  \item[1)] Zmienne.

  \item[2)] Typy zmiennych: \texttt{char}, \texttt{short int}, \texttt{int},
    \texttt{long int}, \texttt{float}, \ldots

  \item[3)] Operator przypisania: \texttt{=}.

  \item[4)] Operator arytmetyczne: \texttt{+}, \texttt{-}, \texttt{*},
    \texttt{/}, \texttt{\%}.
    (Jeśli Państwo myślą, że~to banalnie proste, to~się Państwo
    nieprzyjemnie zdziwią.)

  \item[5)] Operatory porównania: \texttt{==} (nie pomylić z~operatorem
    przypisania~\texttt{=}),

  \item[6)] Instrukcje warunkowe: \texttt{if \ldots{} else \ldots}, \texttt{switch}.

  \item[7)] Pętle: \texttt{while}, \texttt{for}, \texttt{do \ldots{} while}.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{?????}


  Nie potrafię teraz powiedzieć, czy zdążymy, choćby bardzo pobieżnie,
  przerobić \alert{wszystkie} featury języka~C. Proszę pamiętać, że~to jest
  kurs \alert{podstaw informatyki}, więc nie należy~się spodziewać,
  że~nauczymy~się tu wszystkiego. Nawet o~podstawach informatyki.

  Lubię myśleć o~języku programowania jako o~skrzynce z~narzędziami.
  Im lepiej znasz swoją skrzynkę, tym prościej ci wykonać dane zadanie.
  Przykładowo, można wyciągnąć śrubę ze~ściany obcęgami, ale lepiej
  wiedzieć, że w~skrzynce jest śrubokręt.

  Tak samo proszę myśleć o~naszej nauce języka~C. Na początku będziemy
  poznawali pojedyncze „narzędzia” jakie są w~tej „skrzynce” są, co niestety
  dla wielu osób jest nudne. Dopiero jednak jak będziemy znali ich
  odpowiednią liczbę ma sens zabieranie~się

\end{frame}
% ##################
















% % ##################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ##################










% ######################################
\section{C~to teraźniejszość. A~co jest przyszłością?}
% ######################################



% ##################
\begin{frame}
  \frametitle{C ma ponad 50~lat, co dalej?}


  Jak powiedział amerykański filozof i~bejsbolista Yogi Berra
  (właśc. Lawrence Peter Berra, $1925 \text{--} 2015$) „Przewidywanie jest
  bardzo trudne. Zwłaszcza jeśli próbuje~się przewidywać przyszłość.”
  Dlatego muszę zastrzec, że~to co mówią odnośnie przyszłości, są to moje
  osobiste refleksje. Nie mogę dać żadnej gwarancji, że~się sprawdzą.

  Język~C stworzony w~$1972$ roku, ma już ponad $50$~lat, więc to jasne,
  że~pojawiają~się pomysły na języki które mają go zastąpić. W~pewnym sensie
  C++ jest takim językiem. Jednak od momentu pojawienia~się C++, za taką
  datę możemy przyjąć $1985$~rok, minęło sporo czasu, zamiast zastąpić~C,
  język ten żyje obok niego. Ale to bardziej temat na zajęcia o~C++.

  Proszę pamiętać, że~relacja między~C, a~C++, jest jak między krzesłem,
  a~krzesłem elektrycznym.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{C~nie będzie wieczny, ale\ldots}


  Przez ponad pół wieku~(!) w~C napisano niewiarygodne ilość rewelacyjnie
  działającego kodu (co nie znaczy, że~kod ten jest pozbawiony błędów
  i~wad). Ponieważ utrzymywanie starego kodu jest zwykle prostsze niż
  pisanie nowego, który robi to samo, więc część z~tego kody będzie
  utrzymywana tak długo jak tylko~się będzie dało. Przykładowo, jądro
  systemu operacyjnego Linux jest napisane w~$98\%$ w~języku~C (zobacz
  statystki jego \colorhref{https://github.com/torvalds/linux}{repozytorium}
  na~GitHubie). A~bez tego jądra internet pewnie~się zawali.

  Trzeba też pamiętać, że~cała masa innych języków programowania zależna
  jest od kodu napisanego w~dużej części w~C. Przykładowo, szeroko stosowana
  w~obliczeniach numerycznych biblioteka \texttt{numpy} języka Python,
  w~35\% jest napisana w~języku~C (zob. jego
  \colorhref{https://github.com/numpy/numpy}{repozytorium} na~GitHubie).

  Przyczyna tego jest zwykle prosta: C~pozwala tworzyć bardzo szybki kod.
  Kod napisany w~czystym Pythonie jest niestety relatywnie wolny.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kilka pojęcia}


  Dobrze, ale co z~kodem napisanym w~C, który chcemy zastąpić nowym oraz
  nowo tworzonym kodem? Czy tutaj język~C jest dalej niezastąpiony? Krótka
  i~bardzo uproszczona odpowiedź jest taka: C~jest tam już zastępowany
  nowymi językami, acz sprawa toczy~się stosunkowo wolno. W~tym momencie
  powiedziałbym, że~C wciąż ma przyszłość.

  Patrząc trochę w~przyszłość, moja opinia na dzień dzisiejszy jest taka,
  że~języka~C \alert{nie} zastąpi jeden język, tylko kilka. Każdy z~nich
  będzie dopasowany do konkretnej dziedziny
  zastosowań, którą obecnie obejmuje (przynajmniej częściowo) język~C.

  W~mojej ocenie, 80\% dotychczasowego pola zastosowań~C przejmą trzy
  języki: \colorhref{https://go.dev/}{Go},
  \colorhref{https://www.rust-lang.org/}{Rust}
  i~\colorhref{https://ziglang.org/}{Zig}. Pozostałe 20\% przyjmie kilka
  innych, wysoce wyspecjalizowanych języków, ale tutaj nie mam odwagi
  zgadywać, jakie to będą.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{????}


  Jeśli ktoś chce rozszerzyć swoją wiedzę o~jeden z~wymienionych wcześniej
  języków, Go, Rust i~Zig, to proponuję zacząć od~języka~Go. Jest on
  stosunkowo mały, wygodny w~użyciu i~najbardziej z~całej trójki zbliżony
  do~C, więc studiowanie go równolegle z~C, powinno wymagać najmniej pracy.

  Instrukcje jak pobrać i~zainstalować język~Go, można znaleźć
  \colorhref{https://go.dev/learn/}{tutaj}.

  Gdy chodzi o~materiały do nauki, to początkującym polecam zacząć od
  \colorhref{https://www.youtube.com/watch?v=akosxcqJorU}{\textit{Go for
      Absolute Beginners~-- Tutorial}} kanału freeCodeCamp.org
  i~kursu
  \colorhref{https://www.youtube.com/watch?v=WVjc_wl17FA}{\textit{Go
      tutorial for beginners}} Thomasa Langhorsta. Osoby bardziej
  zaawansowane mogą sięgnąć od razu po oficjalne wprowadzenie do~języka
  \colorhref{https://go.dev/tour/welcome/1}{\textit{A~Tour~of Go}}
  (większość tego wprowadzenia jest dostępna również w~języku polskim).

\end{frame}
% ##################










% ######################################
\section{Dlaczego istnieją języki takie jak~C?}
% ######################################



% ##################
\begin{frame}
  \frametitle{Dlaczego w~ogóle istnieją takie języki jak~C?}

  \pause


  Żeby komputer coś zrobił musimy więc mu przekazać polecenie w~języku,
  który rozumie. Dla mnie pierwotny językiem jest język polski, co zaś
  jest pierwotnym językiem komputera? Na potrzeby tego kursu przyjmiemy,
  że~pierwotnym językiem komputera jest \textbf{język asembler}
  (ang. \textit{assembly language}).

  Tak jak niektórzy ludzie mają jako swój pierwotny język angielski,
  hiszpański, japoński, niemiecki, polski, etc., tak komputer również
  posługują~się różnymi rodzajami języka asembler, takimi jak \textsc{arm}
  czy x86/Intel. Typ asemblera jest ustalony przez firmę, która
  wyprodukowała procesor, bowiem asembler jest zdefiniowany przez to jak są
  „podpięte kable” w~rzeczonym procesorze.

  Tutaj pojawia~się pewien problem. Przyjrzyjmy~się teraz programowi
  „Hello, World!” napisanemu w~dialektach asemblera \textsc{arm}~32,
  AArch64, \textsc{risc-v}, x86 i~\textsc{nasm} oraz językach~C
  i~Python.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze ARM~32,
    \parencite{Low-Level-Learning-You-Can-Learn-ARM-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x4} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr r1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov r2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{svc 0} \\

  \hphantom{aaaaaaaa} \texttt{mov x8, \#0x5d} \\
  \hphantom{aaaaaaaa} \texttt{mov x0, \#0x41} \\

  \hphantom{aaaaaaaa} \texttt{svc 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~asemblerze AArch64,
    \parencite{Low-Level-Learning-You-Can-Learn-AArch64-ETC-Ver-2020}}


  \texttt{.global \_start} \\
  \texttt{.section .text} \\



  \texttt{\_start:} \\[-0.2em]
  \hphantom{aaaaaaaa} \texttt{mov x8, \#64} \\
  \hphantom{aaaaaaaa} \texttt{mov x0, \#1} \\
  \hphantom{aaaaaaaa} \texttt{ldr x1, =message} \\
  \hphantom{aaaaaaaa} \texttt{mov x2, \#14} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\

  \hphantom{aaaaaaaa} \texttt{mov r7, \#0x1} \\
  \hphantom{aaaaaaaa} \texttt{mov r0, \#65} \\

  \hphantom{aaaaaaaa} \texttt{swi 0} \\



  \texttt{.section .data} \\
  \texttt{message:} \\
  \hphantom{aaaaaaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze RISC-V
    \parencite{Low-Level-Learning-You-Can-Learn-RISC-V-ETC-Ver-2021}}


  \texttt{.global \_start} \\
  \texttt{\_start:} \\
  \hphantom{aaaa} \texttt{addi a7, zero, 64} \\
  \hphantom{aaaa} \texttt{addi a0, zero, 1} \\
  \hphantom{aaaa} \texttt{la a1, helloworld} \\
  \hphantom{aaaa} \texttt{addi a2, zero, 14} \\
  \hphantom{aaaa} \texttt{ecall}
  \vspace{0.8em}

  \hphantom{aaaa} \texttt{addi a7, zero, 93} \\
  \hphantom{aaaa} \texttt{addi a0, zero, 13} \\
  \hphantom{aaaa} \texttt{ecall}
  \vspace{0.8em}

  \texttt{helloworld:} \\
  \hphantom{aaaa} \texttt{.ascii "Hello, World!\textbackslash n"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze NASM
    \parencite{Toal-NASM-Tutorial-Ver-2024}}


  \hphantom{aaaaaaaaa} \texttt{global} \hphantom{aa} \texttt{\_start} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section} \hphantom{a} \texttt{.text} \\
  \texttt{\_start:} \hphantom{a} \hspace{-0.15em}
  \texttt{mov} \hphantom{aaaaaa} \texttt{rax, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdi, 1} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa}
  \texttt{rsi, message} \\
  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rdx, 14} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{mov} \hphantom{aaaaaa} \texttt{rax, 60} \\
  \hphantom{aaaaaaaaa} \texttt{xor} \hphantom{aaaaaa} \texttt{rdi, rdi} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{syscall} \\
  \vspace{0.8em}

  \hphantom{aaaaaaaaa} \texttt{section .data} \\
  \vspace{0.8em}

  \texttt{message: db} \hphantom{aaaaa} \texttt{"Hello, World!", 10}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~assemblerze x86
    \parencite{Anonymous-Hello-World-in-x86-Assembly-Language}}


  \texttt{org 0x100} \\
  \vspace{0.8em}

  \texttt{mov dx, msg} \\
  \texttt{mov ah, 9} \\
  \texttt{int 0x21} \\
  \vspace{0.8em}

  \texttt{mov ah, 0x4c} \\
  \texttt{int 0x21} \\
  \vspace{0.8em}

  \texttt{msg db 'Hello, World!', 0x0d, 0x0a, '\$'}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~C}


  \texttt{\#include <stdio.h>} \\
  \vspace{0.8em}
  \texttt{int main() \{ } \\
  \hphantom{aaaa} \texttt{printf("Hello, World!\textbackslash n");} \\
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \vspace{0.8em}
  \hphantom{aaaa} \texttt{return 0;} \\
  \texttt{ \} }

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{„Hello, World!” w~języku~Python}


  \texttt{print("Hello, World!")}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Co z~tego wynika?}


  Na pierwszy rzut oka powinno być jasne, że~C jest prostszy od~asemblera,
  a~Python prostszy od~C.

  Większość ludzi zrobi wszystko, by tylko uniknąć pracy w~asemblerze.
  Mam nadzieję, że~nie muszę tłumaczyć dlaczego.  A~nawet jeśli
  znajdzie~się człowieka, który lubi w~nim pisać, to unika~się jak tylko
  można tego, by kod napisany przez niego w~asemblerze wszedł w~skład
  danego programu.

  Jest tak dlatego, że~nawet najlepsi programiści zbyt łatwo mylą~się
  pisząc w~asemblerze, a~pomyłki na jego poziomie są szczególnie
  niebezpieczne. Niestety, wyjaśnienie czemu tak jest, to temat na osobny
  wykład. W~skrócie, błędy w~asemblerze to raj dla hakerów.

  \alert{Ważne.} Czy od tego momentu kursu możemy uznać, że~język
  asemblera sam w~sobie nas zupełnie nie interesuje?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak sobie z~tym poradzić?}


  Jeśli jednak ktoś z~Państwa chce~się dowiedzieć więcej o~asemblerze,
  to bardzo mnie to cieszy, ale musimy to przełożyć na czas po zajęciach.
  Wtedy służę Państwu całą moją wiedzą.

  Może zadają sobie Państwo następujące pytanie. Jeśli Python jest prostszy
  od~C, to czemu kurs \textit{Podstawy informatyki w~języku~C} jest
  prowadzony w~C, a~nie w~Pythonie? Gdybym ja miał na to wpływ, to może
  byłby prowadzony w~Pythonie, ale nie ja o~tym decyduje.

  Jak rozwiązujemy ten problem dziś? Tworzymy język taki jak~C, piszemy
  w~nich programy, a~następnie odpowiedni program zwany
  \textbf{kompilatorem} tłumaczy ten program na język asembler.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Prosty schemat działania kompilatora}


  \begin{figure}

    \begin{tikzpicture}[node distance=0.7]

      \node[diagram rectangle block] (C source code) at (0,0)
      {Kod programu w~języku C};

      \node[diagram block,below=of C source code] (Compiler)
      {Magia (kompilator)};

      \draw[thick diagram arrow] (C source code) -- (Compiler);



      \node[diagram rectangle block,below=of Compiler] (Assembly code)
      {Kod programu w~asemblerze};

      \draw[thick diagram arrow] (Compiler) -- (Assembly code);

    \end{tikzpicture}

    \caption{Ilustracja działania kompilatora~;).}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Program „Hello, World!” skompilowany z~C\ldots}


  Kompilator tłumaczy kod w~języku źródłowym, w~naszym przypadku jest nim
  język~C, na kod w~języku wynikowym, u~nas jest to odpowiedni dialekt
  asemblera. Kompilator którego będziemy używać, to~\texttt{gcc}, akronim
  od~angielskiego \textit{\textsc{gnu} Compiler Collection}, „zbiór
  kompilatorów projektu \textsc{gnu}”.

  Żeby zobaczyć jaki kod w~języku asembler tworzy kompilator \texttt{gcc}
  należy wywołać polecenie: \\
  \texttt{\$ gcc -S program.c -o program-w-jezyku-asemblera.asm}

  Kod języka asemblera jaki zostanie utworzony zależy od miliarda rzeczy
  (typu procesora, wersji kompilatora, etc.). W~każdym razie na moim
  komputerze program „Hello, World!” kompiluje~się do następującego kodu
  języka asemblera.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Z~C do~asemblera, część~I}


  \hphantom{aaaaa} \texttt{.file} \hphantom{aaa}
  \texttt{"PI-01-A-Program-pokazowy-01.c"} \\
  \hphantom{aaaaa} \texttt{.text} \\
  \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa} \texttt{.rodata} \\
  \texttt{.LC0:} \\
  \hphantom{aaaaa} \texttt{.string "Hello, World!"} \\
  \hphantom{aaaaa} \texttt{.text} \\
  \hphantom{aaaaa} \texttt{.globl} \hphantom{aa} \texttt{main} \\
  \hphantom{aaaaa} \texttt{.type} \hphantom{aaa}
  \texttt{main, @function} \\
  \texttt{main:} \\
  \texttt{.LFB0:} \\
  \hphantom{aaaaa} \texttt{.cfi\_startproc} \\
  \hphantom{aaaaa} \texttt{endbr64} \\
  \hphantom{aaaaa} \texttt{pushq} \hphantom{aaa} \texttt{\%rbp} \\
  \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_offset 16} \\
  \hphantom{aaaaa} \texttt{.cfi\_offset 6, -16} \\

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Z~C do~asemblera, część~II}


  \hphantom{aaaaa} \texttt{movq} \hphantom{aaa} \texttt{\%rsp, \%rbp} \\
  \hphantom{aaaaa} \texttt{.cfi\_def\_cfa\_regitser 6} \\
  \hphantom{aaaaa} \texttt{leaq} \hphantom{aaa}
  \texttt{.LC0(\%rip), \%rax} \\
  \hphantom{aaaaa} \texttt{movq} \hphantom{aaa} \texttt{\%rax, \%rdi} \\
  \hphantom{aaaaa} \texttt{call} \hphantom{aaa} \texttt{puts@PLT} \\
  \hphantom{aaaaa} \texttt{movl} \hphantom{aaa} \texttt{\$0, \%eax} \\
  \hphantom{aaaaa} \texttt{popq} \hphantom{aaa} \texttt{\%rbp} \\
  \hphantom{aaaaa} \texttt{.cfi\_def\_cfa 7, 8} \\
  \hphantom{aaaaa} \texttt{ret} \\
  \hphantom{aaaaa} \texttt{.cfi\_endproc} \\
  \texttt{.LFE0:} \\
  \hphantom{aaaaa} \texttt{.size} \hphantom{aaa} \texttt{main, .-main} \\
  \hphantom{aaaaa} \texttt{.ident} \hphantom{aa}
  \texttt{"GCC: (Ubuntu 11.4.0-1ubuntu1-22.04) 11.4.0"} \\
  \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa}
  \texttt{.note.GNU-stack,"",@progbits} \\
  \hphantom{aaaaa} \texttt{.section} \hphantom{aaaaaa}
  \texttt{.note.gnu.property,"a"}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Z~C do~asemblera, część~III}


  \hphantom{aaaaa} \texttt{.align 8} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{1f - 0f} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{4f - 1f} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{5} \\
  \texttt{0:} \\
  \hphantom{aaaaa} \texttt{.string "GNU"} \\
  \texttt{1:} \\
  \hphantom{aaaaa} \texttt{.align 8} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{0xc0000002} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{3f - 2f} \\
  \texttt{2:} \\
  \hphantom{aaaaa} \texttt{.long} \hphantom{aaa} \texttt{0x3} \\
  \texttt{3:} \\
  \hphantom{aaaaa} \texttt{.align 8} \\
  \texttt{4:}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Program „Hello, World!” skompilowany z~C\ldots}


  \alert{Ważne.} Czy od tego momentu, możemy przyjąć, że~nie interesuje
  nas jak dokładnie kompilator działa?

  Jeśli jednak ktoś jest bardziej zainteresowany tą tematyką, to po
  zajęciach służę całą moją wiedzą.

\end{frame}
% ##################










% ######################################
\section{Fazy uruchamiania programu w~języku~C}
% ######################################



% ##################
\begin{frame}
  \frametitle{Trzy fazy tworzenie programu w~języku~C}


  By stworzyć program w~języku~C musimy przejść trzy fazy.

  \begin{enumerate}

  \item Faza pisania programu.

  \item Faza kompilacji.

  \item Faza wykonywania.

  \end{enumerate}



  \alert{Faza pisania programu.} Jest dość oczywista. Otwieramy plik
  z~kodem źródłowym poleceniem: \\
  \texttt{\$ gedit helloWorld.c \&} \\
  wpisujemy w~nim \\
  \texttt{\#include <stdio.h>} \\
  \texttt{int main() \{ } \\
  \hphantom{aaaa} \texttt{printf("Hello, World!\textbackslash n");} \\
  \hphantom{aaaa} \texttt{return 0;} \\
  \texttt{ \} } \\
  Następnie zapisujemy plik na~dysku (\texttt{Ctrl-s}). Koniec.



  % \begin{figure}

  %   \label{fig:Translator-04}

  %   \begin{tikzpicture}

  %     \node[diagram rectangle block] (Source program) at (0,0)
  %     {Program źródłowy (język~C)};

  %     \node[diagram block,right=of Source program] (Compiler)
  %     {Kompilator};

  %     \draw[thick diagram arrow] (Source program) -- (Compiler);



  %     \node[diagram rectangle block,right=of Compiler]
  %     (Target program)
  %     {Program wynikowy (dia. asemblera)};

  %     \draw[thick diagram arrow] (Translator) -- (Target program);

  %   \end{tikzpicture}

  %   \caption{Translator jako czarna skrzynka}


  % \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Faza kompilacji i~wykonania}


  \alert{Faza kompilacji.} Kompilator analizuj niezrozumiały dla komputera
  kod w~języku~C, następnie tłumaczy go na zrozumiał dla danej maszyny kod
  w~odpowiedni dialekcie asemblera. Wynik tego tłumaczenia jest zapisywany
  w~osobnym pliku.

  Kompilator \alert{tylko} przekłada kod z~jednego języka na drugi
  i~zapisuje wynik w~odpowiednim pliku, ale \alert{nie} uruchamia
  otrzymanego programu. Używając prostego przykładu, kompilator
  przetłumaczy „Eat the soup.” na „Zjedz zupę.”, ale nie powie nikomu,
  że~ma zjeść zupę.%  Kompilator dokonuje \alert{tylko} przekładu z~jednego
  % języka na drugi i~jego zapisu do pliku, \alert{nie} uruchamia jednak tego
  % programu. Używając prostego przykładu, kompilator przetłumaczy „Eat the
  % soup.” na „Zjedz zupę.”, ale nie powie nikomu, że~ma zjeść zupę.

  % Przez wywołanie polecenia \\
  % \texttt{\$ gcc --std=c99 -pedantic helloWorld.c -o outProg} \\
  % wykonujemy fazę kompilacji kodu źródłowego \texttt{helloWorld.c}
  % dostając w~rezultacie program wynikowy \texttt{outProg}.

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Jak to wygląda w~praktyce?}


  Przez wywołanie polecenia \\
  \texttt{\$ gcc --std=c99 -pedantic helloWorld.c -o outProg} \\
  wykonujemy fazę kompilacji kodu źródłowego \texttt{helloWorld.c}
  dostając w~rezultacie program wynikowy \texttt{outProg}.

  By bardziej to zobrazować wywołajmy teraz polecenie \\
  \texttt{\$ file helloWorld.c} \\
  Zakładając, że~na dysku istnieje już plik \texttt{outProg}, wprowadźmy
  podobne do poprzedniego polecenie: \\
  \texttt{\$ file outProg} \\
  Można się czuć zagubionym wśród \textsc{elf}ów, ciast (\textsc{pie})
  i~tym podobnych tworów, ale da~się z~tym żyć.

  % \alert{Faza wykonania.} Otrzymany program uruchamiamy wywołując
  % polecenie \\
  % \texttt{\$ ./outProg}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jak to wygląda w~praktyce?}


  % Przez wywołanie polecenia \\
  % \texttt{\$ gcc --std=c99 -pedantic helloWorld.c -o outProg} \\
  % wykonujemy fazę kompilacji kodu źródłowego \texttt{helloWorld.c}
  % dostając w~rezultacie program wynikowy \texttt{outProg}.

  % By bardziej to zobrazować wywołajmy teraz polecenie \\
  % \texttt{\$ file helloWorld.c} \\
  % Zakładając, że~na dysku istnieje już plik \texttt{outProg}, wprowadźmy
  % podobne do poprzedniego polecenie: \\
  % \texttt{\$ file outProg} \\
  % Można się czuć zagubionym wśród \textsc{elf}ów, ciast (\textsc{pie})
  % i~tym podobnych tworów, ale da~się z~tym żyć.

  \alert{Faza wykonania.} Wkraczamy w~nią uruchamiając otrzymany w~fazie
  kompilacji program \texttt{outProg} za pomocą polecenia \\
  \texttt{\$ ./outProg} \\
  W~jego rezultacie system operacyjny przekierowuje kod asemblera
  zawarty w~pliku \texttt{outProg} na procesor, który następnie go wykonuje
  i~w~rezultacie na ekranie widzimy napis „Hello, World!”.

  Jeśli komuś brak jeszcze mocnych wrażeń albo chce mocno odlecieć, niech
  wywoła polecenie \\
  \texttt{\$ xxd outProg outProg\_hex.txt} \\
  a~następnie otworzy plik \texttt{outProg\_hex.txt} wywołując \\
  \texttt{\$ gedit outProg\_hex.txt}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Faza kompilacji i~faza wykonania}


  \begin{figure}

    \begin{tikzpicture}[node distance=0.5]

      \node[diagram rectangle block] (Source code) at (0,0) {Kod źródłowy};

      \node[diagram block,below=of Source code] (Compiler) {Kompilator};

      \draw[thick diagram arrow] (Source code) -- (Compiler);



      \node[diagram rectangle block,below=of Compiler] (Target program)
      {Program wynikowy};

      \draw[thick diagram arrow] (Compiler) -- (Target program);



      \node[below=0.1em of Target program] {a) Faza kompilacji};






      \begin{scope}[xshift=5cm]


        \node[diagram rectangle block] (Input) at (0,0) {Wejście};

        \node[diagram block,below=of Input] (Running target program)
        {Uruchomiony program wynikowy};

        \draw[thick diagram arrow] (Input) -- (Running target program);



        \node[diagram rectangle block,below=of Running target program]
        (Results) {Wyniki działania programu};

        \draw[thick diagram arrow] (Running target program) --
        (Results);



        \node[below=0.1em of Results] {b) Faza wykonania};

      \end{scope}

    \end{tikzpicture}

    \caption{Ilustracja podziału na fazę kompilacji i~wykonania programu}


  \end{figure}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{W~naszym wypadku}


  \begin{figure}

    \begin{tikzpicture}[node distance=0.5]

      \node[diagram rectangle block] (Source code) at (0,0)
      {\texttt{helloWorld.c}};

      \node[diagram block,below=of Source code] (Compiler)
      {Kompilator \texttt{gcc}};

      \draw[thick diagram arrow] (Source code) -- (Compiler);



      \node[diagram rectangle block,below=of Compiler] (Target program)
      {\texttt{outProg}};

      \draw[thick diagram arrow] (Compiler) -- (Target program);



      \node[below=0.1em of Target program] {a) Faza kompilacji};






      \begin{scope}[xshift=5cm]


        \node[diagram rectangle block] (Input) at (0,0)
        {\texttt{outProg}};

        \node[diagram block,below=of Input] (Running target program)
        {\texttt{\$ ./outProg}};

        \draw[thick diagram arrow] (Input) -- (Running target program);



        \node[diagram rectangle block,below=of Running target program]
        (Results) {Hello, World!};

        \draw[thick diagram arrow] (Running target program) --
        (Results);



        \node[below=0.1em of Results] {b) Faza wykonania};

      \end{scope}

    \end{tikzpicture}

    \caption{Kompilacja i~wykonanie programu „Hello, World!”.}


  \end{figure}

\end{frame}
% ##################










% ######################################
\section{Jakie są inne języki programowania?}
% ######################################


% ##################
\begin{frame}
  \frametitle{Jakie są inne języki programowania?}


  Wymieńmy 20 najpopularniejszych języków programowania według indeksu
  \colorhref{https://www.tiobe.com/tiobe-index/}{\textsc{tiobe}}. Poniżej
  prezentowany jest stan tego indeksu na lipiec 2024. Podane wielkości
  procentowe przedstawiają wyliczoną przez twórców indeksu popularność
  języka.



  \begin{itemize}

  \item[1)] \colorhref{https://www.python.org/}{Python}, 16.12\%.

  \item[2)] C++, 10.34\%.

  \item[3)] C, 9.48\%.

  \item[4)] \colorhref{https://www.java.com/pl/}{Java}, 8.59\%.

  \item[5)]
    \colorhref{https://learn.microsoft.com/en-us/dotnet/csharp/}{C\#},
    6.72\%.

  \item[6)] JavaScript, 3.79\%.

  \item[7)] \colorhref{https://go.dev/}{Go}, 2.19\%.

  \item[8)] Visual Basic, 2.08\%.

  \end{itemize}

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Jakie są inne języki programowania?}


  \begin{itemize}

  \item[9)] Fortran, 2.05\%.

  \item[10)] \textsc{sql}, 2.04\%.

  \item[11)] Delphi/Object Pascal, 1.89\%.

  \item[12)] \textsc{matlab}, 1.34\%.

  \item[13)] \colorhref{https://www.rust-lang.org/}{Rust}, 1.18\%.

  \item[14)] \colorhref{https://www.ruby-lang.org/en/}{Ruby}, 1.16\%.

  \item[15)] Scratch, 1.15\%.

  \item[16)] \textsc{php}, 1.15\%.

  \item[17)] \colorhref{https://www.swift.org/}{Swift}, 1.13\%.

  \item[18)] Assembly language, 1.11\%.

  \item[19)] \textsc{cobol}, 1.08\%.

  \item[20)] \colorhref{https://kotlinlang.org/}{Kotlin}, 1.05\%.

  \end{itemize}

\end{frame}
% ##################







% % ############################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ############################































% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ############################
% End of the document

\end{document}
