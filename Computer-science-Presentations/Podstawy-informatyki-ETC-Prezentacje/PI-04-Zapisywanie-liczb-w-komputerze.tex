% ------------------------------------------------------------------------------------------------------------------
% Basic configuration of Beamera class and Jagiellonian theme
% ------------------------------------------------------------------------------------------------------------------
\RequirePackage[l2tabu, orthodox]{nag}



\ifx\PresentationStyle\notset
  \def\PresentationStyle{dark}
\fi



% Options: t -- align text to the top of the frame.
\documentclass[10pt,t]{beamer}
\mode<presentation>
\usetheme[style=\PresentationStyle]{jagiellonian}





% ------------------------------------------------------------------------------------
% Procesing configuration files of Jagiellonian theme located in
% the directory "preambule".
% ------------------------------------------------------------------------------------
\input{./preambule/LanguageSettings/JagiellonianPolishLanguageSettings.tex}
\input{./preambule/TextposConfiguration/TextposConfiguration.tex}

\input{./preambule/ImportingLocalPackages.tex}

\input{./preambule/JagiellonianCustomizationGeneral.tex}
\input{./preambule/JagiellonianCustomizationCommands.tex}










% ------------------------------------------------------
% BibLaTeX
% ------------------------------------------------------
% Package biblatex, with biber as its backend, allow us to handle
% bibliography entries that use Unicode symbols outside ASCII.
\usepackage[
language=polish,
backend=biber,
style=alphabetic,
url=false,
eprint=true,
]{biblatex}

\addbibresource{Podstawy-informatyki-ETC-Bibliography.bib}





% ------------------------------------------------------
% Importing packages, libraries and setting their configuration
% ------------------------------------------------------
% Library improving positioning of nodes in graphs
% \usetikzlibrary{positioning}





% ------------------------------------------------------
% Local packages
% ------------------------------------------------------
% Local configuration of this particular presentation.
\usepackage{./Local-packages/local-settings}

% Package containing various command useful for working with a text.
\usepackage{./Local-packages/general-commands}

% % Styles for drawing diagrams
% \usepackage{./Local-packages/PGF-TikZ-Diagram-styles}

% % Jagiellonian theme's colors
% \usepackage{./Local-packages/jagiellonian-theme-colors}










% ------------------------------------------------------------------------------------------------------------------
\title{Podstawy informatyki z~językiem~C}
\subtitle{Programowanie nie jest trudne, debugowanie już tak}

\author{Kamil Ziemian \\
  \email}


% \date{}
% ------------------------------------------------------------------------------------------------------------------










% ####################################################################
% Beginning of the document
\begin{document}
% ####################################################################





% ######################################
% Number of chars: 7k+, 29k+,
% Text is adjusted to the left and words are broken at the end of the line.
\RaggedRight
% ######################################





% ######################################
\maketitle
% ######################################





% ##################
\begin{frame}
  \frametitle{Spis treści}


  \tableofcontents

\end{frame}
% ##################










% ######################################
\section{Zapisywanie liczb w~komputerze}
% ######################################


% ##################
\begin{frame}
  \frametitle{Komputer to maszyna do liczenia}


  W~samej angielskiej nazwie \textit{computer} zawiera~się informacja,
  że~jest to maszyna przeznaczona do liczenia, więc siłą rzeczy należy
  coś powiedzieć o~tym jak komputer zarządza liczbami. Nie będziemy przy
  tym omawiali wszystkich zawiłości jakie dotyczą tego problemu. Na tym
  przedmiocie chcemy przekazać tylko tyle informacji, ile jest
  naszym zdaniem potrzebne do wyrobienia sobie podstawowych intuicji.
  Za głębsze wniknięcie w~naturę rzeczy odpowiedzialne są inne przedmioty.

  Zaczniemy od pewnie dość nudnego dla większości osób przyjrzenia~się
  potęgom liczby~$2$. W~informatyce bardzo lubimy liczbę~$2$. By być wiernym
  duchowni języka~C równość dwóch liczb oznaczamy symbolem $==$. \\
  $2^{ \HorSpaceTwo 0 } == 1$ \\[0.1em]
  $2^{ \HorSpaceTwo 1 } == 2$ \\[0.1em]
  $2^{ \HorSpaceTwo 2 } == 4$

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wybrane potęgi liczby~$2$}


  $2^{ \HorSpaceTwo 3 } == 8$ \\[0.1em]
  $2^{ \HorSpaceTwo 4 } == 16$ \\[0.1em]
  $2^{ \HorSpaceTwo 5 } == 32$ \\[0.1em]
  $2^{ \HorSpaceTwo 6 } == 64$ \\[0.1em]
  $2^{ \HorSpaceTwo 7 } == 128$ \\[0.1em]
  $2^{ \HorSpaceTwo 8 } == 256$ \\[0.1em]
  $2^{ \HorSpaceTwo 9 } == 512$ \\[0.1em]
  $2^{ \HorSpaceTwo 10 } == 1 \; 024$ \\[0.1em]
  $2^{ \HorSpaceTwo 11 } == 2 \; 048$ \\[0.1em]
  $2^{ \HorSpaceTwo 12 } == 4 \; 096$ \\[0.1em]
  $2^{ \HorSpaceTwo 15 } == 32 \; 768$ \\[0.1em]
  $2^{ \HorSpaceTwo 16 } == 65 \; 536$

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wybrane potęgi liczby~$2$}


  Liczby $2^{ \HorSpaceTwo 16 } == 65 \; 536$
  i~$2^{ \HorSpaceTwo 16 } - 1 == 65 \; 535$ pojawiają~się
  często w~różnych działach techniki, gdyż często zachodzi potrzeba
  przesyłania informacji, której podstawową jednostką są dwa bajty,
  czyli $16$~bitów.

  $2^{ \HorSpaceTwo 17 } == 131 \; 072$ \\[0.1em]
  $2^{ \HorSpaceTwo 18 } == 262 \; 144$ \\[0.1em]
  $2^{ \HorSpaceTwo 19 } == 524 \; 288$ \\[0.1em]
  $2^{ \HorSpaceTwo 20 } == 1 \; 048 \; 576$ \\[0.1em]
  $2^{ \HorSpaceTwo 21 } == 2 \; 097 \; 152$ \\[0.1em]
  $2^{ \HorSpaceTwo 22 } == 4 \; 194 \; 304$ \\[0.1em]
  $2^{ \HorSpaceTwo 23 } == 8 \; 388 \; 608$ \\[0.1em]
  $2^{ \HorSpaceTwo 24 } == 16 \; 777 \; 216$ \\[0.1em]
  $2^{ \HorSpaceTwo 25 } == 33 \; 554 \; 432$ \\[0.1em]
  $2^{ \HorSpaceTwo 26 } == 67 \; 108 \; 864$ \\[0.1em]
  $2^{ \HorSpaceTwo 27 } == 134 \; 217 \; 728$

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wybrane potęgi liczby~$2$}


  $2^{ \HorSpaceTwo 28 } == 268 \; 435 \; 456$ \\[0.1em]
  $2^{ \HorSpaceTwo 29 } == 536 \; 870 \; 912$ \\[0.1em]
  $2^{ \HorSpaceTwo 30 } == 1 \; 073 \; 741 \; 824$ \\[0.1em]
  $2^{ \HorSpaceTwo 31 } == 2 \; 147 \; 483 \; 648$ \\[0.1em]
  $2^{ \HorSpaceTwo 32 } == 4 \; 294 \; 967 \; 296$

  Liczba $2^{ \HorSpaceTwo 32 } == 4 \; 294 \; 967 \; 296$ jest bardzo ważna
  dla wszystkich \\
  systemów i~programów $32$-bitowych, czyli takich w~których
  naturalną jednostką przesyłu informacji są właśnie $32$ bity ($4$~bajty).

  $2^{ \HorSpaceTwo 63 } == 9 \; 223 \; 372 \; 036 \; 854 \; 775 \; 808 \approx
  9 \cdot 10^{ 18 }$ \\
  Słownie: dziewięć trylionów, dwieście dwadzieścia trzy biliardy, trzysta
  siedemdziesiąt dwa biliony, trzydzieści sześć miliardów, osiemset
  pięćdziesiąt cztery miliony, siedemset siedemdziesiąt pięć tysięcy,
  osiemset osiem. \\
  Prościej: $9$~trylionów, $223$~biliardy, $372$~biliony,
  $36$~miliardy, $854$~miliony, $775$~tysięcy, $808$.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Wybrane potęgi liczby~$2$}


  $2^{ \HorSpaceTwo 64 } == 18 \; 446 \; 744 \; 073 \; 709 \; 551 \; 616 \approx
  18 \cdot 10^{ 18 }$ \\
  Słownie: osiemnaście trylionów, czterysta czterdzieści sześć biliardów,
  siedemset czterdzieści cztery biliony, siedemdziesiąt trzy miliardy,
  siedemset dziewięć milionów, pięćset pięćdziesiąt jeden milionów,
  sześćset szesnaście. \\
  Prościej: $18$ trylionów, $446$ biliardów, $744$ biliony, $73$ miliardy,
  $709$ milionów, $551$ tysięcy, $616$.

  Jak ktoś~się tej liczby nauczy na pamięć, to zasługuje na $5$~dodatkowych
  punktów.

  Liczba ta jest oczywiście bardzo ważna, dla systemów $64$-bitowych.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Systemy pozycyjny zapisu liczb naturalnych}


  Sposoby zapisu liczb w~komputerze to naprawdę temat na osobny wykład,
  taki jak metody numeryczne. My zaczniemy od~prostej dyskusji jak komputery
  zapisują liczby naturalne, w~miarę potrzeby omawiając bardziej zaawansowane
  tematy.

  Zacznijmy od krótkiego odświeżenia najlepiej nam znanego systemu
  pozycyjnego, czyli tego opartego o~liczbę~$10$. Liczby w~tym systemie
  czytamy od~prawej do lewej w~następujący sposób. \\
  $123 == 3 \cdot 10^{ \HorSpaceTwo 0 } + 2 \cdot 10^{ \HorSpaceTwo 1 } +
  1 \cdot 10^{ \HorSpaceTwo 2 } == 3 \cdot 1 + 2 \cdot 10 + 1 \cdot 100 == 3 + 20 + 100$ \\
  $456 == 6 \cdot 10^{ \HorSpaceTwo 0 } + 5 \cdot 10^{ \HorSpaceTwo 1 } +
  4 \cdot 10^{ \HorSpaceTwo 2 } == 6 \cdot 1 + 5 \cdot 10 + 4 \cdot 100 == 6 + 50 + 400$ \\
  $2345 == 5 \cdot 10^{ \HorSpaceTwo 0 } + 4 \cdot 10^{ \HorSpaceTwo 1 } +
  3 \cdot 10^{ \HorSpaceTwo 2 } + 2 \cdot 10^{ \HorSpaceTwo 3 } == 5 \cdot 1 + 4 \cdot 10 +
  3 \cdot 100 \, +$ \\
  $+ \, 2 \cdot 1000 == 5 + 40 + 300 + 2000$

  Wzorując~się na języku Go, liczby binarne będziemy zapisywać jako
  $0\text{b}1$, $0\text{b}01$, $0\text{b}111$,~etc. Tak jak w~systemie
  dziesiętnym, czytamy je od prawej do lewej. Prześledźmy teraz
  kilka przykładów.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{System binarny zapisu liczb naturalnych}


  $0\text{b}0 == 0 \cdot 2^{ \HorSpaceTwo 0 } == 0 \cdot 1 == 0$ \\
  $0\text{b}1 == 1 \cdot 2^{ \HorSpaceTwo 0 } == 1 \cdot 1 == 1$ \\
  $0\text{b}10 == 0 \cdot 2^{ \HorSpaceTwo 0 } + 1 \cdot 2^{ \HorSpaceTwo 1 } ==
  0 \cdot 1 + 1 \cdot 2 == 2$ \\
  $0\text{b}11 == 1 \cdot 2^{ \HorSpaceTwo 0 } + 1 \cdot 2^{ \HorSpaceTwo 1 } ==
  1 \cdot 1 + 1 \cdot 2 == 1 + 2 == 3$ \\
  $0\text{b}111 == 1 \cdot 2^{ \HorSpaceTwo 0 } + 1 \cdot 2^{ \HorSpaceTwo 1 } +
  1 \cdot 2^{ \HorSpaceTwo 2 } == 1 \cdot 1 + 1 \cdot 2 + 1 \cdot 4 == 1 + 2 + 4 == 7$ \\
  $0\text{b}10101 == 1 \cdot 2^{ \HorSpaceTwo 0 } + 0 \cdot 2^{ \HorSpaceTwo 1 } +
  1 \cdot 2^{ \HorSpaceTwo 2 } + 0 \cdot 2^{ \HorSpaceTwo 3 } + 1 \cdot 2^{ \HorSpaceTwo 4 } ==
  1 \cdot 1 + 0 \cdot 2 + 1 \cdot 4 \, +$ \\
  $+ \, 0 \cdot 8 + 1 \cdot 16 == 1 + 4 + 16 == 21$

  Jak dobrze wszyscy wiemy, jednostkę która może przechowywać wartość
  $0$ albo $1$ nazywamy \textbf{bitem}. Bity grupujemy dziś w~\textbf{bajty},
  jeden bajt to $2^{ \HorSpaceTwo 3 } == 8$ bitów. W~tym, że~bajt zawiera
  $2^{ \HorSpaceTwo 3 }$ bitów widać upodobanie informatyki do potęgi
  liczby~$2$. Skąd jednak jest to upodobanie.

  Wydaje~się, że~podstawą tego są kwestie techniczne. Zbudowanie urządzenia,
  które może przechowywać dwie różne wartości ($0$ lub $1$), jest prostsze,
  niż takiego, które przechowywałoby trzy wartości ($0$, $1$ lub $2$).
  Warto powiedzieć o~tym kilka słów więcej.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{System binarny zapisu liczb naturalnych}


  Pozostając na bardzo ogólnym poziomie, w~XX wieku eksperymentowano
  z~układami elektronicznymi, których podstawowa jednostka pamięci, była
  w~stanie przechowywać jedną z~trzech wartości ($0$, $1$ lub $2$), jedną
  z~czterech ($0$, $1$, $2$ lub $3$),~etc. Jednostki te odpowiadały temu,
  czemu w~dzisiejszym komputerze odpowiada bit. Gdyby ludzkość
  zdecydowała~się budować komputery w systemie trójkowym, pewnie dzisiaj
  operowalibyśmy „bajtami” o~długości $3^{ 2 } == 9$ „bitów”.

  Różne względy, które są bardziej odpowiednie na bardzo obszerny wykład
  z~elektroniki, sprawiły, iż~zdecydowaliśmy~się oprzeć pamięć komputera
  o~jednostki dwustanowe, czyli właśnie dobrze nam znane bity. Czy tak już
  pozostanie? Przewidywanie przyszłości jest trudne.

  Zadajmy sobie teraz pytanie, ile liczb możemy zapisać za pomocą jednego
  bitu? Dwie $0\text{b}0 == 0$ i~$0\text{b}1 == 1$. Ile zaś za pomocą
  dwóch bitów? Cztery: $0\text{b}00 == 0$, $0\text{b}01 == 1$,
  $0\text{b}10 == 2$ i~$0\text{b}11 == 3$.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{System binarny zapisu liczb naturalnych}


  Zadajmy sobie jeszcze pytanie, ile liczb jesteśmy w~stanie zapisać
  na trzech bitach? Odpowiedź to~$8$: $0\text{b}000 == 0$,
  $0\text{b}001 == 1$, $0\text{b}010 == 2$, $0\text{b}011 == 3$,
  $0\text{b}100 == 4$, $0\text{b}101 == 5$, $0\text{b}110 == 6$
  i~$0\text{b}111 == 7$.

  Te przykłady powinny zilustrować następujący fakt. Mając dostępne
  $n$~bitów możemy za ich pomocą zapisać $2^{ \HorSpaceTwo n }$ stanów. Jest
  to fakt ogólny, którego prosto dowodzi~się matematycznie, jednak
  zajmowanie~się matematycznymi podstawami informatyki, nie należy do zakresu
  tych zajęć. Naszym celem jest pomóc wyrobić sobie Państwu odpowiednią
  intuicję, pozostawiając innym przedmiotom dokładniejsze omówienie tych
  spraw.

  Zwróćmy uwagę na jeszcze jeden fakt. W~tym systemie notacji liczb
  naturalnych, mając do dyspozycji $n$~bitów jeden stan zużywamy na zapisanie
  liczby $0 == 0\text{b}00\ldots0$, pozostałe $2^{ \HorSpaceTwo n - 1 }$ zużywamy
  na zapisanie kolejny liczb naturalnych. Stąd, w~tym konkretnym
  systemie, największą liczbą jaką możemy zapisać na $n$~bitach
  jest $2^{ \HorSpaceTwo n } - 1$.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{System binarny zapisu liczb naturalnych}


  Maksymalna liczba naturalna, jaką w~prezentowanym systemie można zapisać
  na $n$~bitach to $2^{ \HorSpaceTwo n - 1 }$. Ponieważ
  $2^{ \HorSpaceOne 8 } - 1 == 256 - 1 == 255$, to wyjaśnia czemu w~wielu
  miejscach musimy podawać liczby w~zakresie od~$0$ do~$255$. Po porostu
  komputer na zapisanie tej liczby poświęca dokładnie jeden bajt ($8$~bitów).

  System który omówiliśmy nie pozwala zapisywać choć liczb całkowitych
  ujemnych, musi więc zostać odpowiednio rozszerzony. Jednak my nie będziemy
  wnikać w~tego typu zagadnienia, gdyż to co powiedzieliśmy, jest na nasze
  potrzeby wystarczające.

\end{frame}
% ##################










% ######################################
\section{Liczby i~cała reszta}
% ######################################


% ##################
\begin{frame}
  \frametitle{Liczby i~cała reszta}


  Do tej pory powiedzieliśmy sobie jak komputer może zapisywać liczby,
  ale przecież komputer może oprócz liczb zapisywać również wiele innych
  rzeczy, choć litery alfabetu, którymi ta prezentacja jest zapisana. Myśląc
  o~takich sprawach wkraczamy na temat kodowania w~komputerze.

  Zacznijmy od bardzo prostego przykładu, który może~się wydawać
  dziwny, ale jest wbrew pozorom bardzo praktyczny. Jak można zapamiętać
  angielskie słowo „Hello” w~komputerze? Możemy to zrobić w~następujący
  sposób. Wiemy, że~komputer umie zapamiętywać liczby naturalne, więc
  ponumerujmy litery alfabetu (angielskiego) kolejnymi liczbami
  w~następujący sposób. \\
  $\text{A} \to 1$, $\text{B} \to 2$, $\text{C} \to 3$, \ldots, $\text{Z} \to 26$,
  $\text{a} \to 27$, $\text{b} \to 28$, $\text{c} \to 29$, \ldots,
  $\text{z} \to 52$. \\
  Taka odpowiedniość między literami alfabetu angielskiego, a~liczbami
  naturalnymi nazywamy \textbf{kodowaniem}. Dokładniej, zakodowaniem
  znaków jako liczb naturalnych.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Kodowanie liter}


  Możemy teraz zakodować słowo „Hello” jako ciąg liczb
  $8 \; 31 \; 38 \; 38 \; 41$. Niedługo zobaczymy takie kodowanie w~praktyce.
  Teraz możemy komputerowi powiedzieć „Przełącz~się na tryb, w~którym
  każdą liczbę od $1$ do~$52$ rozumiesz jako pewną literę alfabetu
  angielskiego. Jeśli ją napotkasz, to na ekranie wyświetl odpowiedni znak.”

  To wbrew pozorom dobrze opisuje, jak komputery działają, co więcej,
  język~C działa tak cały czas. Jednak zanim powiemy sobie jak język~C
  sobie z~tym radzi, to musimy powiedzieć coś o~systemie kodowania
  \colorhref{https://en.wikipedia.org/wiki/ASCII}{\textsc{ascii}}, który
  w~$2025$ wciąż jest jednym z~fundamentów działania naszych komputerów.

  Akronim \colorhref{https://en.wikipedia.org/wiki/ASCII}{\textsc{ascii}}
  pochodzi od~\textit{American Standard Code for~Information Interchange},
  czyli \textit{Standardowy Amerykański Kod do Wymiany Informacji}.
  Jak sama nazwa wskazuje, został on stworzony przez Amerykanów na ich
  potrzeby, co wyjaśnia dlaczego opiera~się na alfabecie angielskim.
  Dlatego też niektórzy uważają, że~powinno~się go nazywać
  \textsc{us-ascii}.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Historia kodu ASCII}


  Powstanie kodu \textsc{ascii} zaczyna~się w~$1961$ roku. Należy sobie
  uświadomić jak wówczas wyglądała świat komputerów. Komputery potrafiły
  zajmować całe pokoje, internet nie był nawet marzeniem, a~przenoszenie
  danych z~jednego komputera polegało na nagraniu danych na kartki papieru
  lub dysk, przeniesienia ich do budynku, gdzie znajduje~się drugi komputer
  i~wgraniu ich do niego.

  I~tu pojawia~się problem. Co jeśli na jednym komputerze zapisywaliśmy
  literę „A” jako liczbę~$1$, ale na drugim komputerze, ktoś przypisał jej
  wartość~$33$? Wbrew pozorom takie sytuacje~się zdarzały dość często
  i~doprowadzały, jak łatwo~się domyślić, użytkowników komputerów do
  rozpaczy.

  Rozwiązanie wydawało~się dość proste. Utwórzmy standard kodowania, którym
  będziemy~się wszyscy posługiwać i~dzięki któremu na każdym komputerze
  literze~„A”, będzie odpowiadała ta sama liczba.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Historia kodu ASCII}


  Wprowadzanie tej idei w~życie rozpoczął pracujący wówczas dla firmy
  \textsc{ibm} \colorhref{https://en.wikipedia.org/wiki/Bob\_Bemer}{Bob
    Bemer}, który w~maju $1961$~roku złożył projekt takiego standardu
  do organizacji, która dziś nosi nazwę
  \colorhref{https://en.wikipedia.org/wiki/American\_National\_Standards\_Institute}
  {American National Standards Institute}.

  W~tamtych czasach pamięć była droga, każdy bit~się liczył, zaś bajt liczący
  osiem bitów nie był jeszcze powszechnie przyjętym standardem. Po ustaleniu,
  że~potrzeba im standardu dla około $100$ znaków, wzięto najmniejszą
  liczbę bitów, która zapewnia taką liczbę stanów. Liczbą tą jest~$7$,
  bo~$2^{ \HorSpaceTwo 7 } = 128$. Tym samy kodowanie \textsc{ascii} zawiera
  $128$ znaków, przypisane liczbom od~$0$ do~$127$ (proszę zauważyć,
  że~tych liczb jest dokładnie~$128$).

  Pełną tabelę znaków \textsc{ascii} można znaleźć choćby
  \colorhref{https://www.ascii-code.com/}{tutaj}. Pierwsze $32$ znaki tego
  kodu to tzw. znaki kontrolne (ang. \textit{control characters}). Nie są to
  znaki w~sensie języka codziennego, ile raczej symbole służące do kontroli
  pracy komputera.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Struktura kodu ASCII}


  Liczbie $0$ przypisany jest symbol null, służący do~informowania komputera,
  że~coś uległo zakończeniu. Opowiemy sobie o~nim więcej, gdy będziemy
  mówić o~stringach (napisach) w~języku~C. Symbol o~numerze~$2$ informuje
  komputer, że~właśnie rozpoczyna~się pewien tekst, symbol o~numerze~$3$,
  że~ten tekst~się właśnie kończy, symbol~$4$ oznacza zakończenie przesyłu
  danych,~etc. Nie muszą Państwo tego pamiętać, to jest ważne tylko by
  wyjaśnić, czemu \textsc{ascii} ma taki kształt, a~nie inny. Musiał on
  bowiem wziąć pod uwagę wiele zagadnień technicznych, przed którymi
  stanęli jego twórcy w~latach $60$-tych XX~wieku.

  Ostatecznie, literom alfabetu angielskiego przyporządkowano następujące
  liczby. $\text{A} \to 65$, $\text{B} \to 66$, $\text{C} \to 67$, \ldots,
  $\text{Z} \to 90$, $\text{a} \to 97$, $\text{b} \to 98$, $\text{c} \to 99$,
  \ldots, $\text{z} \to 122$. Oprócz tego znakowi przecinka przyporządkowano
  liczbę~$44$, kropce $46$, średnikowi $59$,~etc.

\end{frame}
% ##################






% ##################
\begin{frame}
  \frametitle{Struktura kodu ASCII}


  Ponieważ \textsc{ascii} stworzyli amerykanie, więc zawiera tylko litery
  alfabetu angielskiego. W~jaki sposób kodowane są dziś litery takie jak
  „ą”, czy „ć” to temat na zupełnie inny wykład.

  Nie będziemy od Państwa wymagać znajomości tego wszystkiego. Nasza opowieść
  o~\textsc{ascii} zawiera pewne uproszczenia, gdyż jej główny celem było
  dostarczenie Państwu informacji, pozwalające zrozumieć pewne cechy
  języka~C, które bez tego mogłyby~się wydawać, zupełnie bezsensowne.
  Teraz zaś możemy przejść bezpośrednio do kodowania w~języku~C.

\end{frame}
% ##################





% ######################################
\section{Wprowadzenie do liczb pseudolosowych}
% ######################################


% ##################
\begin{frame}
  \frametitle{Czemu potrzebujemy liczb pseudolosowych?}


  Zacznijmy od dyskusji problemu pozornie odległego od informatyki. Mamy
  fabrykę, która produkuje maszynki do golenia. Wyprodukowaliśmy milion
  maszynek, wzięliśmy jedną do ręki, ona zaś złamała~się od razu. Jeśli
  wyślemy takie maszynki do sklepów, bo klienci przestaną je kupować, a~my
  tego nie chcemy. Stajemy jednak przed pytaniem, ile maszynek z~miliona
  jest tak niskiej jakości? Jeśli jest ich $900 \, 000$ to lepiej wszystkie
  policzyć na straty, bo sprzedaż ich tylko zniszczy nam reputację. Co jeśli
  jednak tylko $1000$ jest w~tak złym stanie i~my przypadkowo wybraliśmy
  jedną z~nich? Wtedy oczywiście należy wysłać cały milion do sklepów, gdyż
  $1000$ klientom którzy mieli pecha, po prostu zwrócimy maszynki na koszt
  firmy.

  Jak jednak stwierdzić, ile maszynek jest dobrych, a~ile złych? Nie
  sprawdzimy każdej z~miliona, bo to za dużo kosztuje. Możemy jednak
  sprawdzić spokojnie $100$. Tylko które $100$?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czemu potrzebujemy liczb pseudolosowych?}


  Jeśli sprawdzimy ostatnie $100$ wyprodukowanych, to może się okazać,
  że~maszyna zepsuła~się pod koniec, ostatni $1000$ maszynek jest przez to
  do utylizacji, ale wszystkie inne są dobre. Jeśli więc będziemy mieli
  pecha, to wyciągniemy błędny wniosek z~jakości $100$ maszynek i~zmarnujemy
  dobre $999 \, 000$.

  To może wziąć $100$ pierwszych maszynek? Ale co jeśli maszyna zepsuła~się
  po wyprodukowaniu pierwszego tysiąca, wtedy $100$ pierwszych maszynek
  jest dobra, a~my wyślemy do sklepów $999 \, 000$ zepsutych, co zrujnuje
  nam reputację. To może wziąć $100$ maszynek ze środka?

  Dziedziny matematyki jakimi są rachunek prawdopodobieństwa i~statystyka,
  podpowiadają nam jakie są optymalne strategie radzenia sobie z~takimi
  problemami. Ponieważ wątpimy, że~Państwo chcą słuchać o~tych sprawach,
  wspominamy o~tym tylko dlatego, że~stanowi to motywację, dla tego
  co będziemy robić.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Czemu potrzebujemy liczb pseudolosowych?}


  Jedną z~dobrych strategii poradzenia sobie z~tym problemem, jest
  ponumerowanie wszystkich maszynek od~$1$ do~$1 \, 000 \, 000$, wylosowanie
  $100$ liczb z~tego zakresu w~sposób losowy, następnie przetestowanie
  tak wylosowanych maszynek. W~zależności od tego jak wiele z~tych maszynek
  było dobrej jakości, a~ile zepsutych, podejmiemy decyzję co zrobić
  z~całą liczącą $1 \, 000 \, 000$ sztuk produkcją. Oczywiście, może~się
  zdarzyć, iż~mamy wielkiego pecha i~wyciągniemy zupełnie błędny wniosek,
  ale użyta metoda pozwala bardzo mocno ograniczyć wystąpienie takich
  sytuacji.

  Dzisiaj takie analizy testowania jakości potrafią być już bardzo złożone
  i~powyższy przykład nie powinien być traktowany jako nic więcej, niż
  prosta ilustracja problemu. Nas zaś zostawia z~następującym pytaniem: skąd
  wziąć $100$ liczb losowy z~zadanego przedziału?

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Skąd wziąć liczby (pseudo)losowe?}


  W~dzisiejszych czasach zwykle wtedy siadamy do komputera i~prosimy go
  o~wygenerowanie nam $100$~odpowiednich liczb. I~tutaj wracamy do
  informatyki.

  Okazuje~się, że~znalezienie liczb naprawdę losowy jest niezwykle trudne.
  Teoria prawdopodobieństwa i~statystyka pozwalają nam znaleźć prawie
  idealne rozwiązania wielu praktycznych problemów, jeśli tylko umiem
  znaleźć prawdziwie losowy zestaw liczb. W~poprzednim przykładzie były to
  numery wyprodukowanych maszynek. Włożono więc bardzo wiele wysiłku
  w~szukanie liczb (pseudo)losowych oraz testowanie, czy dany ciąg liczb
  jest odpowiednio dobry.

  Dzisiejsze wymagania nauki, techniki i~gospodarki sprawiły, że~nasze metody
  badania czy coś jest losowe, stały~się niezwykle subtelne i~wiele źródeł
  liczb losowych musiało zostać odrzuconych jako nie dość dobre.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Skąd wziąć liczby (pseudo)losowe?}


  Przykładowo biorę monetę i~wyrzucam ciąg $\text{O}$, $\text{O}$,
  $\text{O}$, $\text{R}$ ($\text{O}$~-- orzeł, $\text{R}$~-- reszka)
  i~przypisuję orłowi wartość~$1$, a~reszce~$0$, dostaje więc liczbę
  $0\text{b}1110 == 14$. Jednak moneta nie jest nigdy idealnie wyważona,
  więc rzucając nią, będziemy dostawali, przykładowo, trochę więcej orłów,
  niż reszek. Nasze dzisiejsze wymagania odnośnie jakości liczb losowych
  są tak wysokie, że~tego typu odstępstwa od prawdziwej losowości, już
  skreślają daną metodę dla nas.

  Również tego przykładu nie należy traktować specjalnie poważnie. Od jego
  zgodności z~rzeczywistością ważniejsza jest ogólna idea, która za nim
  stoi.

  Mam nadzieję, że~to Państwa przynajmniej trochę przekonało, że~liczby
  losowe są przydatne w~wielu praktycznych problemach, również
  w~informatyce. Jednak przykład z~fabryką maszynek jest prostszy do
  zrozumienia, niż problemy napotykane w~informatyce.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Skąd wziąć liczby (pseudo)losowe?}


  Jeśli nie umiemy znaleźć liczb naprawdę losowych, to może uda nam~się
  znaleźć liczby, które są wystarczająco podobne do losowych? Takie
  właśnie liczby, które nie są naprawdę losowe, ale są do nich
  wystarczająco podobne nazywamy liczbami
  \colorhref{https://en.wikipedia.org/wiki/Pseudorandomness}
  {pseudolosowymi}. Generowanie takich liczb to wciąż otwarta dziedzina
  badań, ale najbardziej podstawowe idea nie są trudne do zrozumienia.

  Zacznijmy od znalezienia funkcji, która zmienia~się w~bardzo
  „nieprzewidywalny” sposób. Przykład takiej funkcji napisanej w~języku~C,
  można znaleźć w~pliku ????

  Zaprezentowana tam funkcja \texttt{generatePseudoRandomNumber()} jest
  funkcją deterministyczną, czyli \texttt{generatePseudoRandomNumber(0)}
  zawsze zwraca liczbę $33$, \texttt{generatePseudoRandomNumber(1)}
  zwraca $308$, \texttt{generatePseudoRandomNumber(2)} zwraca $34$, etc.
  Jednak powiedzenie nawet w~przybliżeniu, ile będzie wynosiła wartość
  tej funkcji na wybrany argumencie, nie jest zadaniem prostym.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Skąd wziąć liczby (pseudo)losowe?}


  Mają już taką „nieprzewidywalną” funkcję, wybieramy liczbę zwaną
  „ziarnem” (ang.~\textit{seed}). Wybór ziarna jest zupełnie dowolny,
  możemy je na przykład otrzymać rzucają kostką. Następnie obliczamy
  wartość \texttt{generatePseudoRandomNumber(ziarno)}. Myśl za tym stoi
  jest mniej więcej taka. Jeśli mam „trochę losową” liczbę jaką jest ziarno
  i~wrzucę ją do „nieprzewidywalnej” funkcji, to rezultat zwrócony przez tę
  funkcję będzie „bardziej losowy”, niż to od czego zacząłem.

  Istnieje wielka literatura na temat tego, co to znaczy być mniej lub
  bardziej losowym i~jestem przekonany, że~nikt z~Państwa nie chce o~tym
  słuchać. Na tym kursie zupełnie wystarczy intuicyjne zrozumienie tego
  zagadnienia.

\end{frame}
% ##################





% ##################
\begin{frame}
  \frametitle{Skąd wziąć liczby (pseudo)losowe?}


  Wróćmy jeszcze na chwilę do naszej funkcji generującej pseudolosowe liczby
  \texttt{generatePseudoRandomNumber(ziarno)}. Funkcje tego typu
  noszą nazwę \textbf{generatorów liczb pseudolosowych}, choć niewątpliwie
  ta konkretna funkcja jest wyjątkowo kiepskim generatorem takich liczb.
  Jestem ze sposób poprawienia działania takich funkcji jest wywołanie
  jej na samej sobie, w~sposób pokazany w~pliku ???.

  To jakiego generator liczb pseudolosowych należy użyć, zależy w~dużej
  mierze od~tego, jak dobrych liczb tego typu potrzebujemy by~rozwiązać
  nasz problem? Jako, że~to jest tylko kurs \textit{Podstaw informatyki},
  chcieliśmy jedynie zarysować przed Państwem ten problem oraz pokazać,
  jakie narzędzia daje nam w~tej kwestii język~C.

\end{frame}
% ##################




% % ############################
% \jagiellonianendslide{Czy są jakieś pytania do tej części?}
% % ############################































% ####################################################################
% ####################################################################
% Bibliography

\printbibliography





% ############################
% End of the document

\end{document}
